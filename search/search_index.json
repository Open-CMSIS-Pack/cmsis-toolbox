{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CMSIS-Toolbox Thank you for using the CMSIS-Toolbox that provides command-line tools for: Project creation and build of embedded applications that utilize software packs . Various compilation tools are supported. Pack creation, maintenance, and distribution of software packs in Open-CMSIS-Pack format . Manual Chapters Overview of the CMSIS-Toolbox with tool workflow and benefits such as command-line and IDE usage. Installation explains the setup of the CMSIS-Toolbox along with a build environment for embedded applications that are based on Arm Cortex-M processors. Build Overview describes the overall concept, outlines the csolution project files that describes the software application, and contains references to examples and project templates. Build Tools contains command line descriptions for cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). CMSIS Solution Project File Format is a detailed description of the csolution project files that define the software application in YAML format. Create Applications explains how to start projects using software packs. It covers also linker script creation, software pack structure, and project maintenance with pack upgrades. Reference Applications explains how to use and create examples that show middleware usage on on many different evaluation boards including custom hardware. Configure STM32 Devices with STM32CubeMX explains how to use STM32CubeMX to manage device and board configuration. Configure NXP Devices with MCUXpresso Config Tools shows how to use MCUXpresso Config Tools to manage device and board configuration. Build Information Files details the build information generated by the csolution tool. Build Operation contains for advanced users further details about build process, CMake backend configuration, and generator integration. Pack Creation describes how to create software packs that optionally include examples and explains the pack creation tools packchk (software pack verification) and svdconv (SVD file verification and header file generator). Revision History Version Description 2.6.0 CMSIS-Toolbox 2.6.0 ; extends pack: version specifier and C language support to C17 and C23. Improved is regions header file generation for linker scripts. It adds trustzone: secure-only for projects without secure entries, apis , messages , and PLM status for config files to cbuild.yml information, and fixes several minor issues. It is no longer possible to specify compiler in the cdefault.yml file. 2.5.0 CMSIS-Toolbox 2.5.0 ; direct CMake interface is now default, tmpdir: controls location of interim files, adds add-path-asm: , adds define-asm , adds regular expression search to for-context: / not-for-context , and contains several corrections. 2.4.0 CMSIS-Toolbox 2.4.0 ; adds CubeMX integration , pre/post-build steps , simplifies the generator integration , and contains several corrections. 2.3.0 CMSIS-Toolbox 2.3.0 adds in the csolution project files component instances and optimize: debug . Tools are extended with cbuild setup command , --frozen-pack option . Refer to release information for more details. 2.2.0 CMSIS-Toolbox 2.2.0 adds generator integration , extends translation controls , adds context set , adds pack locking , and improves linker script management . Refer to release information for more details. 2.0.0 Initial release for CMSIS-Toolbox 2.0.0","title":"Home"},{"location":"#cmsis-toolbox","text":"Thank you for using the CMSIS-Toolbox that provides command-line tools for: Project creation and build of embedded applications that utilize software packs . Various compilation tools are supported. Pack creation, maintenance, and distribution of software packs in Open-CMSIS-Pack format .","title":"CMSIS-Toolbox"},{"location":"#manual-chapters","text":"Overview of the CMSIS-Toolbox with tool workflow and benefits such as command-line and IDE usage. Installation explains the setup of the CMSIS-Toolbox along with a build environment for embedded applications that are based on Arm Cortex-M processors. Build Overview describes the overall concept, outlines the csolution project files that describes the software application, and contains references to examples and project templates. Build Tools contains command line descriptions for cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). CMSIS Solution Project File Format is a detailed description of the csolution project files that define the software application in YAML format. Create Applications explains how to start projects using software packs. It covers also linker script creation, software pack structure, and project maintenance with pack upgrades. Reference Applications explains how to use and create examples that show middleware usage on on many different evaluation boards including custom hardware. Configure STM32 Devices with STM32CubeMX explains how to use STM32CubeMX to manage device and board configuration. Configure NXP Devices with MCUXpresso Config Tools shows how to use MCUXpresso Config Tools to manage device and board configuration. Build Information Files details the build information generated by the csolution tool. Build Operation contains for advanced users further details about build process, CMake backend configuration, and generator integration. Pack Creation describes how to create software packs that optionally include examples and explains the pack creation tools packchk (software pack verification) and svdconv (SVD file verification and header file generator).","title":"Manual Chapters"},{"location":"#revision-history","text":"Version Description 2.6.0 CMSIS-Toolbox 2.6.0 ; extends pack: version specifier and C language support to C17 and C23. Improved is regions header file generation for linker scripts. It adds trustzone: secure-only for projects without secure entries, apis , messages , and PLM status for config files to cbuild.yml information, and fixes several minor issues. It is no longer possible to specify compiler in the cdefault.yml file. 2.5.0 CMSIS-Toolbox 2.5.0 ; direct CMake interface is now default, tmpdir: controls location of interim files, adds add-path-asm: , adds define-asm , adds regular expression search to for-context: / not-for-context , and contains several corrections. 2.4.0 CMSIS-Toolbox 2.4.0 ; adds CubeMX integration , pre/post-build steps , simplifies the generator integration , and contains several corrections. 2.3.0 CMSIS-Toolbox 2.3.0 adds in the csolution project files component instances and optimize: debug . Tools are extended with cbuild setup command , --frozen-pack option . Refer to release information for more details. 2.2.0 CMSIS-Toolbox 2.2.0 adds generator integration , extends translation controls , adds context set , adds pack locking , and improves linker script management . Refer to release information for more details. 2.0.0 Initial release for CMSIS-Toolbox 2.0.0","title":"Revision History"},{"location":"CreateApplications/","text":"Create Applications The following chapter explains the structure of a software pack and how it can be used in an application. Start a Project An application is based on a device and/or board supported by a Device Family Pack (DFP) or Board Support Pack (BSP). The steps to start a project are: Step: Install the DFP and BSP Use Device search or Board search available on web portals to identify the software packs required for your target. Download the Device Family Pack (DFP) and optionally the Board Support Pack (BSP) with cpackget . Note that a BSP is only required if you want to work with a specific board. For custom hardware, typically the DFP is sufficient. Step: Use a Template Project and add DFP and BSP Select a suitable generic Template Project or refer to the DFP documentation as some devices have specific template projects. Copy the template project and open the *.csolution.yml file. Add under packs: the packs identified in step (1). You may omit the version number during initial project development. : compiler: AC6 # List the packs that define the device and/or board. packs: - pack: AnalogDevices::ADuCM320_DFP : Step: Use csolution list to identify the device or board Use csolution list devices <name>.csolution.yml or csolution list boards <name>.csolution.yml to get the device or board name. Enter the device or board name under target-types: . A device is typically used for custom hardware. : target-types: - type: ADuCM320-Board # choose a brief name for your target hardware # device: MyDeviceName # replace with your device or comment out to use a board board: Analog Devices::EVAL-ADuCM320EBZ # you may omit version information : Step: Add required software components Most projects at least require the CMSIS:CORE and Device:Startup (or a variant) software components to be present. Use csolution list components <name>.csolution.yml to identify the name of the startup component and add it to the file *.cproject.yml of your project. Use csolution list components <name>.csolution.yml to identify additional software components from the selected packs. Use the components: in the <name>.cproject.yml file to add new components and refer to related documentation for usage instructions. Note that you may omit vendor and version information for components as this is defined already by the packs that are selected. : components: # List components to use for your application - component: CMSIS:CORE # The CMSIS-Core component used in most projects - component: Device:Startup&Baremetal - component: Device:Peripheral Libraries:ADC : Refer to Using Components for more information. Now, the project should already compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Note that this step downloads missing packs and copies configuration files to the RTE directory . Step: Review and configure RTE files Review the configuration files in the RTE directory and refer to the documentation of the software components for instructions. Configure Linker Scripts below explains how to setup physical memory. For simple projects, the default settings should be sufficient. The build information file <name>.cbuild.Debug+<target-name>.yml lists configuration files of components and other useful information such as links to documentation of the component. Step: Add application functionality Implement the application code in C/C++ source files. Use the groups: section in <name>.cproject.yml to add new source files. : groups: - group: Source Files files: - file: main.c - file: MyFile1.c : Again, the project should compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Repeat step (4) when you added new components that require configuration. Note The Arm CMSIS Solution extension for VS Code guides you through these steps with the Create New Solution workflow . Configure Linker Scripts A linker script file defines the physical memory layout for a *.cproject.yml based. It may also allocate specific program sections (for example DMA buffers or non-volatile variables) to special memory regions. While complex devices may use a bespoke linker script to manage multi-core and multi-master bus systems, many single core devices can use the automatic linker script generation of the csolution Project Manager which uses a generic regions header file in combination with a toolchain-specific linker script template . The following section describes the usage of a linker script template and a regions header file which is combined by a C preprocessor into the final linker script file . It uses auto-generated files , but the methods also apply somewhat to bespoke linker scripts. The overall process to configure linker scripts for independent projects is: Step: Review and adjust the physical memory layout in the regions header file . Step: Optionally add specific program sections to the linker script template or change the default behavior of that file. Regions Header File An initial regions header file is generated based on the memory information coming from the used software packs (DFP and BSP). This file has the name regions_<device_or_board>.h and is located in the directory ./RTE/Device/<device> . For memory with the default attribute set in DFP or BSP the following region settings are generated: The region __ROM0 is the startup region and contains memory with the startup attribute set . The region __RAM0 contains uninitialized memory, STACK and HEAP. STACK default is 0x200. HEAP default is 0xC00 for devices with more than 6KB RAM (otherwise HEAP is set to 0). Contiguous memory with same access (rw, rwx, rx) is combined into one region. For memory with the default attribute no set in DFP or BSP, the memory is listed under resources that are not allocated to linker regions . The user may modify this generated regions header file : to adapt the physical memory layout of the project. to add not allocated memory resources to regions __ROM n and __RAM n . Example: regions_B-U585-IOT02A.h header file for a board #ifndef REGIONS_B_U585I_IOT02A_H #define REGIONS_B_U585I_IOT02A_H //-------- <<< Use Configuration Wizard in Context Menu >>> -------------------- //------ With VS Code: Open Preview for Configuration Wizard ------------------- // <n> Auto-generated using information from packs // <i> Device Family Pack (DFP): Keil::STM32U5xx_DFP@3.0.0-dev0 // <i> Board Support Pack (BSP): Keil::B-U585I-IOT02A_BSP@2.0.0-dev0 // <h> ROM Configuration // ======================= // <h> __ROM0 (is rx memory: Flash from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x08000000 // <i> Contains Startup and Vector Table #define __ROM0_BASE 0x08000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00200000 #define __ROM0_SIZE 0x00200000 // </h> // <h> __ROM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM1_SIZE 0 // </h> // <h> __ROM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM2_SIZE 0 // </h> // <h> __ROM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM3_SIZE 0 // </h> // </h> // <h> RAM Configuration // ======================= // <h> __RAM0 (is rwx memory: SRAM1_2 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20000000 // <i> Contains uninitialized RAM, Stack, and Heap #define __RAM0_BASE 0x20000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00040000 #define __RAM0_SIZE 0x00040000 // </h> // <h> __RAM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM1_SIZE 0 // </h> // <h> __RAM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM2_SIZE 0 // </h> // <h> __RAM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM3_SIZE 0 // </h> // </h> // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000C00 // </h> // <n> Resources that are not allocated to linker regions // <i> rwx RAM: SRAM3 from DFP: BASE: 0x20040000 SIZE: 0x00080000 // <i> rwx RAM: RAM-External from BSP: BASE: 0x90000000 SIZE: 0x00800000 // <i> rx ROM: Flash-External from BSP: BASE: 0x70000000 SIZE: 0x04000000 #endif /* REGIONS_B_U585I_IOT02A_H */ Linker Script Template A template linker script file is copied to the directory ./RTE/Device/<device> . The user may modify this file: to specify program sections that require dedicated physical memory regions. to change the allocation behavior of the linker script. Example: DMA section allocation in ac6_linker_script.sct.src linker script template #if __RAM1_SIZE > 0 RW_RAM1 __RAM2_BASE __RAM2_SIZE { *(.RxDecripSection) // added DMA descriptors *(.TxDecripSection) *(.driver.eth_mac0_rx_buf) *(.driver.eth_mac0_tx_buf) .ANY (+RW +ZI) } #endif Note It is recommended to add a note to the regions header file about such user modifications as shown below: // <h> __RAM1 (is rwx memory: SRAM3 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20040000 // <i> Note: DMA descriptors and buffers are in this region Software Components A software component encapsulates a set of related functions. By offering API headers, it provides interfaces to other software components or to the user application. The software pack provides for a software component other optional items such as configuration files, documentation, user code templates that show the usage of the software component, and a debug view description (for CMSIS-View ). A software component typically interfaces to other software components or to device peripherals. In the CMSIS-Pack system software components: Are identified by the node components: using a component name . Use dependencies to describe required interfaces. List API header files for provided interfaces. For example the lwIP network stack: requires an CMSIS-RTOS2 compliant kernel or a FreeRTOS kernel CMSIS-Drivers for the communication interface. List API header files for their interfaces. Required Interfaces There are two ways to describe required interfaces as shown in the diagram below. Dependency reference to a component (a selection list is supported). Dependency reference to a API definition. Components that implement this API fulfill then the required interface. The API definition has the benefit that components which implement the interface can be added over time. The exact component names need not to be known by the component that requires an interface. ToDo: A potential improvement is to use the command csolution list components to show available implementations for a required interface. Using Components The steps to create an application based on software components are: Step: Select software components Install the software pack that provides the required functionality (this could be based on pack datasheets) and identify the required software component(s). Add the pack and the component to your *.cproject.yml file. Run csolution *.csolution.yml list dependencies to identify other required software components. Run csolution list components --filter to identify packs that provide this software components. Repeat this step until all software components are part of your project. Step: Configure software components Run csolution *.csolution.yml update-rte to copy configuration files into the RTE directory . Set the parameters in the configuration files for your application. Step: Use software components in application program User code templates provide a starting point for your application. Copy these template files to your project directory add add it to your *.cproject.yml file. Adjust the code in the user template files as required. Example: Network Stack In this example, the application requires TCP Socket connectivity. Using the steps described under Using Components delivers this content for *.cproject.yml file. packs: - pack: Keil::MDK-Middleware@7.16.0 - pack: ARM::CMSIS@5.9.0 - pack: ARM::CMSIS-Driver@2.7.2 - pack: Keil::LPC1700_DFP@2.7.1 components: - component: Network&MDK-Pro Net_v6:Socket:TCP - component: Network&MDK-Pro Net_v6:CORE&Release - component: Network&MDK-Pro Net_v6:Interface:ETH - component: CMSIS:CORE - component: CMSIS:RTOS2:Keil RTX5&Source - component: CMSIS Driver:Ethernet:KSZ8851SNL - component: CMSIS Driver:SPI:SPI - component: Device:PIN - component: Device:GPIO - component: Device:Startup The required interfaces are identified using csolution list dependencies : Adding more components such as a IoT Client would be the next step. Update Software Packs An update of a software pack can be performed with these steps: Download new software packs as needed using cpackget . Use the command csolution convert with the option --load latest to update the software packs. csolution convert Hello.csolution.yml --load latest List potentially outdated configuration files using the command csolution list configs . csolution list configs Hello.csolution.yml --context-set ../RTE/CMSIS/RTX_Config.c@5.1.1 (update@5.2.0) from ARM::CMSIS:RTOS2:Keil RTX5&Source@5.8.0 ../RTE/Device/SSE-300-MPS3/startup_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 ../RTE/Device/SSE-300-MPS3/system_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 Note The text update@version indicates that there is a new configuration file available. Use a merge utility to identify and merge configuration settings from a previous version. Refer to PLM of configuration files for more information.","title":"Create Applications"},{"location":"CreateApplications/#create-applications","text":"The following chapter explains the structure of a software pack and how it can be used in an application.","title":"Create Applications"},{"location":"CreateApplications/#start-a-project","text":"An application is based on a device and/or board supported by a Device Family Pack (DFP) or Board Support Pack (BSP). The steps to start a project are: Step: Install the DFP and BSP Use Device search or Board search available on web portals to identify the software packs required for your target. Download the Device Family Pack (DFP) and optionally the Board Support Pack (BSP) with cpackget . Note that a BSP is only required if you want to work with a specific board. For custom hardware, typically the DFP is sufficient. Step: Use a Template Project and add DFP and BSP Select a suitable generic Template Project or refer to the DFP documentation as some devices have specific template projects. Copy the template project and open the *.csolution.yml file. Add under packs: the packs identified in step (1). You may omit the version number during initial project development. : compiler: AC6 # List the packs that define the device and/or board. packs: - pack: AnalogDevices::ADuCM320_DFP : Step: Use csolution list to identify the device or board Use csolution list devices <name>.csolution.yml or csolution list boards <name>.csolution.yml to get the device or board name. Enter the device or board name under target-types: . A device is typically used for custom hardware. : target-types: - type: ADuCM320-Board # choose a brief name for your target hardware # device: MyDeviceName # replace with your device or comment out to use a board board: Analog Devices::EVAL-ADuCM320EBZ # you may omit version information : Step: Add required software components Most projects at least require the CMSIS:CORE and Device:Startup (or a variant) software components to be present. Use csolution list components <name>.csolution.yml to identify the name of the startup component and add it to the file *.cproject.yml of your project. Use csolution list components <name>.csolution.yml to identify additional software components from the selected packs. Use the components: in the <name>.cproject.yml file to add new components and refer to related documentation for usage instructions. Note that you may omit vendor and version information for components as this is defined already by the packs that are selected. : components: # List components to use for your application - component: CMSIS:CORE # The CMSIS-Core component used in most projects - component: Device:Startup&Baremetal - component: Device:Peripheral Libraries:ADC : Refer to Using Components for more information. Now, the project should already compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Note that this step downloads missing packs and copies configuration files to the RTE directory . Step: Review and configure RTE files Review the configuration files in the RTE directory and refer to the documentation of the software components for instructions. Configure Linker Scripts below explains how to setup physical memory. For simple projects, the default settings should be sufficient. The build information file <name>.cbuild.Debug+<target-name>.yml lists configuration files of components and other useful information such as links to documentation of the component. Step: Add application functionality Implement the application code in C/C++ source files. Use the groups: section in <name>.cproject.yml to add new source files. : groups: - group: Source Files files: - file: main.c - file: MyFile1.c : Again, the project should compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Repeat step (4) when you added new components that require configuration. Note The Arm CMSIS Solution extension for VS Code guides you through these steps with the Create New Solution workflow .","title":"Start a Project"},{"location":"CreateApplications/#configure-linker-scripts","text":"A linker script file defines the physical memory layout for a *.cproject.yml based. It may also allocate specific program sections (for example DMA buffers or non-volatile variables) to special memory regions. While complex devices may use a bespoke linker script to manage multi-core and multi-master bus systems, many single core devices can use the automatic linker script generation of the csolution Project Manager which uses a generic regions header file in combination with a toolchain-specific linker script template . The following section describes the usage of a linker script template and a regions header file which is combined by a C preprocessor into the final linker script file . It uses auto-generated files , but the methods also apply somewhat to bespoke linker scripts. The overall process to configure linker scripts for independent projects is: Step: Review and adjust the physical memory layout in the regions header file . Step: Optionally add specific program sections to the linker script template or change the default behavior of that file.","title":"Configure Linker Scripts"},{"location":"CreateApplications/#regions-header-file","text":"An initial regions header file is generated based on the memory information coming from the used software packs (DFP and BSP). This file has the name regions_<device_or_board>.h and is located in the directory ./RTE/Device/<device> . For memory with the default attribute set in DFP or BSP the following region settings are generated: The region __ROM0 is the startup region and contains memory with the startup attribute set . The region __RAM0 contains uninitialized memory, STACK and HEAP. STACK default is 0x200. HEAP default is 0xC00 for devices with more than 6KB RAM (otherwise HEAP is set to 0). Contiguous memory with same access (rw, rwx, rx) is combined into one region. For memory with the default attribute no set in DFP or BSP, the memory is listed under resources that are not allocated to linker regions . The user may modify this generated regions header file : to adapt the physical memory layout of the project. to add not allocated memory resources to regions __ROM n and __RAM n . Example: regions_B-U585-IOT02A.h header file for a board #ifndef REGIONS_B_U585I_IOT02A_H #define REGIONS_B_U585I_IOT02A_H //-------- <<< Use Configuration Wizard in Context Menu >>> -------------------- //------ With VS Code: Open Preview for Configuration Wizard ------------------- // <n> Auto-generated using information from packs // <i> Device Family Pack (DFP): Keil::STM32U5xx_DFP@3.0.0-dev0 // <i> Board Support Pack (BSP): Keil::B-U585I-IOT02A_BSP@2.0.0-dev0 // <h> ROM Configuration // ======================= // <h> __ROM0 (is rx memory: Flash from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x08000000 // <i> Contains Startup and Vector Table #define __ROM0_BASE 0x08000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00200000 #define __ROM0_SIZE 0x00200000 // </h> // <h> __ROM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM1_SIZE 0 // </h> // <h> __ROM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM2_SIZE 0 // </h> // <h> __ROM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM3_SIZE 0 // </h> // </h> // <h> RAM Configuration // ======================= // <h> __RAM0 (is rwx memory: SRAM1_2 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20000000 // <i> Contains uninitialized RAM, Stack, and Heap #define __RAM0_BASE 0x20000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00040000 #define __RAM0_SIZE 0x00040000 // </h> // <h> __RAM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM1_SIZE 0 // </h> // <h> __RAM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM2_SIZE 0 // </h> // <h> __RAM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM3_SIZE 0 // </h> // </h> // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000C00 // </h> // <n> Resources that are not allocated to linker regions // <i> rwx RAM: SRAM3 from DFP: BASE: 0x20040000 SIZE: 0x00080000 // <i> rwx RAM: RAM-External from BSP: BASE: 0x90000000 SIZE: 0x00800000 // <i> rx ROM: Flash-External from BSP: BASE: 0x70000000 SIZE: 0x04000000 #endif /* REGIONS_B_U585I_IOT02A_H */","title":"Regions Header File"},{"location":"CreateApplications/#linker-script-template","text":"A template linker script file is copied to the directory ./RTE/Device/<device> . The user may modify this file: to specify program sections that require dedicated physical memory regions. to change the allocation behavior of the linker script. Example: DMA section allocation in ac6_linker_script.sct.src linker script template #if __RAM1_SIZE > 0 RW_RAM1 __RAM2_BASE __RAM2_SIZE { *(.RxDecripSection) // added DMA descriptors *(.TxDecripSection) *(.driver.eth_mac0_rx_buf) *(.driver.eth_mac0_tx_buf) .ANY (+RW +ZI) } #endif Note It is recommended to add a note to the regions header file about such user modifications as shown below: // <h> __RAM1 (is rwx memory: SRAM3 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20040000 // <i> Note: DMA descriptors and buffers are in this region","title":"Linker Script Template"},{"location":"CreateApplications/#software-components","text":"A software component encapsulates a set of related functions. By offering API headers, it provides interfaces to other software components or to the user application. The software pack provides for a software component other optional items such as configuration files, documentation, user code templates that show the usage of the software component, and a debug view description (for CMSIS-View ). A software component typically interfaces to other software components or to device peripherals. In the CMSIS-Pack system software components: Are identified by the node components: using a component name . Use dependencies to describe required interfaces. List API header files for provided interfaces. For example the lwIP network stack: requires an CMSIS-RTOS2 compliant kernel or a FreeRTOS kernel CMSIS-Drivers for the communication interface. List API header files for their interfaces.","title":"Software Components"},{"location":"CreateApplications/#required-interfaces","text":"There are two ways to describe required interfaces as shown in the diagram below. Dependency reference to a component (a selection list is supported). Dependency reference to a API definition. Components that implement this API fulfill then the required interface. The API definition has the benefit that components which implement the interface can be added over time. The exact component names need not to be known by the component that requires an interface. ToDo: A potential improvement is to use the command csolution list components to show available implementations for a required interface.","title":"Required Interfaces"},{"location":"CreateApplications/#using-components","text":"The steps to create an application based on software components are: Step: Select software components Install the software pack that provides the required functionality (this could be based on pack datasheets) and identify the required software component(s). Add the pack and the component to your *.cproject.yml file. Run csolution *.csolution.yml list dependencies to identify other required software components. Run csolution list components --filter to identify packs that provide this software components. Repeat this step until all software components are part of your project. Step: Configure software components Run csolution *.csolution.yml update-rte to copy configuration files into the RTE directory . Set the parameters in the configuration files for your application. Step: Use software components in application program User code templates provide a starting point for your application. Copy these template files to your project directory add add it to your *.cproject.yml file. Adjust the code in the user template files as required.","title":"Using Components"},{"location":"CreateApplications/#example-network-stack","text":"In this example, the application requires TCP Socket connectivity. Using the steps described under Using Components delivers this content for *.cproject.yml file. packs: - pack: Keil::MDK-Middleware@7.16.0 - pack: ARM::CMSIS@5.9.0 - pack: ARM::CMSIS-Driver@2.7.2 - pack: Keil::LPC1700_DFP@2.7.1 components: - component: Network&MDK-Pro Net_v6:Socket:TCP - component: Network&MDK-Pro Net_v6:CORE&Release - component: Network&MDK-Pro Net_v6:Interface:ETH - component: CMSIS:CORE - component: CMSIS:RTOS2:Keil RTX5&Source - component: CMSIS Driver:Ethernet:KSZ8851SNL - component: CMSIS Driver:SPI:SPI - component: Device:PIN - component: Device:GPIO - component: Device:Startup The required interfaces are identified using csolution list dependencies : Adding more components such as a IoT Client would be the next step.","title":"Example: Network Stack"},{"location":"CreateApplications/#update-software-packs","text":"An update of a software pack can be performed with these steps: Download new software packs as needed using cpackget . Use the command csolution convert with the option --load latest to update the software packs. csolution convert Hello.csolution.yml --load latest List potentially outdated configuration files using the command csolution list configs . csolution list configs Hello.csolution.yml --context-set ../RTE/CMSIS/RTX_Config.c@5.1.1 (update@5.2.0) from ARM::CMSIS:RTOS2:Keil RTX5&Source@5.8.0 ../RTE/Device/SSE-300-MPS3/startup_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 ../RTE/Device/SSE-300-MPS3/system_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 Note The text update@version indicates that there is a new configuration file available. Use a merge utility to identify and merge configuration settings from a previous version. Refer to PLM of configuration files for more information.","title":"Update Software Packs"},{"location":"CubeMX/","text":"Configure STM32 Devices with CubeMX This chapter explains how to use STM32CubeMX with the CMSIS-Toolbox to manage device and board configuration. Note For the CMSIS-Toolbox CubeMX integration STM32 packs with generator support are required. These software packs contain in the release information: Updated for new CMSIS-Toolbox CubeMX integration . Introduction STM32CubeMX (CubeMX) is a graphical tool for configuration of an STM32 device or board. CubeMX generates C code for project and peripheral initialization, based on user settings. Depending on the device configuration, related drivers are added to the user application. The CMSIS-Toolbox interacts with CubeMX using the generic interface for generators . The component: Device:CubeMX connects a csolution project to CubeMX. This component imports the CubeMX generated files for a selected device: or board: using the generator import file *.cgen.yml . This file is similar to a software layer but managed by CubeMX and should be not modified directly. An example project created with CubeMX can be found in csolution-examples/CubeMX . Note If a board is specified in the csolution project , CubeMX pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the CubeMX dialogs. If a device is specified, the user need to configure the peripherals manually using CubeMX dialogs. Simple Project Below is a simple project that just adds the CubeMX generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: CubeMX.csolution.yml solution: created-for: CMSIS-Toolbox@2.3.0 description: Simple CubeMX example cdefault: # use toolchain default settings compiler: AC6 # select toolchain # it is recommended to list the pack or packs that define the device or board used in the csolution.yml file packs: - pack: ARM::CMSIS # CMSIS pack is required for most projects - pack: Keil::B-U585I-IOT02A_BSP - pack: Keil::STM32U5xx_DFP@>=3.0.0-0 target-types: - type: MyBoard # My evaluation kit board: B-U585I-IOT02A # Board name as defined by the pack build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced projects: # list related projects - project: ./CubeMX.cproject.yml File: CubeMX.cproject.yml project: components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX Such a project cannot be directly built, as initially the *.cgen.yml file is missing. It requires to run the CubeMX generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # generator name base-dir: STM32CubeMX/MyBoard # directory for generated files context: CubeMX.Debug+MyBoard # list of context that uses this directory context: CubeMX.Release+MyBoard Use the information above to run the generator: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard This starts CubeMX and passes the information about the selected board, device, and select toolchain. For a project that selects a board, CubeMX imports the default configuration for it. In CubeMX, review and adjust configuration options as required for your application, then just click the button GENERATE CODE . The generated files will be stored in the directory STM32CubeMX/MyBoard . Build the project using this command: cbuild CubeMX.csolution.yml --update-rte Note You may run the CubeMX generator any time to change the configuration setting of your device or board. Directory with generated files CubeMX generates the following content in the generator output directory of the csolution project . In our example the generator output directory is STM32CubeMX/MyBoard . Directory STM32CubeMX/MyBoard Content CubeMX.cgen.yml Generator import file that adds the CubeMX generated files to the csolution project . MX_Device/CubeMX/MX_Device.h Header file with configuration settings for CMSIS software components. STM32CubeMX/STM32CubeMX.ioc CubeMX native project file that includes settings. STM32CubeMX/Src CubeMX generated application code: main.c and STM32 setup code. STM32CubeMX/Inc Header files for CubeMX generated application code. STM32CubeMX/EWARM Project files for IAR; only startup code and linker scripts are used for csolution projects . STM32CubeMX/GCC Project files for GCC; only startup code and linker scripts are used for csolution projects . STM32CubeMX/MDK-ARM Project files for MDK version 5; only startup code and linker scripts are used for csolution projects . [!NOTE] CubeMX generates only the directory for the selected toolchain which is either STM32CubeMX/EWARM , STM32CubeMX/GCC , or STM32CubeMX/MDK-ARM . Content of Generator Import File: CubeMX.cgen.yml The file *.cgen.yml lists the files and settings that are generated by CubeMX and imported in the csolution project . The files under group: CubeMX may be modified by the user in sections marked with USER CODE BEGIN and USER CODE END to implement the application specific features. In the file *.cproject.yml additional user files can be added. generator-import: for-device: STM32U585AIIx for-board: B-U585I-IOT02A define: - USE_FULL_LL_DRIVER - USE_HAL_DRIVER - STM32U585xx add-path: - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc/Legacy - ./STM32CubeMX/Drivers/CMSIS/Device/ST/STM32U5xx/Include - ./STM32CubeMX/Inc - ./MX_Device/CubeMX groups: - group: CubeMX files: - file: ./STM32CubeMX/Src/main.c - file: ./STM32CubeMX/Src/stm32u5xx_it.c - file: ./STM32CubeMX/Src/stm32u5xx_hal_msp.c - file: ./STM32CubeMX/MDK-ARM/startup_stm32u585xx.s - file: ./STM32CubeMX/Src/system_stm32u5xx.c - group: STM32 HAL Driver files: - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_utils.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_exti.c : - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_hal_pcd_ex.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_usb.c Adding an RTOS Many applications require an RTOS kernel. By default, CubeMX implements interrupts functions for all Cortex-M exception handlers. However, some exception handlers are typically required for the RTOS kernel execution. Adding an RTOS kernel requires these steps: Add the RTOS kernel to application (in this case RTX) File: CubeMX.cproject.yml project: packs: - pack: ARM::CMSIS-RTX # RTOS Software Pack groups: - group: MyApp files: - file: MyMain.c components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX - component: CMSIS:RTOS2:Keil RTX5&Source # RTOS component - component: CMSIS:OS Tick:SysTick # OS Tick implementation for RTOS Note The example above uses CMSIS-RTX as the RTOS kernel, other kernels require different components and packs, but the concept is similar. Configure interrupt handlers in CubeMX Run CubeMX with: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard Open the dialog Pinout & Configuration - System Core NVIC - Code generation and disable Generate IRQ handler for: System service call via SWI instruction Pendable request for system service System tick timer Then click the button GENERATE CODE to update the generated files in the directory STM32CubeMX/MyBoard Linker Script Depending on the project type and toolchain, CubeMX provides a linker script. For compiler: AC6 : no linker script is generated for a simple memory. In this case, the default linker script from the CMSIS-Toolbox is used, but needs a modification: remove ARM_LIB_HEAP and ARM_LIB_STACK as they are defined in the STM32 startup file. a linker script is provided for more complex projects (typically when using the CubeMX Memory Manager). For compiler: GCC or compiler: IAR , a linker script is always provided. Note The linker script that is provided by CubeMX is defined in the *.cgen.yml and imported into the csolution project . Use CubeMX with Board Layer A software layer is a set of pre-configured software components and source files for re-use in multiple projects. A board layer contains typically basic I/O drivers and related device and board configuration. For a board layer, CubeMX can be used to generate device configuration and peripheral drivers. As a board layer uses a separate directory that is independent of a specific csolution project the location of the STM32CubeMX generated files should be specified using the generators: node in the <board>.clayer.yml file. This locates the CubeMX generated files in the directory structure of the software layer . As a board layer is used by several projects, the name of the generator import file should be also explicitly specified as shown below: generators: options: - generator: CubeMX path: ./CubeMX # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`. This configuration results in the following directory structure: Directory and Files Description <board>.clayer.yml Defines the source files and software components of the board layer. CubeMX/ Directory with CubeMX ioc file and other generated files and folders. CubeMX/Board.cgen.yml Generator import file that lists CubeMX generated files and options. CubeMX/STM32CubeMX/ Directory with CubeMX generated files. CubeMX/STM32CubeMX/Drivers/ Directory with driver related source files. Several STM32 Board Support Packs with Generator Support contain board layers that use such a configuration. For examples, the Nucleo-F756ZG_BSP or B-U585I-IOT02A_BSP . TrustZone or Multi-Core Project Projects that use TrustZone or a multi-core device share the same STM32CubeMX configuration. There is therefore just one directory STM32CubeMX located at the same level as the *.csolution.yml project file. CubeMX Runtime Context Mapping Some devices, for example the STM32H7S series, provide in CubeMX runtime contexts , for example: Boot , Appli , ExtMemLoader . To map the csolution project context to these CubeMX runtime contexts it is required for this type of devices to use map: key in the generator : option as shown below. The STM32H7S series uses the following CubeMX run-time names: Boot for the boot loader. Appli for the user application program. ExtMemLoader for the part that is in external memory. The generators: node is used to map a *.cproject.yml or *.clayer.yml file to a CubeMX run-time context as shown below. generators: options: - generator: CubeMX map: Appli # map project or layer to CubeMX runtime context Migration to CMSIS-Toolbox CubeMX Integration In previous CubeMX integrations a *.gpdsc file is used to import the generator output. The following table compares the CMSIS-Toolbox CubeMX integration (based on *.cgen.yml files) with the previous STM32CubeMX integration (based on *.gpdsc files). Comparison CMSIS-Toolbox *.cgen.yml Integration Previous *.gdpsc Integration IDE Support VS Code , Keil uVision 5.40 or higher Keil uVision, CMSIS-Pack for Eclipse CLI Tools CMSIS-Toolbox 2.4.0 or higher n/a STM32CubeMX project file STM32CubeMX.ioc STCubeGenerated.ioc STM32CubeMX source location ./STM32CubeMX/<target-type/STM32CubeMX/Src ./RTE/Device/<device name>/STCubeGenerated/Src or ./Board/<board name>/STM32CubeMX/Src STM32CubeMX include location ./STM32CubeMX/<target-type/STM32CubeMX/Inc ./RTE/Device/<device name>/STCubeGenerated/Inc or ./Board/<board name>/STM32CubeMX/Inc ST Firmware Provided by STM32Cube Firmware Packs Provided by STM32*_DFP software pack CMSIS-Driver Provided by CMSIS-Driver_STM32 software pack Provided by STM32*_DFP software pack To migrate existing projects that where using the previous STM32CubeMX integration (based on *.gpdsc files) use the following steps: Remove all component: Keil::Device:xxx from the *.cproject.yml file. Add the component: Device:CubeMX to the *.cproject.yml file. Use csolution run *.csolution.yml -g CubeMX to initialize the directory structure. Replace the file STM32CubeMX.ioc with the file STCubeGenerated.ioc from the previous project. Copy source and include files from previous location as they may contain user modifications. Use csolution run *.csolution.yml -g CubeMX to generated the output from the previous STM32CubeMX project. Update the configuration in STM32CubeMX: In the tab Project Manager - Project set Project Settings - Toolchain/IDE to match the compiler selection in the csolution project. In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration. uVision - Update STM32 DFP Packs The Generator Integration of the CMSIS-Toolbox is also available with uVision version 5.40 or higher. New STM32*_DFP software packs that contain in the release information Updated for new CMSIS-Toolbox CubeMX integration require migration. The steps below describe the migration process of an previous CubeMX configuration. In \u00b5Vision open the dialog Manage - Run-Time Environment . Remove all components from Device Cclass as the STM32 device firmware is now managed by CubeMX. Close Manage - Run-Time Environment with OK . Open the dialog Manage - Run-Time Environment again. Select the component Device:CubeMX and start STM32CubeMX with the play button. Update the configuration in STM32CubeMX: In the tab Project Manager - Project set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration. Starting a new project works similar with these steps: In uVision use Project - New uVision Project and select the STM32 device that you want to use. Optional: Project - Manage - Project items tab Project Info / Layer allows to select an evaluation board under Board . Open the dialog Manage - Run-Time Environment . Select the component Device:CubeMX and start STM32CubeMX with the play button. Create a new device configuration in STM32CubeMX: Follow the instructions of STM32CubeMX and verify settings. In the tab Project Manager - Project set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration.","title":"Configure STM32 Devices with STM32CubeMX"},{"location":"CubeMX/#configure-stm32-devices-with-cubemx","text":"This chapter explains how to use STM32CubeMX with the CMSIS-Toolbox to manage device and board configuration. Note For the CMSIS-Toolbox CubeMX integration STM32 packs with generator support are required. These software packs contain in the release information: Updated for new CMSIS-Toolbox CubeMX integration .","title":"Configure STM32 Devices with CubeMX"},{"location":"CubeMX/#introduction","text":"STM32CubeMX (CubeMX) is a graphical tool for configuration of an STM32 device or board. CubeMX generates C code for project and peripheral initialization, based on user settings. Depending on the device configuration, related drivers are added to the user application. The CMSIS-Toolbox interacts with CubeMX using the generic interface for generators . The component: Device:CubeMX connects a csolution project to CubeMX. This component imports the CubeMX generated files for a selected device: or board: using the generator import file *.cgen.yml . This file is similar to a software layer but managed by CubeMX and should be not modified directly. An example project created with CubeMX can be found in csolution-examples/CubeMX . Note If a board is specified in the csolution project , CubeMX pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the CubeMX dialogs. If a device is specified, the user need to configure the peripherals manually using CubeMX dialogs.","title":"Introduction"},{"location":"CubeMX/#simple-project","text":"Below is a simple project that just adds the CubeMX generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: CubeMX.csolution.yml solution: created-for: CMSIS-Toolbox@2.3.0 description: Simple CubeMX example cdefault: # use toolchain default settings compiler: AC6 # select toolchain # it is recommended to list the pack or packs that define the device or board used in the csolution.yml file packs: - pack: ARM::CMSIS # CMSIS pack is required for most projects - pack: Keil::B-U585I-IOT02A_BSP - pack: Keil::STM32U5xx_DFP@>=3.0.0-0 target-types: - type: MyBoard # My evaluation kit board: B-U585I-IOT02A # Board name as defined by the pack build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced projects: # list related projects - project: ./CubeMX.cproject.yml File: CubeMX.cproject.yml project: components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX Such a project cannot be directly built, as initially the *.cgen.yml file is missing. It requires to run the CubeMX generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # generator name base-dir: STM32CubeMX/MyBoard # directory for generated files context: CubeMX.Debug+MyBoard # list of context that uses this directory context: CubeMX.Release+MyBoard Use the information above to run the generator: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard This starts CubeMX and passes the information about the selected board, device, and select toolchain. For a project that selects a board, CubeMX imports the default configuration for it. In CubeMX, review and adjust configuration options as required for your application, then just click the button GENERATE CODE . The generated files will be stored in the directory STM32CubeMX/MyBoard . Build the project using this command: cbuild CubeMX.csolution.yml --update-rte Note You may run the CubeMX generator any time to change the configuration setting of your device or board. Directory with generated files CubeMX generates the following content in the generator output directory of the csolution project . In our example the generator output directory is STM32CubeMX/MyBoard . Directory STM32CubeMX/MyBoard Content CubeMX.cgen.yml Generator import file that adds the CubeMX generated files to the csolution project . MX_Device/CubeMX/MX_Device.h Header file with configuration settings for CMSIS software components. STM32CubeMX/STM32CubeMX.ioc CubeMX native project file that includes settings. STM32CubeMX/Src CubeMX generated application code: main.c and STM32 setup code. STM32CubeMX/Inc Header files for CubeMX generated application code. STM32CubeMX/EWARM Project files for IAR; only startup code and linker scripts are used for csolution projects . STM32CubeMX/GCC Project files for GCC; only startup code and linker scripts are used for csolution projects . STM32CubeMX/MDK-ARM Project files for MDK version 5; only startup code and linker scripts are used for csolution projects . [!NOTE] CubeMX generates only the directory for the selected toolchain which is either STM32CubeMX/EWARM , STM32CubeMX/GCC , or STM32CubeMX/MDK-ARM . Content of Generator Import File: CubeMX.cgen.yml The file *.cgen.yml lists the files and settings that are generated by CubeMX and imported in the csolution project . The files under group: CubeMX may be modified by the user in sections marked with USER CODE BEGIN and USER CODE END to implement the application specific features. In the file *.cproject.yml additional user files can be added. generator-import: for-device: STM32U585AIIx for-board: B-U585I-IOT02A define: - USE_FULL_LL_DRIVER - USE_HAL_DRIVER - STM32U585xx add-path: - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc/Legacy - ./STM32CubeMX/Drivers/CMSIS/Device/ST/STM32U5xx/Include - ./STM32CubeMX/Inc - ./MX_Device/CubeMX groups: - group: CubeMX files: - file: ./STM32CubeMX/Src/main.c - file: ./STM32CubeMX/Src/stm32u5xx_it.c - file: ./STM32CubeMX/Src/stm32u5xx_hal_msp.c - file: ./STM32CubeMX/MDK-ARM/startup_stm32u585xx.s - file: ./STM32CubeMX/Src/system_stm32u5xx.c - group: STM32 HAL Driver files: - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_utils.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_exti.c : - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_hal_pcd_ex.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_usb.c","title":"Simple Project"},{"location":"CubeMX/#adding-an-rtos","text":"Many applications require an RTOS kernel. By default, CubeMX implements interrupts functions for all Cortex-M exception handlers. However, some exception handlers are typically required for the RTOS kernel execution. Adding an RTOS kernel requires these steps: Add the RTOS kernel to application (in this case RTX) File: CubeMX.cproject.yml project: packs: - pack: ARM::CMSIS-RTX # RTOS Software Pack groups: - group: MyApp files: - file: MyMain.c components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX - component: CMSIS:RTOS2:Keil RTX5&Source # RTOS component - component: CMSIS:OS Tick:SysTick # OS Tick implementation for RTOS Note The example above uses CMSIS-RTX as the RTOS kernel, other kernels require different components and packs, but the concept is similar. Configure interrupt handlers in CubeMX Run CubeMX with: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard Open the dialog Pinout & Configuration - System Core NVIC - Code generation and disable Generate IRQ handler for: System service call via SWI instruction Pendable request for system service System tick timer Then click the button GENERATE CODE to update the generated files in the directory STM32CubeMX/MyBoard","title":"Adding an RTOS"},{"location":"CubeMX/#linker-script","text":"Depending on the project type and toolchain, CubeMX provides a linker script. For compiler: AC6 : no linker script is generated for a simple memory. In this case, the default linker script from the CMSIS-Toolbox is used, but needs a modification: remove ARM_LIB_HEAP and ARM_LIB_STACK as they are defined in the STM32 startup file. a linker script is provided for more complex projects (typically when using the CubeMX Memory Manager). For compiler: GCC or compiler: IAR , a linker script is always provided. Note The linker script that is provided by CubeMX is defined in the *.cgen.yml and imported into the csolution project .","title":"Linker Script"},{"location":"CubeMX/#use-cubemx-with-board-layer","text":"A software layer is a set of pre-configured software components and source files for re-use in multiple projects. A board layer contains typically basic I/O drivers and related device and board configuration. For a board layer, CubeMX can be used to generate device configuration and peripheral drivers. As a board layer uses a separate directory that is independent of a specific csolution project the location of the STM32CubeMX generated files should be specified using the generators: node in the <board>.clayer.yml file. This locates the CubeMX generated files in the directory structure of the software layer . As a board layer is used by several projects, the name of the generator import file should be also explicitly specified as shown below: generators: options: - generator: CubeMX path: ./CubeMX # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`. This configuration results in the following directory structure: Directory and Files Description <board>.clayer.yml Defines the source files and software components of the board layer. CubeMX/ Directory with CubeMX ioc file and other generated files and folders. CubeMX/Board.cgen.yml Generator import file that lists CubeMX generated files and options. CubeMX/STM32CubeMX/ Directory with CubeMX generated files. CubeMX/STM32CubeMX/Drivers/ Directory with driver related source files. Several STM32 Board Support Packs with Generator Support contain board layers that use such a configuration. For examples, the Nucleo-F756ZG_BSP or B-U585I-IOT02A_BSP .","title":"Use CubeMX with Board Layer"},{"location":"CubeMX/#trustzone-or-multi-core-project","text":"Projects that use TrustZone or a multi-core device share the same STM32CubeMX configuration. There is therefore just one directory STM32CubeMX located at the same level as the *.csolution.yml project file.","title":"TrustZone or Multi-Core Project"},{"location":"CubeMX/#cubemx-runtime-context-mapping","text":"Some devices, for example the STM32H7S series, provide in CubeMX runtime contexts , for example: Boot , Appli , ExtMemLoader . To map the csolution project context to these CubeMX runtime contexts it is required for this type of devices to use map: key in the generator : option as shown below. The STM32H7S series uses the following CubeMX run-time names: Boot for the boot loader. Appli for the user application program. ExtMemLoader for the part that is in external memory. The generators: node is used to map a *.cproject.yml or *.clayer.yml file to a CubeMX run-time context as shown below. generators: options: - generator: CubeMX map: Appli # map project or layer to CubeMX runtime context","title":"CubeMX Runtime Context Mapping"},{"location":"CubeMX/#migration-to-cmsis-toolbox-cubemx-integration","text":"In previous CubeMX integrations a *.gpdsc file is used to import the generator output. The following table compares the CMSIS-Toolbox CubeMX integration (based on *.cgen.yml files) with the previous STM32CubeMX integration (based on *.gpdsc files). Comparison CMSIS-Toolbox *.cgen.yml Integration Previous *.gdpsc Integration IDE Support VS Code , Keil uVision 5.40 or higher Keil uVision, CMSIS-Pack for Eclipse CLI Tools CMSIS-Toolbox 2.4.0 or higher n/a STM32CubeMX project file STM32CubeMX.ioc STCubeGenerated.ioc STM32CubeMX source location ./STM32CubeMX/<target-type/STM32CubeMX/Src ./RTE/Device/<device name>/STCubeGenerated/Src or ./Board/<board name>/STM32CubeMX/Src STM32CubeMX include location ./STM32CubeMX/<target-type/STM32CubeMX/Inc ./RTE/Device/<device name>/STCubeGenerated/Inc or ./Board/<board name>/STM32CubeMX/Inc ST Firmware Provided by STM32Cube Firmware Packs Provided by STM32*_DFP software pack CMSIS-Driver Provided by CMSIS-Driver_STM32 software pack Provided by STM32*_DFP software pack To migrate existing projects that where using the previous STM32CubeMX integration (based on *.gpdsc files) use the following steps: Remove all component: Keil::Device:xxx from the *.cproject.yml file. Add the component: Device:CubeMX to the *.cproject.yml file. Use csolution run *.csolution.yml -g CubeMX to initialize the directory structure. Replace the file STM32CubeMX.ioc with the file STCubeGenerated.ioc from the previous project. Copy source and include files from previous location as they may contain user modifications. Use csolution run *.csolution.yml -g CubeMX to generated the output from the previous STM32CubeMX project. Update the configuration in STM32CubeMX: In the tab Project Manager - Project set Project Settings - Toolchain/IDE to match the compiler selection in the csolution project. In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration.","title":"Migration to CMSIS-Toolbox CubeMX Integration"},{"location":"CubeMX/#uvision-update-stm32-dfp-packs","text":"The Generator Integration of the CMSIS-Toolbox is also available with uVision version 5.40 or higher. New STM32*_DFP software packs that contain in the release information Updated for new CMSIS-Toolbox CubeMX integration require migration. The steps below describe the migration process of an previous CubeMX configuration. In \u00b5Vision open the dialog Manage - Run-Time Environment . Remove all components from Device Cclass as the STM32 device firmware is now managed by CubeMX. Close Manage - Run-Time Environment with OK . Open the dialog Manage - Run-Time Environment again. Select the component Device:CubeMX and start STM32CubeMX with the play button. Update the configuration in STM32CubeMX: In the tab Project Manager - Project set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration. Starting a new project works similar with these steps: In uVision use Project - New uVision Project and select the STM32 device that you want to use. Optional: Project - Manage - Project items tab Project Info / Layer allows to select an evaluation board under Board . Open the dialog Manage - Run-Time Environment . Select the component Device:CubeMX and start STM32CubeMX with the play button. Create a new device configuration in STM32CubeMX: Follow the instructions of STM32CubeMX and verify settings. In the tab Project Manager - Project set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration.","title":"uVision - Update STM32 DFP Packs"},{"location":"Experimental-Features/","text":"Experimental Features Experimental features are implemented to iterate on new functionality. Experimental features have limited test coverage and the functionality may change in future versions of the CMSIS-Toolbox without further notice. The CMSIS-Toolbox 2.7 implements the following experimental features: Experimental Features Resource Management resources: Example <solution-name>+<target-name>.regions.h file Question Adding Memory Run and Debug Management <solution-name>+<target-name>.cbuild-run.yml Usage Questions Resource Management In a multi-processor or multi-project application the target type describes the target hardware. A solution is a collection of related projects and the context-set defines the projects that are deployed to the target hardware. A project uses a subset of resources (called regions at linker level). The linker script management is extended for multi-processor or multi-project applications with the following features: When resources: node is specified in one of the *.cproject.yml or *.clayer.yml files of a csolution project : The file .\\cmsis\\<solution-name>+<target-name>.regions.h is generated. This file contains the global region settings of a solution for one target-type. The file .\\cmsis\\<solution-name>+<target-name>.regions.h replaces the regions_<device_or_board>.h that is located in the directory ./RTE/Device/<device> . The regions_<device_or_board>.h is longer generated. A define: <project-name>_cproject is always added to the linker script pre-processor (also when no resources: node is used). The following picture explains the extended linker script management for multi-project applications. resources: The resources: node specifies the resources required by a project. It is used at the level of project: , setup: , or layer: . The resources: node is additive; when multiple resources: nodes specify the same region the size is added. Note In a next iteration, the linker script may be generated by the CMSIS-Toolbox and features from uVision to allocate source modules to specific regions may get added. Therefore the resources: node is forward looking in the way heap and stack is specified. resources: regions: - region: __ROM0 # region name pre-defined in script template: __ROM0..3 size: 0x10000 # specifies region size # name: ITCM_Flash - maps to physical memory name(s), if missing use PDSC default memory # address: - absolution address of region; not in scope for 2.7 # startup: - locate startup/vectors to this region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 - region: __RAM0 # region name pre-defined in script template: __RAM0..3 size: 0x8000 # specifies region size heap: 0x2000 # heap size (only permitted region __RAM0) stack: 0x4000 # stack size (only permitted in region __RAM0) # name: - maps to physical memory name(s), if missing use PDSC default memory # - SRAM1 # - SRAM2 # address: - absolution address of region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 # sections: - potentially locate sections (requires linker script generation); not in scope for 2.7 # - .text.function Example <solution-name>+<target-name>.regions.h file #ifndef USBD_STM32F746G_DISCO_REGIONS_H #define USBD_STM32F746G_DISCO_REGIONS_H // *** DO NOT MODIFY THIS FILE! *** // // Generated by csolution 2.7.0 based on packs and csolution project resources // Device Family Pack (DFP): Keil::STM32F7xx_DFP@3.0.0 // Board Support Pack (BSP): Keil::STM32F746G-DISCO_BSP@1.0.0 // Available Physical Memory Resources // rx ROM: Name: ITCM_Flash (from DFP) BASE: 0x00200000 SIZE: 0x00100000 // rx ROM: Name: Flash (from DFP) BASE: 0x08000000 SIZE: 0x00100000 (default) // rwx RAM: Name: DTCM (from DFP) BASE: 0x20000000 SIZE: 0x00010000 // rwx RAM: Name: SRAM1 (from DFP) BASE: 0x20010000 SIZE: 0x00020000 (default) // rwx RAM: Name: SRAM2 (from DFP) BASE: 0x20030000 SIZE: 0x00020000 (default) // rwx RAM: Name: BKP_SRAM (from DFP) BASE: 0x40024000 SIZE: 0x00001000 // rwx RAM: Name: ITCM (from DFP) BASE: 0x00000000 SIZE: 0x00004000 //-------------------------------------- #ifdef A_cproject // Resources allocated in A.cproject.yml #define __ROM0_BASE 0x08000000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00010000 #define __RAM0_BASE 0x20010000 /* Memory Name: SRAM1 */ #define __RAM0_SIZE 0x00008000 #define __STACK_SIZE 0x00004000 #define __HEAP_SIZE 0x00002000 #endif /* A_cproject */ //-------------------------------------- #ifdef B_cproject // Resources allocated in B.cproject.yml #define __ROM0_BASE 0x08010000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00030000 #define __RAM0_BASE 0x20018000 /* Memory Name: SRAM1+SRAM2 */ #define __RAM0_SIZE 0x00020000 #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000000 #endif /* B_cproject */ #endif /* USBD_STM32F746G_DISCO_REGIONS_H */ Question Should the <solution-name>+<target-name>.regions.h file contain also #define's for the overall avaiable memory, i.e. for a boot loader? Adding Memory Hardware targets may have additional off-chip memory. A memory: node that can be added as additional information to a target type as shown below: solution: : target-types: - type: MyHardware device: STMicroelectronics::STM32F746NGHx memory: # Additional memory available in MyHardware - name: Ext-Flash # Identifier - access: rx # access permission - start: 0x40000000 - size: 0x200000 - algorithm: Flash/Ext-Flash.flm # Programming algorithm Run and Debug Management The CMSIS-Pack PDSC files contain information about device/board parameters and software components: Flash algorithms of device memory (in DFP) and board memory (in BSP). On-board debug adapter (a default programming/debug channel) including features. Available memory of device and board. Device parameters such as processor core(s) and clock speed. Debug Access Sequences and System Description Files that support more complex Cortex-A/R/M configurations. CMSIS-SVD System View Description (SVD) files for viewing device peripherals. CMSIS-View Software Component Viewer Description (SCVD) files for analysis of software components (RTOS, Middleware). The CMSIS-Toolbox build system manages device/board/software components, controls the build output (typically ELF/DWARF files), and has provisions for HEX, BIN and post-processing. It allows to manage different target-types and the context set manages the images that belong to a target. In addition the user may need the following information which should be added to the YML-Input files for the CMSIS-Toolbox. Flash algorithms for external memory in custom hardware (see Adding Memory ). ToDo: Additional images that should be loaded. ToDo: Device configuration information. ToDo: Access information for protected debug ports (i.e. encryption keys). <solution-name>+<target-name>.cbuild-run.yml The <solution-name>+<target-name>.cbuild-run.yml is generated in the folder .cmsis and provides the relevant information for executing Run and Debug commands. Overall it: simplifies the usage of flash programmers and debuggers. provides information for command line and IDE workflows in a consistent way. ensures that information is portable, i.e from a cloud-hosted CI system to a desktop test system. The <solution-name>+<target-name>.cbuild-run.yml file provides access to PDSC information and the build output of one target. It also exports the Debug Access Sequences . The <solution-name>+<target-name>.cbuild-run.yml file represents a context-set of a solution. Content of <solution-name>+<target-name>.cbuild-run.yml : run: # Start of file, contains run and debug information for a target generated-by: csolution version 2.7.0 solution: ../USB_Device.csolution.yml target-type: +STM32U585AIIx compiler: AC6 board: STMicroelectronics::B-U585I-IOT02A:Rev.C board-pack: Keil::B-U585I-IOT02A_BSP@2.0.0 device: STMicroelectronics::STM32U585AIIx device-pack: Keil::STM32U5xx_DFP@3.0.0 programming: # Flash programming algorithms - algorithm: ${CMSIS_PACK_ROOT}/DFP-path/<programming-algorithm> - algorithm: ${CMSIS_PACK_ROOT}/BSP-path/<programming-algorithm> config: <potential config options> # is this required - algorithm: custom-hw-path/<programming-algorithm> output: # application image files - type: elf file: HID.axf load: <scope> # all (default), symbols only, binary only system-description: - file: ${CMSIS_PACK_ROOT}/DFP-path/<svd> type: svd - file: ${CMSIS_PACK_ROOT}/pack-path/<scvd> type: scvd from-pack: <pack> # information from DFP, BSP specific to the target # https://open-cmsis-pack.github.io/Open-CMSIS-Pack-Spec/main/html/packFormat.html board: # Board element debugProbe: ... debugInterface: ... debug-port: # Information from DFP access-port-v1: ... access-port-v2: ... jtag: cjtag: swd: default-settings: # Default debug configuration default: # debug protocol (SWD or JTAG) to use for target connections. clock: # clock setting in Hz for a target connection. swj: # allows Serial Wire Debug (SWD) and JTAG protocols dormant: # device access via CoreSight DP requires the dormant state sdf: ${CMSIS_PACK_ROOT}/DFP-path/<sdf> # path of the system description file (SDF). sequences: ... trace: ... Usage The *.cbuild-run.yml file can be directly passed to programmers and debug tools, for example using a command line option. It contains all information that needs to be passed. >programmer -csolution MySolution+MyHardware.cbuild-run.yml Questions What should be done now to simplify above information while making it more future proof? For CMSIS-Toolbox 3.0: Should the location of cbuild information files change to folder .\\.cmsis ? Should the structure of build information file change and include cbuild-run.yml ? The cbuild information file will then represent a context-set, and not just one context.","title":"Experimental Features"},{"location":"Experimental-Features/#experimental-features","text":"Experimental features are implemented to iterate on new functionality. Experimental features have limited test coverage and the functionality may change in future versions of the CMSIS-Toolbox without further notice. The CMSIS-Toolbox 2.7 implements the following experimental features: Experimental Features Resource Management resources: Example <solution-name>+<target-name>.regions.h file Question Adding Memory Run and Debug Management <solution-name>+<target-name>.cbuild-run.yml Usage Questions","title":"Experimental Features"},{"location":"Experimental-Features/#resource-management","text":"In a multi-processor or multi-project application the target type describes the target hardware. A solution is a collection of related projects and the context-set defines the projects that are deployed to the target hardware. A project uses a subset of resources (called regions at linker level). The linker script management is extended for multi-processor or multi-project applications with the following features: When resources: node is specified in one of the *.cproject.yml or *.clayer.yml files of a csolution project : The file .\\cmsis\\<solution-name>+<target-name>.regions.h is generated. This file contains the global region settings of a solution for one target-type. The file .\\cmsis\\<solution-name>+<target-name>.regions.h replaces the regions_<device_or_board>.h that is located in the directory ./RTE/Device/<device> . The regions_<device_or_board>.h is longer generated. A define: <project-name>_cproject is always added to the linker script pre-processor (also when no resources: node is used). The following picture explains the extended linker script management for multi-project applications.","title":"Resource Management"},{"location":"Experimental-Features/#resources","text":"The resources: node specifies the resources required by a project. It is used at the level of project: , setup: , or layer: . The resources: node is additive; when multiple resources: nodes specify the same region the size is added. Note In a next iteration, the linker script may be generated by the CMSIS-Toolbox and features from uVision to allocate source modules to specific regions may get added. Therefore the resources: node is forward looking in the way heap and stack is specified. resources: regions: - region: __ROM0 # region name pre-defined in script template: __ROM0..3 size: 0x10000 # specifies region size # name: ITCM_Flash - maps to physical memory name(s), if missing use PDSC default memory # address: - absolution address of region; not in scope for 2.7 # startup: - locate startup/vectors to this region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 - region: __RAM0 # region name pre-defined in script template: __RAM0..3 size: 0x8000 # specifies region size heap: 0x2000 # heap size (only permitted region __RAM0) stack: 0x4000 # stack size (only permitted in region __RAM0) # name: - maps to physical memory name(s), if missing use PDSC default memory # - SRAM1 # - SRAM2 # address: - absolution address of region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 # sections: - potentially locate sections (requires linker script generation); not in scope for 2.7 # - .text.function","title":"resources:"},{"location":"Experimental-Features/#example-solution-nametarget-nameregionsh-file","text":"#ifndef USBD_STM32F746G_DISCO_REGIONS_H #define USBD_STM32F746G_DISCO_REGIONS_H // *** DO NOT MODIFY THIS FILE! *** // // Generated by csolution 2.7.0 based on packs and csolution project resources // Device Family Pack (DFP): Keil::STM32F7xx_DFP@3.0.0 // Board Support Pack (BSP): Keil::STM32F746G-DISCO_BSP@1.0.0 // Available Physical Memory Resources // rx ROM: Name: ITCM_Flash (from DFP) BASE: 0x00200000 SIZE: 0x00100000 // rx ROM: Name: Flash (from DFP) BASE: 0x08000000 SIZE: 0x00100000 (default) // rwx RAM: Name: DTCM (from DFP) BASE: 0x20000000 SIZE: 0x00010000 // rwx RAM: Name: SRAM1 (from DFP) BASE: 0x20010000 SIZE: 0x00020000 (default) // rwx RAM: Name: SRAM2 (from DFP) BASE: 0x20030000 SIZE: 0x00020000 (default) // rwx RAM: Name: BKP_SRAM (from DFP) BASE: 0x40024000 SIZE: 0x00001000 // rwx RAM: Name: ITCM (from DFP) BASE: 0x00000000 SIZE: 0x00004000 //-------------------------------------- #ifdef A_cproject // Resources allocated in A.cproject.yml #define __ROM0_BASE 0x08000000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00010000 #define __RAM0_BASE 0x20010000 /* Memory Name: SRAM1 */ #define __RAM0_SIZE 0x00008000 #define __STACK_SIZE 0x00004000 #define __HEAP_SIZE 0x00002000 #endif /* A_cproject */ //-------------------------------------- #ifdef B_cproject // Resources allocated in B.cproject.yml #define __ROM0_BASE 0x08010000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00030000 #define __RAM0_BASE 0x20018000 /* Memory Name: SRAM1+SRAM2 */ #define __RAM0_SIZE 0x00020000 #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000000 #endif /* B_cproject */ #endif /* USBD_STM32F746G_DISCO_REGIONS_H */","title":"Example &lt;solution-name&gt;+&lt;target-name&gt;.regions.h file"},{"location":"Experimental-Features/#question","text":"Should the <solution-name>+<target-name>.regions.h file contain also #define's for the overall avaiable memory, i.e. for a boot loader?","title":"Question"},{"location":"Experimental-Features/#adding-memory","text":"Hardware targets may have additional off-chip memory. A memory: node that can be added as additional information to a target type as shown below: solution: : target-types: - type: MyHardware device: STMicroelectronics::STM32F746NGHx memory: # Additional memory available in MyHardware - name: Ext-Flash # Identifier - access: rx # access permission - start: 0x40000000 - size: 0x200000 - algorithm: Flash/Ext-Flash.flm # Programming algorithm","title":"Adding Memory"},{"location":"Experimental-Features/#run-and-debug-management","text":"The CMSIS-Pack PDSC files contain information about device/board parameters and software components: Flash algorithms of device memory (in DFP) and board memory (in BSP). On-board debug adapter (a default programming/debug channel) including features. Available memory of device and board. Device parameters such as processor core(s) and clock speed. Debug Access Sequences and System Description Files that support more complex Cortex-A/R/M configurations. CMSIS-SVD System View Description (SVD) files for viewing device peripherals. CMSIS-View Software Component Viewer Description (SCVD) files for analysis of software components (RTOS, Middleware). The CMSIS-Toolbox build system manages device/board/software components, controls the build output (typically ELF/DWARF files), and has provisions for HEX, BIN and post-processing. It allows to manage different target-types and the context set manages the images that belong to a target. In addition the user may need the following information which should be added to the YML-Input files for the CMSIS-Toolbox. Flash algorithms for external memory in custom hardware (see Adding Memory ). ToDo: Additional images that should be loaded. ToDo: Device configuration information. ToDo: Access information for protected debug ports (i.e. encryption keys).","title":"Run and Debug Management"},{"location":"Experimental-Features/#solution-nametarget-namecbuild-runyml","text":"The <solution-name>+<target-name>.cbuild-run.yml is generated in the folder .cmsis and provides the relevant information for executing Run and Debug commands. Overall it: simplifies the usage of flash programmers and debuggers. provides information for command line and IDE workflows in a consistent way. ensures that information is portable, i.e from a cloud-hosted CI system to a desktop test system. The <solution-name>+<target-name>.cbuild-run.yml file provides access to PDSC information and the build output of one target. It also exports the Debug Access Sequences . The <solution-name>+<target-name>.cbuild-run.yml file represents a context-set of a solution. Content of <solution-name>+<target-name>.cbuild-run.yml : run: # Start of file, contains run and debug information for a target generated-by: csolution version 2.7.0 solution: ../USB_Device.csolution.yml target-type: +STM32U585AIIx compiler: AC6 board: STMicroelectronics::B-U585I-IOT02A:Rev.C board-pack: Keil::B-U585I-IOT02A_BSP@2.0.0 device: STMicroelectronics::STM32U585AIIx device-pack: Keil::STM32U5xx_DFP@3.0.0 programming: # Flash programming algorithms - algorithm: ${CMSIS_PACK_ROOT}/DFP-path/<programming-algorithm> - algorithm: ${CMSIS_PACK_ROOT}/BSP-path/<programming-algorithm> config: <potential config options> # is this required - algorithm: custom-hw-path/<programming-algorithm> output: # application image files - type: elf file: HID.axf load: <scope> # all (default), symbols only, binary only system-description: - file: ${CMSIS_PACK_ROOT}/DFP-path/<svd> type: svd - file: ${CMSIS_PACK_ROOT}/pack-path/<scvd> type: scvd from-pack: <pack> # information from DFP, BSP specific to the target # https://open-cmsis-pack.github.io/Open-CMSIS-Pack-Spec/main/html/packFormat.html board: # Board element debugProbe: ... debugInterface: ... debug-port: # Information from DFP access-port-v1: ... access-port-v2: ... jtag: cjtag: swd: default-settings: # Default debug configuration default: # debug protocol (SWD or JTAG) to use for target connections. clock: # clock setting in Hz for a target connection. swj: # allows Serial Wire Debug (SWD) and JTAG protocols dormant: # device access via CoreSight DP requires the dormant state sdf: ${CMSIS_PACK_ROOT}/DFP-path/<sdf> # path of the system description file (SDF). sequences: ... trace: ...","title":"&lt;solution-name&gt;+&lt;target-name&gt;.cbuild-run.yml"},{"location":"Experimental-Features/#usage","text":"The *.cbuild-run.yml file can be directly passed to programmers and debug tools, for example using a command line option. It contains all information that needs to be passed. >programmer -csolution MySolution+MyHardware.cbuild-run.yml","title":"Usage"},{"location":"Experimental-Features/#questions","text":"What should be done now to simplify above information while making it more future proof? For CMSIS-Toolbox 3.0: Should the location of cbuild information files change to folder .\\.cmsis ? Should the structure of build information file change and include cbuild-run.yml ? The cbuild information file will then represent a context-set, and not just one context.","title":"Questions"},{"location":"MCUXpressoConfig/","text":"Configure NXP Devices with MCUXpresso Config Tools This chapter explains how to use the MCUXpresso Config Tool with the CMSIS-Toolbox to manage device and board configuration. Note MCUXpresso Config Tools integration with CMSIS-Toolbox is available with CMSIS packs based on MCUXpresso SDK 2.16.0 (or higher). Overview The MCUXpresso Config Tool is a graphical tool for configuration of a NXP device or board. MCUXpresso generates C code for project and peripheral initialization based on user settings. The CMSIS-Toolbox interacts with MCUXpresso Config Tools using the generic interface for generators and automatically adds generated source code to the project. The component: Device:Config Tools connects a csolution project to MCUXpresso. This component imports the MCUXpresso generated files for a selected device: or board: using the generator import file ( *.cgen.yml ). This *.cgen.yml file is similar to a software layer but managed by MCUXpresso and should be not modified directly. An example project created with MCUXpresso can be found in csolution-examples/DualCore . Note When a board is specified in the csolution project , MCUXpresso pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the MCUXpresso dialogs. When only a device is specified, the user need to configure the peripherals manually using MCUXpresso dialogs. Simple Project Below is a simple project that just adds the MCUXpresso generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: Simple.csolution.yml solution: created-for: CMSIS-Toolbox@2.6.0 # List of tested compilers that can be selected select-compiler: - compiler: AC6 - compiler: GCC - compiler: IAR # List the packs that define the device and/or board. packs: - pack: NXP::FRDM-MCXN947_BSP - pack: NXP::MCXN947_DFP - pack: ARM::CMSIS # List different hardware targets that are used to deploy the solution. target-types: - type: MCXN947VDF board: NXP::FRDM-MCXN947 device: NXP::MCXN947VDF # List of different build configurations. build-types: - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced # List related projects. projects: - project: Simple.cproject.yml File: Simple.cproject.yml project: device: :cm33_core0 generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig name: ConfigTools # List components to use for your application. # A software component is a re-usable unit that may be configurable. components: - component: Device:Config Tools:Init - component: Device:Startup - component: Device:CMSIS:MCXN947_header - component: Device:CMSIS:MCXN947_system - component: Device:SDK Drivers:clock - component: Device:SDK Drivers:common - component: Device:SDK Drivers:mcx_spc - component: Device:SDK Drivers:reset - component: CMSIS:CORE groups: - group: Main files: - file: ./main.c Such a project cannot be built directly as initially the *.cgen.yml file is missing. It requires to run the MCUXpresso generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution Simple.csolution.yml list generators --verbose MCUXpressoConfig (Global Registered Generator MCUXpresso Config tools) base-dir: MCUXpressoConfig cgen-file: MCUXpressoConfig/ConfigTools.cgen.yml context: Simple.Debug+MCXN947VDF context: Simple.Release+MCXN947VDF Using the above information to run the generator using this command: csolution Simple.csolution.yml run --generator MCUXpressoConfig --context Simple.Debug+MCXN947VDF It starts MCUXpresso and passes the information about the selected board, device, and selected toolchain. For a project that selects a board, MCUXpresso imports the default configuration for the evaluation kit. In MCUXpresso, review and adjust configuration options as required for your application, then just click the button Update Code . The generated files will be stored in the directory ./MCUXpressoConfig . Build the project using this command: cbuild Simple.csolution.yml --update-rte Note You may run the MCUXpresso Config Tools any time to change the configuration setting of your device or board. Directory with generated files MCUXpresso generates the following content in the generator output directory of the csolution project . In our example the generator output directory is ./MCUXpressoConfig . Directory ./MCUXpressoConfig Content ConfigTools.cgen.yml Import file which adds the generated files to the csolution project . FRDM-MCXN947.mex MCUXpresso Config Tools configuration file. board/clock_config.c Clock setup using clock driver functions. board/clock_config.h Clock configuration header file. board/peripherals.c Board peripherals setup via init functions. board/peripherals.h Board peripherals setup header file. board/pin_mux.c Board pin setup via init functions. board/pin_mux.h Board pin setup header file. Content of Generator Import File: ConfigTools.cgen.yml The file ConfigTools.cgen.yml lists the files and settings that are generated by MCUXpresso and imported in the csolution project . You may add further user files here. generator-import: generated-by: 'MCUXpresso config tools Generated: 09/12/2024 17:02:22' for-device: MCXN947 for-board: FRDM-MCXN947 groups: - group: ConfigTools board files: - file: board/clock_config.c - file: board/clock_config.h - file: board/peripherals.c - file: board/peripherals.h - file: board/pin_mux.c - file: board/pin_mux.h Linker Script Depending on the toolchain, NXP provides a linker script. For Arm Compiler 6, a scatter file with the ending *.scf is provided, for GCC, a linker script file with the ending *.ld is provided and for IAR, the provided linker script files end with *.icf extension. Create a Board Layer A software layer is a set of pre-configured software components and source files for re-use in multiple projects. A board layer contains typically basic I/O drivers and related device and board configuration. MCUXpresso does generate a significant part of a board layer. The board layer is stored in an separate directory that is independent of a specific csolution project . To create a board layer, copy the related source files, the MCUXpresso generated files, and the configuration files of the RTE directory that relate to software components in the board layer. Example directory content of a NXP board layer Directory and Files Description Board.clayer.yml Defines the source files and software components of the board layer. MCUXpressoConfig/ Directory with MCUXpresso generated files. MCUXpressoConfig/Board.cgen.yml Generator import file that lists MCUXpresso generated files and options. The Board.clayer.yml file defines with the generators: node, options to locate the MCUXpresso generated files in the directory structure of the software layer . As a board layer is used by many projects, the name of the generator import file should be explicitly specified as shown below: generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`.","title":"Configure NXP Devices with MCUXpresso Config Tools"},{"location":"MCUXpressoConfig/#configure-nxp-devices-with-mcuxpresso-config-tools","text":"This chapter explains how to use the MCUXpresso Config Tool with the CMSIS-Toolbox to manage device and board configuration. Note MCUXpresso Config Tools integration with CMSIS-Toolbox is available with CMSIS packs based on MCUXpresso SDK 2.16.0 (or higher).","title":"Configure NXP Devices with MCUXpresso Config Tools"},{"location":"MCUXpressoConfig/#overview","text":"The MCUXpresso Config Tool is a graphical tool for configuration of a NXP device or board. MCUXpresso generates C code for project and peripheral initialization based on user settings. The CMSIS-Toolbox interacts with MCUXpresso Config Tools using the generic interface for generators and automatically adds generated source code to the project. The component: Device:Config Tools connects a csolution project to MCUXpresso. This component imports the MCUXpresso generated files for a selected device: or board: using the generator import file ( *.cgen.yml ). This *.cgen.yml file is similar to a software layer but managed by MCUXpresso and should be not modified directly. An example project created with MCUXpresso can be found in csolution-examples/DualCore . Note When a board is specified in the csolution project , MCUXpresso pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the MCUXpresso dialogs. When only a device is specified, the user need to configure the peripherals manually using MCUXpresso dialogs.","title":"Overview"},{"location":"MCUXpressoConfig/#simple-project","text":"Below is a simple project that just adds the MCUXpresso generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: Simple.csolution.yml solution: created-for: CMSIS-Toolbox@2.6.0 # List of tested compilers that can be selected select-compiler: - compiler: AC6 - compiler: GCC - compiler: IAR # List the packs that define the device and/or board. packs: - pack: NXP::FRDM-MCXN947_BSP - pack: NXP::MCXN947_DFP - pack: ARM::CMSIS # List different hardware targets that are used to deploy the solution. target-types: - type: MCXN947VDF board: NXP::FRDM-MCXN947 device: NXP::MCXN947VDF # List of different build configurations. build-types: - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced # List related projects. projects: - project: Simple.cproject.yml File: Simple.cproject.yml project: device: :cm33_core0 generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig name: ConfigTools # List components to use for your application. # A software component is a re-usable unit that may be configurable. components: - component: Device:Config Tools:Init - component: Device:Startup - component: Device:CMSIS:MCXN947_header - component: Device:CMSIS:MCXN947_system - component: Device:SDK Drivers:clock - component: Device:SDK Drivers:common - component: Device:SDK Drivers:mcx_spc - component: Device:SDK Drivers:reset - component: CMSIS:CORE groups: - group: Main files: - file: ./main.c Such a project cannot be built directly as initially the *.cgen.yml file is missing. It requires to run the MCUXpresso generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution Simple.csolution.yml list generators --verbose MCUXpressoConfig (Global Registered Generator MCUXpresso Config tools) base-dir: MCUXpressoConfig cgen-file: MCUXpressoConfig/ConfigTools.cgen.yml context: Simple.Debug+MCXN947VDF context: Simple.Release+MCXN947VDF Using the above information to run the generator using this command: csolution Simple.csolution.yml run --generator MCUXpressoConfig --context Simple.Debug+MCXN947VDF It starts MCUXpresso and passes the information about the selected board, device, and selected toolchain. For a project that selects a board, MCUXpresso imports the default configuration for the evaluation kit. In MCUXpresso, review and adjust configuration options as required for your application, then just click the button Update Code . The generated files will be stored in the directory ./MCUXpressoConfig . Build the project using this command: cbuild Simple.csolution.yml --update-rte Note You may run the MCUXpresso Config Tools any time to change the configuration setting of your device or board. Directory with generated files MCUXpresso generates the following content in the generator output directory of the csolution project . In our example the generator output directory is ./MCUXpressoConfig . Directory ./MCUXpressoConfig Content ConfigTools.cgen.yml Import file which adds the generated files to the csolution project . FRDM-MCXN947.mex MCUXpresso Config Tools configuration file. board/clock_config.c Clock setup using clock driver functions. board/clock_config.h Clock configuration header file. board/peripherals.c Board peripherals setup via init functions. board/peripherals.h Board peripherals setup header file. board/pin_mux.c Board pin setup via init functions. board/pin_mux.h Board pin setup header file. Content of Generator Import File: ConfigTools.cgen.yml The file ConfigTools.cgen.yml lists the files and settings that are generated by MCUXpresso and imported in the csolution project . You may add further user files here. generator-import: generated-by: 'MCUXpresso config tools Generated: 09/12/2024 17:02:22' for-device: MCXN947 for-board: FRDM-MCXN947 groups: - group: ConfigTools board files: - file: board/clock_config.c - file: board/clock_config.h - file: board/peripherals.c - file: board/peripherals.h - file: board/pin_mux.c - file: board/pin_mux.h","title":"Simple Project"},{"location":"MCUXpressoConfig/#linker-script","text":"Depending on the toolchain, NXP provides a linker script. For Arm Compiler 6, a scatter file with the ending *.scf is provided, for GCC, a linker script file with the ending *.ld is provided and for IAR, the provided linker script files end with *.icf extension.","title":"Linker Script"},{"location":"MCUXpressoConfig/#create-a-board-layer","text":"A software layer is a set of pre-configured software components and source files for re-use in multiple projects. A board layer contains typically basic I/O drivers and related device and board configuration. MCUXpresso does generate a significant part of a board layer. The board layer is stored in an separate directory that is independent of a specific csolution project . To create a board layer, copy the related source files, the MCUXpresso generated files, and the configuration files of the RTE directory that relate to software components in the board layer. Example directory content of a NXP board layer Directory and Files Description Board.clayer.yml Defines the source files and software components of the board layer. MCUXpressoConfig/ Directory with MCUXpresso generated files. MCUXpressoConfig/Board.cgen.yml Generator import file that lists MCUXpresso generated files and options. The Board.clayer.yml file defines with the generators: node, options to locate the MCUXpresso generated files in the directory structure of the software layer . As a board layer is used by many projects, the name of the generator import file should be explicitly specified as shown below: generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`.","title":"Create a Board Layer"},{"location":"Proposal%20-%20Resource%20Management/","text":"Proposal - Resource Management The CMSIS-Toolbox has a simple linker management that assigns all available memory resources to a project. While this is useful for simple projects, it does not provide enough flexibility for multi-processor or multi-project applications. This is a proposal on how these features could be added. Linker Script Management The current linker script processing is suitable for single core projects and uses: At project level the linker: node specifies the files above. Multi-processor or multi-project applications In a multi-processor or multi-project application the: target type describes the target hardware. It contains memory resources from the device: and optionally board: . For many applications it is beneficial to list all resources in a single header file (that is specific to a target type .) A project uses a subset of resources (called regions at linker level). Depending on build-types the resources may need adjustments. A potential solution could be: Target specific regions+target.h file that contains all available memory regions and allows to partition these regions for each project. This file could be auto-generated based on the information available in DFP and BSP. The define symbols for ROM0..3 , RAM0..3 would be extended with a project (see example below). Project specific linker scripts that include the regions+target.h file. The project specific linker scripts use the extended define symbols described above. Example: The following is the *.csolution.yml file. It contains 4 projects: Core2 , TFM , MQTT_AWS , and Bootloader . target-types: type: MyTarget projects: - project: ./core2/Core2.cproject.yml # Project that runs on a second core - project: ./security/TFM.cproject.yml # Secure project - project: ./application/MQTT_AWS.cproject.yml # Non-secure project - project: ./bootloader/Bootloader.cproject.yml # Secure project (transfers control to TFM) regions-MyTarget.h // <h>ROM Configuration // ======================= // <h> __ROM0=Flash // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. // <i> Default: 0x08000000 #define __ROM0_BASE 0x08000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. // <i> Default: 0x00200000 #define __ROM0_SIZE 0x00200000 // This are user configurable sizes #define __ROM0_SIZE_Core2 0x10000 #define __ROM0_SIZE_TFM 0x0 #define __ROM0_SIZE_MQTT_AWS 0x20000 #define __ROM0_SIZE_BootLoader 0x40000 // This is the allocation order #define __ROM0_BASE_Core2 __ROM0_BASE #define __ROM0_BASE_TFM (__ROM0_BASE_Core2+__ROM0_SIZE_Core2) #define __ROM0_BASE_MQTT_AWS (__ROM0_BASE_TFM+__ROM0_SIZE_TFM) #define __ROM0_BASE_BootLoader (__ROM0_MQTT_AWS+__ROM0_MQTT_AWS) // similar information is generated for ROM1..ROM3 + RAM0..RAM4 // in case that memory is only available for a core, only a fraction of the project is created The linker script is extended for each project using the project name. The copy process is similar to an %instance%, but expands %project% with the project name. Generic linker script ac6_linker_script.sct.src LR_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { ER_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { *.o (RESET, +First) *(InRoot$$Sections) *(+RO +XO) } #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) ER_CMSE_VENEER AlignExpr(+0, 32) (__ROM0_SIZE_TFM - AlignExpr(ImageLength(ER_ROM0), 32)) { *(Veneer$$CMSE) } #endif RW_NOINIT __RAM0_BASE_TFM UNINIT (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE) { *.o(.bss.noinit) *.o(.bss.noinit.*) } RW_RAM0 AlignExpr(+0, 8) (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE - AlignExpr(ImageLength(RW_NOINIT), 8)) { *(+RW +ZI) } : ac6_linker_script.sct.src expanded for TFM project LR_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { ER_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { *.o (RESET, +First) *(InRoot$$Sections) *(+RO +XO) } #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) ER_CMSE_VENEER AlignExpr(+0, 32) (__ROM0_SIZE_TFM - AlignExpr(ImageLength(ER_ROM0), 32)) { *(Veneer$$CMSE) } #endif RW_NOINIT __RAM0_BASE_TFM UNINIT (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE) { *.o(.bss.noinit) *.o(.bss.noinit.*) } RW_RAM0 AlignExpr(+0, 8) (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE - AlignExpr(ImageLength(RW_NOINIT), 8)) { *(+RW +ZI) } :","title":"Proposal - Resource Management"},{"location":"Proposal%20-%20Resource%20Management/#proposal-resource-management","text":"The CMSIS-Toolbox has a simple linker management that assigns all available memory resources to a project. While this is useful for simple projects, it does not provide enough flexibility for multi-processor or multi-project applications. This is a proposal on how these features could be added.","title":"Proposal - Resource Management"},{"location":"Proposal%20-%20Resource%20Management/#linker-script-management","text":"The current linker script processing is suitable for single core projects and uses: At project level the linker: node specifies the files above.","title":"Linker Script Management"},{"location":"Proposal%20-%20Resource%20Management/#multi-processor-or-multi-project-applications","text":"In a multi-processor or multi-project application the: target type describes the target hardware. It contains memory resources from the device: and optionally board: . For many applications it is beneficial to list all resources in a single header file (that is specific to a target type .) A project uses a subset of resources (called regions at linker level). Depending on build-types the resources may need adjustments. A potential solution could be: Target specific regions+target.h file that contains all available memory regions and allows to partition these regions for each project. This file could be auto-generated based on the information available in DFP and BSP. The define symbols for ROM0..3 , RAM0..3 would be extended with a project (see example below). Project specific linker scripts that include the regions+target.h file. The project specific linker scripts use the extended define symbols described above. Example: The following is the *.csolution.yml file. It contains 4 projects: Core2 , TFM , MQTT_AWS , and Bootloader . target-types: type: MyTarget projects: - project: ./core2/Core2.cproject.yml # Project that runs on a second core - project: ./security/TFM.cproject.yml # Secure project - project: ./application/MQTT_AWS.cproject.yml # Non-secure project - project: ./bootloader/Bootloader.cproject.yml # Secure project (transfers control to TFM) regions-MyTarget.h // <h>ROM Configuration // ======================= // <h> __ROM0=Flash // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. // <i> Default: 0x08000000 #define __ROM0_BASE 0x08000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. // <i> Default: 0x00200000 #define __ROM0_SIZE 0x00200000 // This are user configurable sizes #define __ROM0_SIZE_Core2 0x10000 #define __ROM0_SIZE_TFM 0x0 #define __ROM0_SIZE_MQTT_AWS 0x20000 #define __ROM0_SIZE_BootLoader 0x40000 // This is the allocation order #define __ROM0_BASE_Core2 __ROM0_BASE #define __ROM0_BASE_TFM (__ROM0_BASE_Core2+__ROM0_SIZE_Core2) #define __ROM0_BASE_MQTT_AWS (__ROM0_BASE_TFM+__ROM0_SIZE_TFM) #define __ROM0_BASE_BootLoader (__ROM0_MQTT_AWS+__ROM0_MQTT_AWS) // similar information is generated for ROM1..ROM3 + RAM0..RAM4 // in case that memory is only available for a core, only a fraction of the project is created The linker script is extended for each project using the project name. The copy process is similar to an %instance%, but expands %project% with the project name. Generic linker script ac6_linker_script.sct.src LR_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { ER_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { *.o (RESET, +First) *(InRoot$$Sections) *(+RO +XO) } #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) ER_CMSE_VENEER AlignExpr(+0, 32) (__ROM0_SIZE_TFM - AlignExpr(ImageLength(ER_ROM0), 32)) { *(Veneer$$CMSE) } #endif RW_NOINIT __RAM0_BASE_TFM UNINIT (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE) { *.o(.bss.noinit) *.o(.bss.noinit.*) } RW_RAM0 AlignExpr(+0, 8) (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE - AlignExpr(ImageLength(RW_NOINIT), 8)) { *(+RW +ZI) } : ac6_linker_script.sct.src expanded for TFM project LR_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { ER_ROM0 __ROM0_BASE_TFM __ROM0_SIZE_TFM { *.o (RESET, +First) *(InRoot$$Sections) *(+RO +XO) } #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) ER_CMSE_VENEER AlignExpr(+0, 32) (__ROM0_SIZE_TFM - AlignExpr(ImageLength(ER_ROM0), 32)) { *(Veneer$$CMSE) } #endif RW_NOINIT __RAM0_BASE_TFM UNINIT (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE) { *.o(.bss.noinit) *.o(.bss.noinit.*) } RW_RAM0 AlignExpr(+0, 8) (__RAM0_SIZE_TFM - __HEAP_SIZE - __STACK_SIZE - __STACKSEAL_SIZE - AlignExpr(ImageLength(RW_NOINIT), 8)) { *(+RW +ZI) } :","title":"Multi-processor or multi-project applications"},{"location":"Proposal%20-%20Run%2BDebug%20Management/","text":"Proposal - Run and Debug Management This proposal discusses how the CMSIS-Toolbox may simplify workflows with programming and debug tools. Overview The CMSIS-Pack PDSC files contain information about device/board parameters and software components: Flash algorithms of device memory (in DFP) and board memory (in BSP). On-board debug adapter (a default programming/debug channel) including features. Available memory of device and board. Device parameters such as processor core(s) and clock speed. Debug Access Sequences and System Description Files that support more complex Cortex-A/R/M configurations. CMSIS-SVD System View Description (SVD) files for viewing device peripherals. CMSIS-View Software Component Viewer Description (SCVD) files for analysis of software components (RTOS, Middleware). The CMSIS-Toolbox build system manages device/board/software components and controls the build output (typically ELF/DWARF files) and has provisions for HEX, BIN and post-processing. It allows to manage different target-types and the context set manages the images that belong to a target. In addition the user may need the following information which should be added to the YML-Input files for the CMSIS-Toolbox. Flash algorithms for external memory in custom hardware. Additional images that should be loaded. Device configuration information. Access information for protected debug ports (i.e. encryption keys). Run and Debug Information Management The problems to solve Provide information for command line and IDE workflows in a consistent way. Simplify the implementation in run and debug tools, reduce dependency to other tools. Ensure that information is portable, i.e from a cloud-hosted CI system to a desktop test system. Provide flexibility and ease-of-use. Today, some programmers access DFP and BSP information via the packs. This results in additional complexity of the tool and more dependencies. In VS Code, task configurations control the Run action ( tasks.json ) and launch configurations control the Debug action ( launch.json ). The tasks.json and launch.json files store multiple configurations and are located in the .vscode folder of your workspace (the csolution project root folder). The current implementation uses extension commands to obtain project information. This limits the portability of these files. Example `launch.json: { \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getTargetPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", \"processorName\": \"${command:cmsis-csolution.getProcessorName}\" } ] } Proposed solution Introduce a new target-type specific file *.cbuild-run.yml generated by CMSIS-Toolbox. This file provides access to PDSC information and build output of one target. Potentially export the Debug Access Sequences into an additional parameter file as PDSC file processing is complexity due to device dependencies. Introduce a new folder .cmsis that contains these additional files. This folder might be also used for other build information files. The cbuild-run.yml file represents a context-set. Content of *.cbuild-run.yml : run: # Start of file, contains run and debug information for a target generated-by: csolution version 2.7.0 solution: ../USB_Device.csolution.yml target-type: +STM32U585AIIx compiler: AC6 board: STMicroelectronics::B-U585I-IOT02A:Rev.C board-pack: Keil::B-U585I-IOT02A_BSP@2.0.0 device: STMicroelectronics::STM32U585AIIx device-pack: Keil::STM32U5xx_DFP@3.0.0 programming: # Flash programming algorithms - algorithm: ${CMSIS_PACK_ROOT}/DFP-path/<programming-algorithm> - algorithm: ${CMSIS_PACK_ROOT}/BSP-path/<programming-algorithm> config: <potential config options> # is this required - algorithm: custom-hw-path/<programming-algorithm> output: # application image files - type: elf file: HID.axf load: <scope> # all (default), symbols only, binary only system-description: - file: ${CMSIS_PACK_ROOT}/DFP-path/<svd> type: svd - file: ${CMSIS_PACK_ROOT}/pack-path/<scvd> type: scvd from-pack: <pack> # information from DFP, BSP specific to the target # https://open-cmsis-pack.github.io/Open-CMSIS-Pack-Spec/main/html/packFormat.html board: # Board element debugProbe: ... debugInterface: ... debug-port: # Information from DFP access-port-v1: ... access-port-v2: ... jtag: cjtag: swd: default-settings: # Default debug configuration default: # debug protocol (SWD or JTAG) to use for target connections. clock: # clock setting in Hz for a target connection. swj: # allows Serial Wire Debug (SWD) and JTAG protocols dormant: # device access via CoreSight DP requires the dormant state sdf: ${CMSIS_PACK_ROOT}/DFP-path/<sdf> # path of the system description file (SDF). sequences: ... trace: ... Usage The *.cbuild-run.yml file can be directly passed to programmers and debug tools, for example using a command line option. It contains all information that needs to be passed. >programmer -csolution MySolution+MyHardware.cbuild-run.yml Questions What should be done now to simplify above information while making it more future proof? For CMSIS-Toolbox 3.0: Should the location of cbuild information files change to folder .\\.cmsis ? Should the structure of build information file change and include cbuild-run.yml ? The cbuild information file will then represent a context-set, and not just one context.","title":"Proposal - Run and Debug Management"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#proposal-run-and-debug-management","text":"This proposal discusses how the CMSIS-Toolbox may simplify workflows with programming and debug tools.","title":"Proposal - Run and Debug Management"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#overview","text":"The CMSIS-Pack PDSC files contain information about device/board parameters and software components: Flash algorithms of device memory (in DFP) and board memory (in BSP). On-board debug adapter (a default programming/debug channel) including features. Available memory of device and board. Device parameters such as processor core(s) and clock speed. Debug Access Sequences and System Description Files that support more complex Cortex-A/R/M configurations. CMSIS-SVD System View Description (SVD) files for viewing device peripherals. CMSIS-View Software Component Viewer Description (SCVD) files for analysis of software components (RTOS, Middleware). The CMSIS-Toolbox build system manages device/board/software components and controls the build output (typically ELF/DWARF files) and has provisions for HEX, BIN and post-processing. It allows to manage different target-types and the context set manages the images that belong to a target. In addition the user may need the following information which should be added to the YML-Input files for the CMSIS-Toolbox. Flash algorithms for external memory in custom hardware. Additional images that should be loaded. Device configuration information. Access information for protected debug ports (i.e. encryption keys).","title":"Overview"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#run-and-debug-information-management","text":"","title":"Run and Debug Information Management"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#the-problems-to-solve","text":"Provide information for command line and IDE workflows in a consistent way. Simplify the implementation in run and debug tools, reduce dependency to other tools. Ensure that information is portable, i.e from a cloud-hosted CI system to a desktop test system. Provide flexibility and ease-of-use. Today, some programmers access DFP and BSP information via the packs. This results in additional complexity of the tool and more dependencies. In VS Code, task configurations control the Run action ( tasks.json ) and launch configurations control the Debug action ( launch.json ). The tasks.json and launch.json files store multiple configurations and are located in the .vscode folder of your workspace (the csolution project root folder). The current implementation uses extension commands to obtain project information. This limits the portability of these files. Example `launch.json: { \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getTargetPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", \"processorName\": \"${command:cmsis-csolution.getProcessorName}\" } ] }","title":"The problems to solve"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#proposed-solution","text":"Introduce a new target-type specific file *.cbuild-run.yml generated by CMSIS-Toolbox. This file provides access to PDSC information and build output of one target. Potentially export the Debug Access Sequences into an additional parameter file as PDSC file processing is complexity due to device dependencies. Introduce a new folder .cmsis that contains these additional files. This folder might be also used for other build information files. The cbuild-run.yml file represents a context-set. Content of *.cbuild-run.yml : run: # Start of file, contains run and debug information for a target generated-by: csolution version 2.7.0 solution: ../USB_Device.csolution.yml target-type: +STM32U585AIIx compiler: AC6 board: STMicroelectronics::B-U585I-IOT02A:Rev.C board-pack: Keil::B-U585I-IOT02A_BSP@2.0.0 device: STMicroelectronics::STM32U585AIIx device-pack: Keil::STM32U5xx_DFP@3.0.0 programming: # Flash programming algorithms - algorithm: ${CMSIS_PACK_ROOT}/DFP-path/<programming-algorithm> - algorithm: ${CMSIS_PACK_ROOT}/BSP-path/<programming-algorithm> config: <potential config options> # is this required - algorithm: custom-hw-path/<programming-algorithm> output: # application image files - type: elf file: HID.axf load: <scope> # all (default), symbols only, binary only system-description: - file: ${CMSIS_PACK_ROOT}/DFP-path/<svd> type: svd - file: ${CMSIS_PACK_ROOT}/pack-path/<scvd> type: scvd from-pack: <pack> # information from DFP, BSP specific to the target # https://open-cmsis-pack.github.io/Open-CMSIS-Pack-Spec/main/html/packFormat.html board: # Board element debugProbe: ... debugInterface: ... debug-port: # Information from DFP access-port-v1: ... access-port-v2: ... jtag: cjtag: swd: default-settings: # Default debug configuration default: # debug protocol (SWD or JTAG) to use for target connections. clock: # clock setting in Hz for a target connection. swj: # allows Serial Wire Debug (SWD) and JTAG protocols dormant: # device access via CoreSight DP requires the dormant state sdf: ${CMSIS_PACK_ROOT}/DFP-path/<sdf> # path of the system description file (SDF). sequences: ... trace: ...","title":"Proposed solution"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#usage","text":"The *.cbuild-run.yml file can be directly passed to programmers and debug tools, for example using a command line option. It contains all information that needs to be passed. >programmer -csolution MySolution+MyHardware.cbuild-run.yml","title":"Usage"},{"location":"Proposal%20-%20Run%2BDebug%20Management/#questions","text":"What should be done now to simplify above information while making it more future proof? For CMSIS-Toolbox 3.0: Should the location of cbuild information files change to folder .\\.cmsis ? Should the structure of build information file change and include cbuild-run.yml ? The cbuild information file will then represent a context-set, and not just one context.","title":"Questions"},{"location":"ReferenceApplications/","text":"Reference Applications This chapter explains how to work with Reference Applications that can run on several evaluation boards. Introduction The CMSIS-Pack format supports different types of project examples: Template Projects are stub projects that help getting started. Some software packs may contain device specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These project examples show usage of middleware components and require additional software layers with API drivers for the specific target hardware, typically an evaluation board. The following sections explain the usage, structure, and creation of Reference Applications that can target many different evaluation boards. Refer to Pack Creation s\u00bb Project Examples for information on how to publish projects examples as part of software packs. Types of Reference Applications Reference Applications may show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Such software uses application programming interfaces (APIs) to interface with hardware interfaces or other software components. MDK-Middleware Reference Applications The MDK-Middleware provides software components for IPv4/IPv6 networking, USB Host/Device communication, and a variety of file systems for data storage. The MDK-Middleware software pack contains Reference Applications that show the usage of these software components. These examples are hardware agnostic; adding a board layer that provides the required APIs allows runnig the example project on a specific target hardware. The picture above shows how a USB HID example connects to a board specific software layer. The Reference Application does not specify a target hardware. For execution on target hardware, a software layer is required that provides the hardware specific APIs. These board specific layers are provided in BSP packs which allows to run the example on many different hardware targets. The Reference example uses connections: to list the consumed (required) APIs. The board layer in the BSP pack provides these connections: and may offer several additional connections: that makes the layer suitable for a wide range of Reference Applications . As the Reference Application is not hardware specific, it does not define a target type. Also, it does not add the board specific software layer. It requires two steps to configure the *.csolution.yml file of such an example for an evaluation board. Refer to the Usage section for more information. Reference Application *.csolution.yml file solution: cdefault: compiler: AC6 : packs: # Step 1: Specify DFP and BSP for the device and board, for example with: # - pack: Keil::STM32U5xx_DFP # - pack: Keil::B-U585I-IOT02A_BSP target-types: # Step 1: Specify your board, for example with: # - type: STM32U585 # board: B-U585I-IOT02A # Step 2: Run `cbuild setup` and use cbuild-idx.yml to identify variables, for example: # variables: # - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml Sensor Reference Applications The overall concept of Reference Applications and the same board specific software layers can be used for a wide range of software stacks. For example, a sensor SDK pack may provide Reference Applications that show the usage of a MEMS sensor. This MEMS sensor is additional hardware that could be provided by a widely supported Arduino UNO shield. The sensor SDK with the related Arduino shield can be structured to work with a wide range of evaluation boards that offer a compatible board specific software layer. The overall structure of a sensor example project is shown in the picture below. It is composed of: The Reference Application with sensor specific middleware that shows the usage of a MEMS sensor. Layer type: Board contains the hardware specific setup of an evaluation board with a Cortex-M processor along with drivers, i.e. for SPI or I2C that connect to the pins of the Arduino shield. Layer type: Shield defines the pin routing of the Arduino UNO shield that adds the MEMS sensor to the evaluation board. Note As the connections: for the MEMS sensor are specific to the sensor itself, the same Reference Application also works with an evaluation board that integrates the MEMS sensor (and requires therefore no Shield layer). The board specific software layer adds in this case the sensor specific connections: . Targeting Custom Hardware A Reference Application may serve as starting point for user applications that target custom hardware. It is required to provide: A software layer with a compatible set of APIs ( connections: ) consumed by the Reference Application . This software layer can be added along with the target type (in the *.csolution.yml file) that defines the custom hardware. Note It is not required to define connections: as this information is only used to identify compatible layers. A header file that replaces the CMSIS_target_header . Refer to Header File Structure for more information. Example *.csolution.yml file for custom hardware solution: cdefault: compiler: AC6 : target-types: - type: MyHardware device: STM32U585AIIx # custom hardware uses only a device definition variables: - Board-Layer: %SolutionDir$/MyTarget/MyHardware.clayer.yml Example MyHardware.clayer.yml You may use a *.clayer.yml file for implementing the HAL drivers for the application and define the CMSIS_target_header as shown below: layer: : define: - CMSIS_target_header: \"\\\"MyHardware.h\\\"\" Usage A Reference Application is an incomplete *.csolution.yml project file that requires additional intervention. The following steps explain how to to compile the project: In the *.csolution.yml file under the packs: node, add the DFP (for the device) and the BSP (for the board). Under target-types: , add your board. solution: cdefault: : packs: - pack: Keil::STM32U5xx_DFP - pack: Keil::B-U585I-IOT02A_BSP target-types: - type: MyBoard board: B-U585I-IOT02A # name of a target board Run cbuild setup with the *.csolution.yml file. This identifies compatible layers with an output similar to: >cbuild setup xxx.csolution.yml error csolution: undefined variables in xxx.csolution.yml: - $Board-Layer$ To resolve undefined variables, copy the settings from cbuild-idx.yml to csolution.yml The related *.cbuild-idx.yml should contain information similar to this: build-idx: generated-by: csolution version 2.4.0 cdefault: cdefault.yml csolution: xxx.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml description: B-U585I-IOT02A Board setup for IoT path: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT file: Board.clayer.yml copy-to: .Board/U585 As a user you have now two choices to work with the identified software layer: Refer layers in ${CMSIS_PACK_ROOT} This is useful when there is no plan to modify the software layer, for example in the early phase of adoption. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml Copy layers to csolution project This allows to modify the layer, for example add or remove drivers or change device settings. It requires these steps: Copy all files from path , i.e. ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT to the local csolution project directory. If set, remove the R/O attribute from the copied files. Under variables: , add the path to the *.clayer.yml file. Use $SolutionDir() as base path to make the project portable. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml Note The copy step is executed for you by some IDEs during the Create New Project workflow. Structure The following section describes the overall file structure of Reference Applications . Project Files A *.csolution.yml project file that contains software layers for two different evaluation boards should look like shown below. This project contains three different examples that show different features of a USB device middleware. The actual example project (HID, MSC, or CDC1) is selected using a context set ; the compiler is selected using the --toolchain option. To translate the completed Reference Applications use: cbuild USB_Device.csolution.yml --context-set --toolchain AC6 Example USB_Device.csolution.yml file for two boards with three projects solution: created-for: CMSIS-Toolbox@2.4.0 cdefault: target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A variables: - Board-Layer: $SolutionDir()$\\Board\\B-U585I-IOT02A\\Board.clayer.yml - type: LPC55S69-EVK # type name identical with board name? board: LPC55S69-EVK variables: - Board-Layer: $SolutionDir()$\\Board\\LPC55S69-EVK\\Board.clayer.yml build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: HID/HID.cproject.yml - project: MSC/MassStorage.cproject.yml - project: CDC1/VirtualCOM.cproject.yml Typical Directory Structure The table below shows the typical directory structure of the above example from the programmers point of view. The software layer in the directory ./Board is copied from the BSP of the related board. Directory Content Content USB_Device.csolution.yml Overall CMSIS solution project file. ./HID/ HID example project from MDK-Middleware pack. ./MSC/ MSC example project from MDK-Middleware pack. ./CDC1/ CDC1 example project from MDK-Middleware pack. ./Board/B-U585I-IOT02A Board software layer from B-U585I-IOT02A BSP. ./Board/LPC55S69-EVK Board software layer from LPC55S69-EVK BSP. Header File Structure The interfaces between the software layers are defined in header files. Thus, is it possible to reuse the various software blocks with other build systems that are not CMSIS aware. The following diagram shows the overall header file structure. The Reference Application has no direct access to hardware. Therefore, it does not use the CMSIS_device_header provided by the CMSIS-Core that defines the registers and interrupt mapping. To access target hardware, these header files are used by the Reference Application : Standardized Driver API header files are used for the communication with device peripherals. Header files of CMSIS-Drivers are provided by the CMSIS base software pack . The configuration of the driver interfaces is defined by the CMSIS_target_header . This header therefore specifies the available resources of the target hardware that can be used by the Reference Application . The Header File Example shows a typical structure of the CMSIS_target_header . When a shield is applied to an evaluation board, the CMSIS_shield_header extends the resource configuration of the CMSIS_target_header . Note The driver implementation of the hardware abstraction might use shim layer as shown on the right side of above diagram. For example, the driver implementation for STM32 devices uses the STM32 HAL. Application Program Start A Reference Application starts with the C function app_main as shown below. #include CMSIS_target_header // board resource definitions // reference application of a middleware component int app_main (void) { }; The application may use a RTOS kernel or run a simple while loop. Additional software components such as CMSIS-View , CMSIS-DSP , or MbedTLS are added directly to the Reference Application . In general, the connections: that are consumed should be minimized allowing to run the example on many different target boards. Board Layer The board layer provides system startup, board/device hardware initialization, and transfers control to the application. It also exposes various drivers and interfaces. Typical Features: System startup including clock and memory configuration. Device/Board hardware initialization. Calls the application startup function. Drivers for board peripherals [optional]. Interfaces to LEDs and switches [optional]. STDIO re-targeting to debug interfaces [optional]. Shield setup and drivers for Arduino interfaces [optional]. Heap and Stack configuration [optional]. Files: CMSIS startup and system file for device initialization. main.c source module that implements the function main . Optional drivers and interfaces (CMSIS-Drivers, GPIO, STDIO). Files that relate to the device and/or board configuration (i.e. generated by MCUXpresso or STM32CubeMX) Linker script definition for boards that require specific memory configurations. The configuration parameters of the available APIs are defined in CMSIS_target_header . Generator Usage: The board specific software layer is used by many different projects. When a board configuration is generated by tools, such as MCUXpresso or STM32CubeMX for example, configure the generator output directory and import file using the generators: node in the *.clayer.yml file as shown below: layer: generators: options: - generator: CubeMX path: ./CubeMX name: Board Shield Layer A shield layer adds support for additional hardware via plugin shields (i.e. Arduino Uno). Arduino shields consume connections with the prefix ARDUINO_UNO_ . In the future, other shields may be supported as well. Shields may feature various hardware modules such as WiFi chips or MEMS sensors. Frequently, the shield's software layer only defines a header file that redirects the Arduino specific connect: to a chip specific connect: that is then used by application software. The shield's software layer is configured from the board software layer which calls the following function: extern int32_t shield_setup (void); Connections Connections are only used to identify compatible software layers. There are no strict rules for the connect Name it is therefore possible to extend it with additional name spacing, i.e. prefix with ST_ to denote ST specific interfaces. There are also no strict rules how the different software layers consume or provide the connect names. However, guidelines will be developed once reference applications mature. Currently, the following connect names are used. connect name Value Description . . Arduino Shield Interface ARDUINO_UNO_UART - CMSIS-Driver USART connecting to UART on Arduino pins D0..D1 ARDUINO_UNO_SPI - CMSIS-Driver SPI connecting to SPI on Arduino pins D10..D13 ARDUINO_UNO_I2C - CMSIS-Driver I2C connecting to I2C on Arduino pins D20..D21 ARDUINO_UNO_I2C-Alt - CMSIS-Driver I2C connecting to I2C on Arduino pins D18..D19 ARDUINO_UNO_D0 .. D21 - CMSIS-Driver GPIO connecting to Arduino pins D0..D21 . . CMSIS Driver and RTOS Interfaces CMSIS_ETH - CMSIS-Driver ETH connected to physical board connector CMSIS_MCI - CMSIS-Driver MCI connected to physical board connector CMSIS_USB_Device - CMSIS-Driver USB Device connected to physical board connector CMSIS_USB_Host - CMSIS-Driver USB Host connected to physical board connector CMSIS_VIO - CMSIS-Driver VIO interface for virtual I/O CMSIS-RTOS2 - CMSIS-RTOS2 compliant RTOS . . I/O Retargeting STDERR - Standard Error output STDIN - Standard Input STDOUT - Standard Output . . Memory allocation Heap Heap Size Memory heap configuration ToDo: what features of CMSIS-RTOS2 are typically used by board layers? more information about Heap. How is it configured? Which existing Reference Applications are using it? FreeRTOS has it's own heap management; is it really required? ARDUINO_UNO_UART Connects to a CMSIS-Driver USART Interface configured in asynchronous UART mode with no modem lines. CMSIS_target_header contains driver instance number with this define: #define ARDUINO_UNO_UART 3 // CMSIS-Driver USART instance number ARDUINO_UNO_I2C / ARDUINO_UNO_I2C-Alt Connects to a CMSIS-Driver I2C Interface configured in controller mode. CMSIS_target_header contains driver instance number with this define: #define ARDUINO_UNO_I2C 0 // CMSIS-Driver I2C instance number ARDUINO_UNO_SPI Connects to a CMSIS-Driver SPI Interface configured in controller mode and CPOL/CPHA frame format (no TI or Microwire). The Target Select (SS) pin (typically on ARDUINO_UNO_D10) is not handled by CMSIS-Driver SPI interface. This is driven by the GPIO interface. CMSIS_target_header contains driver instance number with this define: #define ARDUINO_UNO_SPI 1 // CMSIS-Driver SPI instance number ARDUINO_UNO_D0 .. D21 Connects to a CMSIS-Driver GPIO Interface . CMSIS_target_header contains the pin mapping to the physical driver. #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */ CMSIS_ETH Connects to a CMSIS-Driver Ethernet Interface that offers a physical Ethernet connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_ETH 0 // CMSIS-Driver Ethernet instance number CMSIS_MCI Connects to a CMSIS-Driver MCI Interface that offers a physical memory card connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_MCI 0 // CMSIS-Driver MCI instance number CMSIS_USB_Device Connects to a CMSIS-Driver USB Device Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBD 0 // CMSIS-Driver USB Device instance number CMSIS_USB_Host Connects to a CMSIS-Driver USB Host Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBH 0 // CMSIS-Driver USB Host instance number CMSIS_VIO Connects to a CMSIS-Driver VIO Interface , a virtual I/O interface that connects on physical boards to LEDs and switches. STDIN / STDOUT / STDERR I/O redirection via the CMSIS-Compiler software component. Typical the redirect is to a UART dedicated for debugging. Arduino Shield The software layers Board and Shield are currently based on Arduino UNO connectors. To combine different boards and shields a consistent pin naming is required. The standardized mapping is shown in the diagram below. Header File Example Two header files contain I/O configuration settings for the application program: CMSIS_target_header defines the resources available by the evaluation board. CMSIS_shield_header extends this CMSIS_target_header with resources of a shield that is applied to an evaluation board. Refer to Header File Structure for more information. CMSIS_target_header #ifndef B_U585I_IOT02A_H_ #define B_U585I_IOT02A_H_ #include \"stm32u5xx_hal.h\" #include \"GPIO_STM32U5xx.h\" #include \"Driver_I2C.h\" // ToDo are these headers included in CMSIS_target_header? #include \"Driver_SPI.h\" #include \"Driver_USART.h\" // B-U585I-IOT02A Arduino Connector Pin Defintions #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */ // CMSIS Driver instances on Arduino connector #define ARDUINO_UNO_I2C 1 #define ARDUINO_UNO_SPI 1 #define ARDUINO_UNO_UART 3 // CMSIS Driver instances of Board peripherals #define CMSIS_DRIVER_USBD 0 // instance of CMSIS-Driver USB Device // CMSIS Drivers extern ARM_DRIVER_I2C Driver_I2C1; extern ARM_DRIVER_SPI Driver_SPI1; extern ARM_DRIVER_USART Driver_USART1; extern ARM_DRIVER_USART Driver_USART3; #ifdef CMSIS_shield_header #include CMSIS_shield_header #endif #endif /* B_U585I_IOT02A_H_ */ CMSIS_shield_header #ifndef _FRDM_STBC_AGM01_SHIELD_H_ #define _FRDM_STBC_AGM01_SHIELD_H_ // FRDM-STBC-AGM01 Shield Reset #define RESET_GPIO ARDUINO_UNO_D17 #define SHIELD_MULTIB 0 #define SHIELD_NONE 1 #define SHIELD_AGM01 2 #define SHIELD_AGM02 3 #define SHIELD_AGMP03 4 #define SHIELD_AGM04 5 #define THIS_SHIELD SHIELD_AGM01 // Shield Setup (default configuration) extern int32_t shield_setup (void); #endif /* _FRDM_STBC_AGM01_SHIELD_H_ */","title":"Reference Applications"},{"location":"ReferenceApplications/#reference-applications","text":"This chapter explains how to work with Reference Applications that can run on several evaluation boards.","title":"Reference Applications"},{"location":"ReferenceApplications/#introduction","text":"The CMSIS-Pack format supports different types of project examples: Template Projects are stub projects that help getting started. Some software packs may contain device specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These project examples show usage of middleware components and require additional software layers with API drivers for the specific target hardware, typically an evaluation board. The following sections explain the usage, structure, and creation of Reference Applications that can target many different evaluation boards. Refer to Pack Creation s\u00bb Project Examples for information on how to publish projects examples as part of software packs.","title":"Introduction"},{"location":"ReferenceApplications/#types-of-reference-applications","text":"Reference Applications may show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Such software uses application programming interfaces (APIs) to interface with hardware interfaces or other software components.","title":"Types of Reference Applications"},{"location":"ReferenceApplications/#mdk-middleware-reference-applications","text":"The MDK-Middleware provides software components for IPv4/IPv6 networking, USB Host/Device communication, and a variety of file systems for data storage. The MDK-Middleware software pack contains Reference Applications that show the usage of these software components. These examples are hardware agnostic; adding a board layer that provides the required APIs allows runnig the example project on a specific target hardware. The picture above shows how a USB HID example connects to a board specific software layer. The Reference Application does not specify a target hardware. For execution on target hardware, a software layer is required that provides the hardware specific APIs. These board specific layers are provided in BSP packs which allows to run the example on many different hardware targets. The Reference example uses connections: to list the consumed (required) APIs. The board layer in the BSP pack provides these connections: and may offer several additional connections: that makes the layer suitable for a wide range of Reference Applications . As the Reference Application is not hardware specific, it does not define a target type. Also, it does not add the board specific software layer. It requires two steps to configure the *.csolution.yml file of such an example for an evaluation board. Refer to the Usage section for more information. Reference Application *.csolution.yml file solution: cdefault: compiler: AC6 : packs: # Step 1: Specify DFP and BSP for the device and board, for example with: # - pack: Keil::STM32U5xx_DFP # - pack: Keil::B-U585I-IOT02A_BSP target-types: # Step 1: Specify your board, for example with: # - type: STM32U585 # board: B-U585I-IOT02A # Step 2: Run `cbuild setup` and use cbuild-idx.yml to identify variables, for example: # variables: # - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml","title":"MDK-Middleware Reference Applications"},{"location":"ReferenceApplications/#sensor-reference-applications","text":"The overall concept of Reference Applications and the same board specific software layers can be used for a wide range of software stacks. For example, a sensor SDK pack may provide Reference Applications that show the usage of a MEMS sensor. This MEMS sensor is additional hardware that could be provided by a widely supported Arduino UNO shield. The sensor SDK with the related Arduino shield can be structured to work with a wide range of evaluation boards that offer a compatible board specific software layer. The overall structure of a sensor example project is shown in the picture below. It is composed of: The Reference Application with sensor specific middleware that shows the usage of a MEMS sensor. Layer type: Board contains the hardware specific setup of an evaluation board with a Cortex-M processor along with drivers, i.e. for SPI or I2C that connect to the pins of the Arduino shield. Layer type: Shield defines the pin routing of the Arduino UNO shield that adds the MEMS sensor to the evaluation board. Note As the connections: for the MEMS sensor are specific to the sensor itself, the same Reference Application also works with an evaluation board that integrates the MEMS sensor (and requires therefore no Shield layer). The board specific software layer adds in this case the sensor specific connections: .","title":"Sensor Reference Applications"},{"location":"ReferenceApplications/#targeting-custom-hardware","text":"A Reference Application may serve as starting point for user applications that target custom hardware. It is required to provide: A software layer with a compatible set of APIs ( connections: ) consumed by the Reference Application . This software layer can be added along with the target type (in the *.csolution.yml file) that defines the custom hardware. Note It is not required to define connections: as this information is only used to identify compatible layers. A header file that replaces the CMSIS_target_header . Refer to Header File Structure for more information. Example *.csolution.yml file for custom hardware solution: cdefault: compiler: AC6 : target-types: - type: MyHardware device: STM32U585AIIx # custom hardware uses only a device definition variables: - Board-Layer: %SolutionDir$/MyTarget/MyHardware.clayer.yml Example MyHardware.clayer.yml You may use a *.clayer.yml file for implementing the HAL drivers for the application and define the CMSIS_target_header as shown below: layer: : define: - CMSIS_target_header: \"\\\"MyHardware.h\\\"\"","title":"Targeting Custom Hardware"},{"location":"ReferenceApplications/#usage","text":"A Reference Application is an incomplete *.csolution.yml project file that requires additional intervention. The following steps explain how to to compile the project: In the *.csolution.yml file under the packs: node, add the DFP (for the device) and the BSP (for the board). Under target-types: , add your board. solution: cdefault: : packs: - pack: Keil::STM32U5xx_DFP - pack: Keil::B-U585I-IOT02A_BSP target-types: - type: MyBoard board: B-U585I-IOT02A # name of a target board Run cbuild setup with the *.csolution.yml file. This identifies compatible layers with an output similar to: >cbuild setup xxx.csolution.yml error csolution: undefined variables in xxx.csolution.yml: - $Board-Layer$ To resolve undefined variables, copy the settings from cbuild-idx.yml to csolution.yml The related *.cbuild-idx.yml should contain information similar to this: build-idx: generated-by: csolution version 2.4.0 cdefault: cdefault.yml csolution: xxx.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml description: B-U585I-IOT02A Board setup for IoT path: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT file: Board.clayer.yml copy-to: .Board/U585 As a user you have now two choices to work with the identified software layer:","title":"Usage"},{"location":"ReferenceApplications/#refer-layers-in-cmsis_pack_root","text":"This is useful when there is no plan to modify the software layer, for example in the early phase of adoption. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml","title":"Refer layers in ${CMSIS_PACK_ROOT}"},{"location":"ReferenceApplications/#copy-layers-to-csolution-project","text":"This allows to modify the layer, for example add or remove drivers or change device settings. It requires these steps: Copy all files from path , i.e. ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT to the local csolution project directory. If set, remove the R/O attribute from the copied files. Under variables: , add the path to the *.clayer.yml file. Use $SolutionDir() as base path to make the project portable. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml Note The copy step is executed for you by some IDEs during the Create New Project workflow.","title":"Copy layers to csolution project"},{"location":"ReferenceApplications/#structure","text":"The following section describes the overall file structure of Reference Applications .","title":"Structure"},{"location":"ReferenceApplications/#project-files","text":"A *.csolution.yml project file that contains software layers for two different evaluation boards should look like shown below. This project contains three different examples that show different features of a USB device middleware. The actual example project (HID, MSC, or CDC1) is selected using a context set ; the compiler is selected using the --toolchain option. To translate the completed Reference Applications use: cbuild USB_Device.csolution.yml --context-set --toolchain AC6 Example USB_Device.csolution.yml file for two boards with three projects solution: created-for: CMSIS-Toolbox@2.4.0 cdefault: target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A variables: - Board-Layer: $SolutionDir()$\\Board\\B-U585I-IOT02A\\Board.clayer.yml - type: LPC55S69-EVK # type name identical with board name? board: LPC55S69-EVK variables: - Board-Layer: $SolutionDir()$\\Board\\LPC55S69-EVK\\Board.clayer.yml build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: HID/HID.cproject.yml - project: MSC/MassStorage.cproject.yml - project: CDC1/VirtualCOM.cproject.yml","title":"Project Files"},{"location":"ReferenceApplications/#typical-directory-structure","text":"The table below shows the typical directory structure of the above example from the programmers point of view. The software layer in the directory ./Board is copied from the BSP of the related board. Directory Content Content USB_Device.csolution.yml Overall CMSIS solution project file. ./HID/ HID example project from MDK-Middleware pack. ./MSC/ MSC example project from MDK-Middleware pack. ./CDC1/ CDC1 example project from MDK-Middleware pack. ./Board/B-U585I-IOT02A Board software layer from B-U585I-IOT02A BSP. ./Board/LPC55S69-EVK Board software layer from LPC55S69-EVK BSP.","title":"Typical Directory Structure"},{"location":"ReferenceApplications/#header-file-structure","text":"The interfaces between the software layers are defined in header files. Thus, is it possible to reuse the various software blocks with other build systems that are not CMSIS aware. The following diagram shows the overall header file structure. The Reference Application has no direct access to hardware. Therefore, it does not use the CMSIS_device_header provided by the CMSIS-Core that defines the registers and interrupt mapping. To access target hardware, these header files are used by the Reference Application : Standardized Driver API header files are used for the communication with device peripherals. Header files of CMSIS-Drivers are provided by the CMSIS base software pack . The configuration of the driver interfaces is defined by the CMSIS_target_header . This header therefore specifies the available resources of the target hardware that can be used by the Reference Application . The Header File Example shows a typical structure of the CMSIS_target_header . When a shield is applied to an evaluation board, the CMSIS_shield_header extends the resource configuration of the CMSIS_target_header . Note The driver implementation of the hardware abstraction might use shim layer as shown on the right side of above diagram. For example, the driver implementation for STM32 devices uses the STM32 HAL.","title":"Header File Structure"},{"location":"ReferenceApplications/#application-program-start","text":"A Reference Application starts with the C function app_main as shown below. #include CMSIS_target_header // board resource definitions // reference application of a middleware component int app_main (void) { }; The application may use a RTOS kernel or run a simple while loop. Additional software components such as CMSIS-View , CMSIS-DSP , or MbedTLS are added directly to the Reference Application . In general, the connections: that are consumed should be minimized allowing to run the example on many different target boards.","title":"Application Program Start"},{"location":"ReferenceApplications/#board-layer","text":"The board layer provides system startup, board/device hardware initialization, and transfers control to the application. It also exposes various drivers and interfaces. Typical Features: System startup including clock and memory configuration. Device/Board hardware initialization. Calls the application startup function. Drivers for board peripherals [optional]. Interfaces to LEDs and switches [optional]. STDIO re-targeting to debug interfaces [optional]. Shield setup and drivers for Arduino interfaces [optional]. Heap and Stack configuration [optional]. Files: CMSIS startup and system file for device initialization. main.c source module that implements the function main . Optional drivers and interfaces (CMSIS-Drivers, GPIO, STDIO). Files that relate to the device and/or board configuration (i.e. generated by MCUXpresso or STM32CubeMX) Linker script definition for boards that require specific memory configurations. The configuration parameters of the available APIs are defined in CMSIS_target_header . Generator Usage: The board specific software layer is used by many different projects. When a board configuration is generated by tools, such as MCUXpresso or STM32CubeMX for example, configure the generator output directory and import file using the generators: node in the *.clayer.yml file as shown below: layer: generators: options: - generator: CubeMX path: ./CubeMX name: Board","title":"Board Layer"},{"location":"ReferenceApplications/#shield-layer","text":"A shield layer adds support for additional hardware via plugin shields (i.e. Arduino Uno). Arduino shields consume connections with the prefix ARDUINO_UNO_ . In the future, other shields may be supported as well. Shields may feature various hardware modules such as WiFi chips or MEMS sensors. Frequently, the shield's software layer only defines a header file that redirects the Arduino specific connect: to a chip specific connect: that is then used by application software. The shield's software layer is configured from the board software layer which calls the following function: extern int32_t shield_setup (void);","title":"Shield Layer"},{"location":"ReferenceApplications/#connections","text":"Connections are only used to identify compatible software layers. There are no strict rules for the connect Name it is therefore possible to extend it with additional name spacing, i.e. prefix with ST_ to denote ST specific interfaces. There are also no strict rules how the different software layers consume or provide the connect names. However, guidelines will be developed once reference applications mature. Currently, the following connect names are used. connect name Value Description . . Arduino Shield Interface ARDUINO_UNO_UART - CMSIS-Driver USART connecting to UART on Arduino pins D0..D1 ARDUINO_UNO_SPI - CMSIS-Driver SPI connecting to SPI on Arduino pins D10..D13 ARDUINO_UNO_I2C - CMSIS-Driver I2C connecting to I2C on Arduino pins D20..D21 ARDUINO_UNO_I2C-Alt - CMSIS-Driver I2C connecting to I2C on Arduino pins D18..D19 ARDUINO_UNO_D0 .. D21 - CMSIS-Driver GPIO connecting to Arduino pins D0..D21 . . CMSIS Driver and RTOS Interfaces CMSIS_ETH - CMSIS-Driver ETH connected to physical board connector CMSIS_MCI - CMSIS-Driver MCI connected to physical board connector CMSIS_USB_Device - CMSIS-Driver USB Device connected to physical board connector CMSIS_USB_Host - CMSIS-Driver USB Host connected to physical board connector CMSIS_VIO - CMSIS-Driver VIO interface for virtual I/O CMSIS-RTOS2 - CMSIS-RTOS2 compliant RTOS . . I/O Retargeting STDERR - Standard Error output STDIN - Standard Input STDOUT - Standard Output . . Memory allocation Heap Heap Size Memory heap configuration ToDo: what features of CMSIS-RTOS2 are typically used by board layers? more information about Heap. How is it configured? Which existing Reference Applications are using it? FreeRTOS has it's own heap management; is it really required?","title":"Connections"},{"location":"ReferenceApplications/#arduino_uno_uart","text":"Connects to a CMSIS-Driver USART Interface configured in asynchronous UART mode with no modem lines. CMSIS_target_header contains driver instance number with this define: #define ARDUINO_UNO_UART 3 // CMSIS-Driver USART instance number","title":"ARDUINO_UNO_UART"},{"location":"ReferenceApplications/#arduino_uno_i2c-arduino_uno_i2c-alt","text":"Connects to a CMSIS-Driver I2C Interface configured in controller mode. CMSIS_target_header contains driver instance number with this define: #define ARDUINO_UNO_I2C 0 // CMSIS-Driver I2C instance number","title":"ARDUINO_UNO_I2C / ARDUINO_UNO_I2C-Alt"},{"location":"ReferenceApplications/#arduino_uno_spi","text":"Connects to a CMSIS-Driver SPI Interface configured in controller mode and CPOL/CPHA frame format (no TI or Microwire). The Target Select (SS) pin (typically on ARDUINO_UNO_D10) is not handled by CMSIS-Driver SPI interface. This is driven by the GPIO interface. CMSIS_target_header contains driver instance number with this define: #define ARDUINO_UNO_SPI 1 // CMSIS-Driver SPI instance number","title":"ARDUINO_UNO_SPI"},{"location":"ReferenceApplications/#arduino_uno_d0-d21","text":"Connects to a CMSIS-Driver GPIO Interface . CMSIS_target_header contains the pin mapping to the physical driver. #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */","title":"ARDUINO_UNO_D0 .. D21"},{"location":"ReferenceApplications/#cmsis_eth","text":"Connects to a CMSIS-Driver Ethernet Interface that offers a physical Ethernet connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_ETH 0 // CMSIS-Driver Ethernet instance number","title":"CMSIS_ETH"},{"location":"ReferenceApplications/#cmsis_mci","text":"Connects to a CMSIS-Driver MCI Interface that offers a physical memory card connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_MCI 0 // CMSIS-Driver MCI instance number","title":"CMSIS_MCI"},{"location":"ReferenceApplications/#cmsis_usb_device","text":"Connects to a CMSIS-Driver USB Device Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBD 0 // CMSIS-Driver USB Device instance number","title":"CMSIS_USB_Device"},{"location":"ReferenceApplications/#cmsis_usb_host","text":"Connects to a CMSIS-Driver USB Host Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBH 0 // CMSIS-Driver USB Host instance number","title":"CMSIS_USB_Host"},{"location":"ReferenceApplications/#cmsis_vio","text":"Connects to a CMSIS-Driver VIO Interface , a virtual I/O interface that connects on physical boards to LEDs and switches.","title":"CMSIS_VIO"},{"location":"ReferenceApplications/#stdin-stdout-stderr","text":"I/O redirection via the CMSIS-Compiler software component. Typical the redirect is to a UART dedicated for debugging.","title":"STDIN / STDOUT / STDERR"},{"location":"ReferenceApplications/#arduino-shield","text":"The software layers Board and Shield are currently based on Arduino UNO connectors. To combine different boards and shields a consistent pin naming is required. The standardized mapping is shown in the diagram below.","title":"Arduino Shield"},{"location":"ReferenceApplications/#header-file-example","text":"Two header files contain I/O configuration settings for the application program: CMSIS_target_header defines the resources available by the evaluation board. CMSIS_shield_header extends this CMSIS_target_header with resources of a shield that is applied to an evaluation board. Refer to Header File Structure for more information. CMSIS_target_header #ifndef B_U585I_IOT02A_H_ #define B_U585I_IOT02A_H_ #include \"stm32u5xx_hal.h\" #include \"GPIO_STM32U5xx.h\" #include \"Driver_I2C.h\" // ToDo are these headers included in CMSIS_target_header? #include \"Driver_SPI.h\" #include \"Driver_USART.h\" // B-U585I-IOT02A Arduino Connector Pin Defintions #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */ // CMSIS Driver instances on Arduino connector #define ARDUINO_UNO_I2C 1 #define ARDUINO_UNO_SPI 1 #define ARDUINO_UNO_UART 3 // CMSIS Driver instances of Board peripherals #define CMSIS_DRIVER_USBD 0 // instance of CMSIS-Driver USB Device // CMSIS Drivers extern ARM_DRIVER_I2C Driver_I2C1; extern ARM_DRIVER_SPI Driver_SPI1; extern ARM_DRIVER_USART Driver_USART1; extern ARM_DRIVER_USART Driver_USART3; #ifdef CMSIS_shield_header #include CMSIS_shield_header #endif #endif /* B_U585I_IOT02A_H_ */ CMSIS_shield_header #ifndef _FRDM_STBC_AGM01_SHIELD_H_ #define _FRDM_STBC_AGM01_SHIELD_H_ // FRDM-STBC-AGM01 Shield Reset #define RESET_GPIO ARDUINO_UNO_D17 #define SHIELD_MULTIB 0 #define SHIELD_NONE 1 #define SHIELD_AGM01 2 #define SHIELD_AGM02 3 #define SHIELD_AGMP03 4 #define SHIELD_AGM04 5 #define THIS_SHIELD SHIELD_AGM01 // Shield Setup (default configuration) extern int32_t shield_setup (void); #endif /* _FRDM_STBC_AGM01_SHIELD_H_ */","title":"Header File Example"},{"location":"YML-CBuild-Format/","text":"Build Information Files The following chapter explains the YAML cbuild format that describes how to build a complete application. cbuild Output Files The following output files are generated by the csolution tool. Depending on options, the files *.cbuild-pack.yml and *.cbuild-set.yml are also used as input file. File Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.<build-type>+<target-type>.yml Build description of a single *.cproject.yml input file; contains all information for the build step for a specific context including references to the content used from software packs. *.cbuild-pack.yml Software packs recorded for the all input files ( *.csolution.yml , cproject.yml , and .clayer.yml ); used as input file to ensure reproducible builds that use the same software packs and pack versions. *.cbuild-set.yml Context selection for the build process, enabled with option --context-set: . Directory Structure As csolution based projects should be portable across different host computers, relative file references are used within the directory structure. All file references use relative paths to the base directory of the related *.yml file. Files that are within the file structure of the csolution base directory are also referenced using relative paths, i.e. ../layers/layer1/source-file1.c . Files that are located in the CMSIS-Pack root directory are prefixed with ${CMSIS_PACK_ROOT} . Note All file references to user source code should be relative paths. The prefixes ${CMSIS_PACK_ROOT} and ${CMSIS_COMPILER_ROOT} are used to refer to base directories of files that relate to software packs and compiler specific files. These base directories can also be on different filesystem drives. Files outside of the directory structure of csolution based application use absolute paths. If absolute paths are used, a warning is issued in the *.cbuild-idx.yml file. A typical directory structure of a csolution based application that uses common layers source files is shown below. \ud83d\udce6 # csolution base directory \u2523 myapp.csolution.yml \u2523 myapp.cbuild-idx.yml \u2523 myapp.cbuild-pack.yml \u2523 myapp.cbuild-set.yml \u2523 \ud83d\udcc2 project1 \u2503 \u2523 mypro1.cproject.yml \u2503 \u2523 mypro1.cbuild.yml # file references are relative to directory project1 \u2523 \ud83d\udcc2 project2 \u2503 \u2523 mypro2.cproject.yml \u2503 \u2523 mypro2.cbuild.yml # file references are relative to directory project2 \u2523 \ud83d\udcc2 layer \u2503 \u2523 mylayer.clayer.yml Pack locking An application contains a set of packs coming from different places, e.g. from the csolution directly, or indirectly from cprojects or clayers . In order to have consistent pack usage in the application, as well as allowing projects to evolve and add new target-types or build-types but still remain on the same shared pack versions, the cbuild-pack.yml is introduced. It works in the following way. An entire application has a set of pack requirements . These requirements can come from many different locations or contexts, and may be: specified exactly, e.g. ARM::CMSIS@5.9.0 specified with range, e.g. ARM::CMSIS@>=5.8.0 specified without version, e.g. ARM::CMSIS specified with wildcards on the pack name, e.g. ARM::CMSI* specified without pack name, e.g. ARM All these pack requirements are resolved into exact versions in the cbuild-pack.yml file as a list of items on the following format: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by-pack: - ARM - ARM::CMSI* - ARM::CMSIS - ARM::CMSIS@>=5.8.0 - ARM::CMSIS@5.9.0 If a context is added or changed, the selected-by is used to ensure that the pack requirements are resolved to a consistent pack version, reducing surprising versions being selected in the entire application. If a pack requirement is no longer present in the application, then the cbuild-pack.yml file will be cleaned from the relevant entries during the cbuild-pack.yml generation step. The location of the cbuild-pack.yml file follows the csolution.yml file. csolution convert - Uses and updates cbuild-pack.yml csolution list ... - Uses cbuild-pack.yml csolution run - Uses cbuild-pack.yml csolution update-rte - Uses and updates cbuild-pack.yml graph TD; csolution.yml cbuild-pack.yml cproject.yml subgraph Loading res1[\"<center><u>Resolving step 1 (PopulateContexts)</u></center><ul><li>Reading the files</li><li>Adds cbuild-pack.yml\\npack requirements to the solution</li></ul>\"] res2[\"<center><u>Resolving step 2 (AddPackRequirements)</u></center><ul><li>Pack version ranges are matched to fully qualified versions using cbuild-pack.yml</li><li>Pack wildcards are matched to fully qualified versions using cbuild-pack.yml</li><li>Pack wildcards are kept for further expansion in the model</li><li>Local packs are left as-is</li></ul>\"] style res1 text-align:left style res2 text-align:left end action[\"<u>Some action</u> <br> e.g. convert, list, run, update-rte, ...\"] subgraph Saving res3[\"<center><u>Resolving step 3 (GenerateCbuildPack)</u></center><ul><li>Rebuild list of packs required by all contexts</li><li>Ensure that original 'pack expression' are kept in cbuild-pack.yml</li></ul>\"] write[\"<center><u>Potentially write cbuild-pack.yml</u></center><ul><li>Only done for the [convert, update-rte] commands</li></ul>\"] style res3 text-align:left end csolution.yml --> res1 cbuild-pack.yml --> res1 cproject.yml --> res1 res1 --> res2 res2 --> action action --> res3 res3 --> write This means that the cbuild-pack.yml information is used to load the appropriate fully qualified pack versions, matching previously used version ranges and pack wildcards. Subsequent runs, and newly added contexts, can therefore use the least surprising versions. File Structure of *.cbuild-idx.yml build-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. description: Brief description text copied from the *.csolution.yml input file used to generate this application. cdefault: Relative path and name of the *.cdefault.yml input file used to generate this application. csolution: Relative path and name of the *.csolution.yml input file used to generate this application. configurations: For reference applications with undefined layers: list of potential project configurations for a reference application with undefined layers cprojects: List of *.cproject.yml and *.clayer.yml input files used to generate this application. cbuilds: List of *.cbuild.yml output files that are generated for this application. select-compiler: For projects with unspecified compiler: list of available compilers for selection Example: build-idx: generated-by: csolution version 2.3.0 description: USB application examples sharing board layers. cdefault: cdefault.yml csolution: USB.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml cprojects: - cproject: Device/HID/HID.cproject.yml clayers: - clayer: $Board-Layer$ - cproject: Device/MassStorage/MassStorage.cproject.yml clayers: - clayer: $Board-Layer$ cbuilds: - cbuild: Device/HID/HID.Debug+B-U585I-IOT02A.cbuild.yml project: HID configuration: .Debug+B-U585I-IOT02A - cbuild: Device/MassStorage/MassStorage.Release+B-U585I-IOT02A.cbuild.yml project: MassStorage configuration: .Release+B-U585I-IOT02A errors: true # indicates error packs-missing: # lists missing packs - pack: ARM::CMSIS-RTX # with unspecified version - pack: ARM::CMSIS@6.0.0 # with specified version File Structure of *.cbuild.yml The cbuild.yml file is structured into several sections. The top-level structure is outlined below. build: Content generated-by: Reference to csolution tool along with version information used to generate this application. context: Project context of this build description. compiler: Compiler toolchain used for code generation. board: Board name used for this context. board-pack: BSP that is defining the Board name used for this context. device: Device name with processor core selection used in this project context. device-pack: DFP that is defining the Device name with processor core selection used in this project context. processor: List of processor attributes used in this project context. packs: List of software packs along with path information used to generate this project context. optimize: Generic optimize level for code generation. debug: Global control the generation of debug information. warnings: Global control warning level for compiler diagnostics. misc: Global control of miscellaneous literal tool-specific controls. define: List of global define symbol settings. add-path: List of global include path settings. output-type: Select the output type (exe or lib) for this project context. output-dirs: Specifies the directories used to generate the output files. linker: Specifies the linker script processing used to generate the output files. components: List of software components used. apis: List of API interfaces used. groups: List of source file groups along with source files. constructed-files: List of files that are generated by RTE management of csolution tool. licenses: List of licenses used by the various software components of this project context. Example: build: context: HelloWorld_cm0plus.Debug+FRDM-K32L3A6 compiler: AC6 device: K32L3A60VPJ1A:cm0plus processor: fpu: off endian: little trustzone: non-secure packs: - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 - pack: NXP::K32L3A60_DFP@15.0.0 path: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 optimize: none debug: on misc: C: - -std=c99 - -fno-builtin CPP: - -fno-builtin Link: - --diag_suppress 6314 - --entry=Reset_Handler define: - CPU_K32L3A60VPJ1A_cm0plus - MCMGR_HANDLE_EXCEPTIONS=1 : - _RTE_ add-path: - ../middleware/multicore/mcmgr/src - RTE/Board_Support/K32L3A60VPJ1A_cm0plus - RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6 - ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0/CMSIS/Core/Include - ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 : output-type: exe output-dirs: gendir: generated intdir: ../tmp/HelloWorld_cm0plus/FRDM-K32L3A6/Debug outdir: ../out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug rtedir: RTE components: - component: ARM::CMSIS:CORE@5.6.0 condition: ARMv6_7_8-M Device from-pack: ARM::CMSIS@5.9.0 selected-by: ARM::CMSIS:CORE - component: NXP::Device:CMSIS:K32L3A60_system@1.0.0 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:CMSIS:K32L3A60_system files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/system_K32L3A60_cm0plus.c category: sourceC - component: NXP::Device:SDK Drivers:clock@2.2.1 condition: device.K32L3A60_AND_driver.common from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:clock files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_clock.c category: sourceC - component: NXP::Device:SDK Drivers:common@2.3.2 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS_AND_driver.clock from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:common files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common.c category: sourceC - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common_arm.c category: sourceC : groups: - group: Application files: - file: ./hello_world_core1.c category: sourceC - file: ./RTE/Device/K32L3A60VPJ1A_cm0plus/K32L3A60xxx_cm0plus_flash.scf category: linkerScript - group: Middleware files: - file: ../middleware/multicore/mcmgr/src/mcmgr.c category: sourceC : constructed-files: - file: RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6/RTE_Components.h category: header File Structure of *.cbuild-pack.yml The cbuild-pack.yml file is structured into several sections. The top-level structure is outlined below. cbuild-pack: Content resolved-packs: List of packs used to create the project contexts. resolved-packs: Content - resolved-pack: pack name used. selected-by-pack: List of components included from the pack. Example: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by: - ARM::CMSIS - resolved-pack: ARM::V2M_MPS3_SSE_300_BSP@1.2.0 selected-by: - ARM::V2M_MPS3_SSE_300_BSP@1.2.0 - resolved-pack: Keil::ARM_Compiler@1.7.2 selected-by: - Keil::ARM_Compiler File Structure of *.cbuild-set.yml The cbuild-set.yml file is structured into several sections. The top-level structure is outlined below. cbuild-set: Content generated-by: Reference to tool along with version information that generated this file. contexts: List of context names for the context-set: option. Example: cbuild-set: generated-by: csolution version 2.2.0 contexts: - context: CM33_s.Release+AVH - context: CM33_ns.Debug+AVH cbuild-specific Nodes configurations: The configurations: node lists possible configurations for reference applications that have undefined variable settings. configurations: Content - target-type: Name of target-type for which configurations are listed. target-configurations: List of possible configurations for the target-type. - configuration: Possible configuration for the reference application. - variables: List of variable names with configuration information. <layer-name>: Layer name with value that is the path to the clayer.yml file. description: Brief description text taken from *.clayer.yml . settings: Usage instructions for this layer. - set: Value of set and info taken from connect: in *.clayer.yml . path: Path to the directory that contains the layer (from *.PDSC file). file: Name of the *.clayer.yml file (optional with relative path to the directory specified with path) (from *.PDSC file). copy-to: Proposed directory for the layer in the csolution project (from *.PDSC file). Example: configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml description: \"Configuration including FXLS8962 sensor\" - target-type: MyBoard - configuration: - variables: - Board-Layer: ./layer/board/frdmk22f/frdmk22f.clayer.yml description: \"Configuration: Ethernet, UART, and WiFi\" settings: - set: set1.select1 (connect A - set 1 select 1) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f - Shield-Layer: ./layer/shield/agmp03/agmp03.clayer.yml description: \"Shield with FXLS8962 and FXAS21002\" settings: - set: Bus.SPI (FXLS8962 SPI Bus - Jumper configuration: I2C/SPI=SPI) - set: Bus.SPI (FXAS21002 SPI Bus - Jumper configuration: I2C/SPI=SPI) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f cprojects: The cprojects: node lists all *.cproject.yml input files along with *.clayer.yml files that are used to compose the application. cprojects: Content - cproject: Relative path and name of a *.cproject.yml input file. clayers: List of *.clayer.yml input files used by this *.cproject.yml file. Example: cprojects: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml clayers: - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/FreeRTOS+TCP/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/WiFi/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/VSocket/Socket.clayer.yml : cbuilds: The cbuilds: node lists all project context configurations that are generated with this build. cbuilds: Content - cbuild: Build description file of a single context for a *.cproject.yml input file; project: Project name configuration: Context configuration for this build description file errors: Error indication packs-missing: List of missing packs messages: List of errors: , warnings: , or info: messages Example: cbuilds: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml project: Demo configuration: .Debug+AVH errors: true messages: errors: - no compatible software layer found. Review required connections of the project info: - test.cbuild-set.yml - file is already up-to-date select-compiler: If no compiler is specified in the csolution project , the cbuild setup command lists the available compilers based on the compiler registration and select-compiler: node in the file *.csolution.yml or cdefault.yml . select-compiler: Content - compiler: Name (optionally with version) of the compiler toolchain; copied from the select-compiler: node in the csolution project . packs: The packs: node is the start of a pack list that is used for the project context. packs: Content - pack: Explicit pack specification with exact version information used. path: Path name that stores the software pack (see note). Note Packs that are located in the CMSIS-Pack root directory are prefixed with %CMSIS_PACK_ROOT% . Example: packs: - pack: ARM::CMSIS-FreeRTOS@10.4.6 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS-FreeRTOS/10.4.6 - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 : - pack: MDK-Packs::IoT_Socket@1.3.1 path: ../IoT_Socket generators: The generators: node contains information for calling a generator. generators: Content - generator: Section for a specific generator. path: Path name for storing the files generated. gdpsc: File name of the *.GDPSC file that stores the information in path: . command: Section for invoking the generator on different Host operating systems. Example: generators: - generator: STM32CubeMX path: RTE/Device gpdsc: RTE/Device/STM32L475VGTx/FrameworkCubeMX.gpdsc command: win: file: ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1/MDK/CubeMX/STM32CubeMxLauncher.exe arguments: - STM32L475VGTx - ../../Release+STM32L4.cprj - ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1 Source File Management Keyword Description groups: Start of a list that adds source groups and files. components: Start of a list that adds software components. linker: linker: Content - regions: Path and file name of regions_<device_or_board>.h , used to generate a Linker Script via pre-processor. - script: Path and file name of the Linker Script template that is pre-processed. - define: Define symbol settings for the linker script file preprocessor. groups: groups: Content - group: Name of the group. optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. groups: Start a nested list of groups. files: List of files that belong to a group files: of a group files: Content - file: Name of the file. category: File category according Open-CMSIS-Pack specification optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. components: components: Content - component: Name of the software component. condition: Reference to the condition ID of the software pack that triggered inclusion of this component. from-pack: Pack that defines this component. selected-by: The original component name used in cproject/clayer.YML . optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. instances: Number of component instances configured. generator: Generator information for components that are configurable via a generator. implements: Refers to the API that the component is based on. files: List of files that belong to this component. apis: apis: Content - api: Name of the API. condition: Reference to the condition ID of the software pack that triggered inclusion of this API. from-pack: Pack that defines this API. implemented-by: Refers to the software componeent that implements the API. files: List of files that belong to this API. generator: generator: Content - id: Generator identifier used for this component path: File name and path to the *.cgen.yml file that is generated. files: of a component files: Content - file: Name and path to the file. category: File category according Open-CMSIS-Pack specification attr: File category according Open-CMSIS-Pack specification; api refers to header files that define the api of a component. condition: Reference to the condition ID of the software pack that triggered inclusion of this file. select: Selection text for user code template files and api header files. version: For files that belong to components the version specified in the PDSC file. base: Unmodified configuration file (base file from the software pack ) that is currently in use. update: New configuration file from an updated software pack . status: Action for configuration file update: suggested, recommended, required. constructed-files: A list of files that are generated by the RTE management of the csolution tool. constructed-files: Content - file: Name and path to the file. category: File category according Open-CMSIS-Pack specification licenses: The *.cbuild.yml files contains license information about each software component that is included from software packs. Each different license that is used in an a project context has a sepearate section. licenses: Content - license: License identifier or short description. lisense-agreement: File category according Open-CMSIS-Pack specification packs: List of software packs used to generate this project context. components: List of software components used to generate this project context. Example: licenses: - license: <proprietary> END USER LICENSE AGREEMENT FOR ARM SOFTWARE DEVELOPMENT TOOLS license-agreement: ${CMSIS_PACK_ROOT}/Keil/MDK-Middleware/8.0.0/license_terms/license_agreement.txt packs: - pack: Keil::MDK-Middleware@8.0.0 components: - component: Keil::USB&MDK:CORE@8.0.0 - component: Keil::USB&MDK:Device:HID@8.0.0 - component: Keil::USB&MDK:Device@8.0.0 - license: Apache-2.0 packs: - pack: ARM::CMSIS-Compiler@2.1.0 - pack: ARM::CMSIS-Driver_STM32@1.0.0 - pack: ARM::CMSIS-RTX@5.9.0 : components: - component: CMSIS Driver:GPIO(API) - component: CMSIS Driver:I2C(API) - component: CMSIS Driver:SPI(API) : - component: ARM::CMSIS-Compiler:CORE@1.1.0 - component: ARM::CMSIS-Compiler:STDERR:Custom@1.1.0 - component: ARM::CMSIS-Compiler:STDIN:Custom@1.1.0 : Generator Information Files The csolution run command generates the following build information files in the intdir: of the related context . These files are the input to a generator and provide the information about the csolution project to the generator. The files are generated in the tmp directory of the project and contain absolute paths. File Description *.cbuild-gen-idx.yml Index file of all *.cbuild-gen.yml build descriptions; contains also overall information for the application. *.cbuild-gen.yml Build description of a single *.cproject.yml input file. The format is identical with the *.cbuild.yml file. File Structure of *.cbuild-gen-idx.yml build-gen-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. generators: List of generators that are called with the run command generators: Content - id: generator identifier specified with the option --generator in the csolution run command. output: Specifies the directory for generated files board: Board name used for the generator device: Device name used for the generator project-type: Describes the project type \"single-core\", \"multi-core\", \"trustzone\" cbuild-gens: List of *.cbuild-gen.yml files with options that are generated for the generator run cbuild-gens: Content - cbuild-gen: Build information file with name <context>.cbuild-gen.yml ; structure identical with *.cbuild.yml . project: Project name (used as name for *.cgen.yml when name: is not specified) configuration: Specifies .build-type+target-type of this context. name: Explicit name for the *.cgen.yml generator import file specified by generator options . map: Mapping to a generator specific run-time context name specified by generator options . Example: build-gen-idx: generated-by: csolution version 2.3.0 generators: - id: CubeMX output: C:/w/csolution-examples/CubeMX/STM32CubeMX/MyBoard # output directory device: STM32U585AIIx board: B-U585I-IOT02A project-type: single-core cbuild-gens: - cbuild-gen: C:/w/csolution-examples/CubeMX/tmp/CubeMX/MyBoard/Debug/CubeMX.Debug+MyBoard.cbuild-gen.yml project: CubeMX # user selected name of the project configuration: .Debug+MyBoard name: BoardLayer # create BoardLayer.cgen.yml in output directory (new in CMSIS-Toolbox 2.4.0) map: Boot # map to STM32CubeMX run-time context (new in CMSIS-Toolbox 2.4.0) Generator Import File The *.cgen.yml file is lists the generated csolution project part and starts with the node generator-import: . It defines similar to a Software Layer additional parameters, files, and components that are included in the project. File Structure of *.cgen.yml generator-import: Content generated-by: Tool name that generated this file for-device: Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Board information, used for consistency check (board selection is in *.csolution.yml ). packs: Defines packs that are required for this layer. define: Define symbol settings for code generation. undefine: Remove define symbol settings for code generation. add-path: Additional include file paths. del-path: Remove specific include file paths. groups: List of source file groups along with source files. components: List of software components used.","title":"Build Information Files"},{"location":"YML-CBuild-Format/#build-information-files","text":"The following chapter explains the YAML cbuild format that describes how to build a complete application.","title":"Build Information Files"},{"location":"YML-CBuild-Format/#cbuild-output-files","text":"The following output files are generated by the csolution tool. Depending on options, the files *.cbuild-pack.yml and *.cbuild-set.yml are also used as input file. File Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.<build-type>+<target-type>.yml Build description of a single *.cproject.yml input file; contains all information for the build step for a specific context including references to the content used from software packs. *.cbuild-pack.yml Software packs recorded for the all input files ( *.csolution.yml , cproject.yml , and .clayer.yml ); used as input file to ensure reproducible builds that use the same software packs and pack versions. *.cbuild-set.yml Context selection for the build process, enabled with option --context-set: .","title":"cbuild Output Files"},{"location":"YML-CBuild-Format/#directory-structure","text":"As csolution based projects should be portable across different host computers, relative file references are used within the directory structure. All file references use relative paths to the base directory of the related *.yml file. Files that are within the file structure of the csolution base directory are also referenced using relative paths, i.e. ../layers/layer1/source-file1.c . Files that are located in the CMSIS-Pack root directory are prefixed with ${CMSIS_PACK_ROOT} . Note All file references to user source code should be relative paths. The prefixes ${CMSIS_PACK_ROOT} and ${CMSIS_COMPILER_ROOT} are used to refer to base directories of files that relate to software packs and compiler specific files. These base directories can also be on different filesystem drives. Files outside of the directory structure of csolution based application use absolute paths. If absolute paths are used, a warning is issued in the *.cbuild-idx.yml file. A typical directory structure of a csolution based application that uses common layers source files is shown below. \ud83d\udce6 # csolution base directory \u2523 myapp.csolution.yml \u2523 myapp.cbuild-idx.yml \u2523 myapp.cbuild-pack.yml \u2523 myapp.cbuild-set.yml \u2523 \ud83d\udcc2 project1 \u2503 \u2523 mypro1.cproject.yml \u2503 \u2523 mypro1.cbuild.yml # file references are relative to directory project1 \u2523 \ud83d\udcc2 project2 \u2503 \u2523 mypro2.cproject.yml \u2503 \u2523 mypro2.cbuild.yml # file references are relative to directory project2 \u2523 \ud83d\udcc2 layer \u2503 \u2523 mylayer.clayer.yml","title":"Directory Structure"},{"location":"YML-CBuild-Format/#pack-locking","text":"An application contains a set of packs coming from different places, e.g. from the csolution directly, or indirectly from cprojects or clayers . In order to have consistent pack usage in the application, as well as allowing projects to evolve and add new target-types or build-types but still remain on the same shared pack versions, the cbuild-pack.yml is introduced. It works in the following way. An entire application has a set of pack requirements . These requirements can come from many different locations or contexts, and may be: specified exactly, e.g. ARM::CMSIS@5.9.0 specified with range, e.g. ARM::CMSIS@>=5.8.0 specified without version, e.g. ARM::CMSIS specified with wildcards on the pack name, e.g. ARM::CMSI* specified without pack name, e.g. ARM All these pack requirements are resolved into exact versions in the cbuild-pack.yml file as a list of items on the following format: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by-pack: - ARM - ARM::CMSI* - ARM::CMSIS - ARM::CMSIS@>=5.8.0 - ARM::CMSIS@5.9.0 If a context is added or changed, the selected-by is used to ensure that the pack requirements are resolved to a consistent pack version, reducing surprising versions being selected in the entire application. If a pack requirement is no longer present in the application, then the cbuild-pack.yml file will be cleaned from the relevant entries during the cbuild-pack.yml generation step. The location of the cbuild-pack.yml file follows the csolution.yml file. csolution convert - Uses and updates cbuild-pack.yml csolution list ... - Uses cbuild-pack.yml csolution run - Uses cbuild-pack.yml csolution update-rte - Uses and updates cbuild-pack.yml graph TD; csolution.yml cbuild-pack.yml cproject.yml subgraph Loading res1[\"<center><u>Resolving step 1 (PopulateContexts)</u></center><ul><li>Reading the files</li><li>Adds cbuild-pack.yml\\npack requirements to the solution</li></ul>\"] res2[\"<center><u>Resolving step 2 (AddPackRequirements)</u></center><ul><li>Pack version ranges are matched to fully qualified versions using cbuild-pack.yml</li><li>Pack wildcards are matched to fully qualified versions using cbuild-pack.yml</li><li>Pack wildcards are kept for further expansion in the model</li><li>Local packs are left as-is</li></ul>\"] style res1 text-align:left style res2 text-align:left end action[\"<u>Some action</u> <br> e.g. convert, list, run, update-rte, ...\"] subgraph Saving res3[\"<center><u>Resolving step 3 (GenerateCbuildPack)</u></center><ul><li>Rebuild list of packs required by all contexts</li><li>Ensure that original 'pack expression' are kept in cbuild-pack.yml</li></ul>\"] write[\"<center><u>Potentially write cbuild-pack.yml</u></center><ul><li>Only done for the [convert, update-rte] commands</li></ul>\"] style res3 text-align:left end csolution.yml --> res1 cbuild-pack.yml --> res1 cproject.yml --> res1 res1 --> res2 res2 --> action action --> res3 res3 --> write This means that the cbuild-pack.yml information is used to load the appropriate fully qualified pack versions, matching previously used version ranges and pack wildcards. Subsequent runs, and newly added contexts, can therefore use the least surprising versions.","title":"Pack locking"},{"location":"YML-CBuild-Format/#file-structure-of-cbuild-idxyml","text":"build-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. description: Brief description text copied from the *.csolution.yml input file used to generate this application. cdefault: Relative path and name of the *.cdefault.yml input file used to generate this application. csolution: Relative path and name of the *.csolution.yml input file used to generate this application. configurations: For reference applications with undefined layers: list of potential project configurations for a reference application with undefined layers cprojects: List of *.cproject.yml and *.clayer.yml input files used to generate this application. cbuilds: List of *.cbuild.yml output files that are generated for this application. select-compiler: For projects with unspecified compiler: list of available compilers for selection Example: build-idx: generated-by: csolution version 2.3.0 description: USB application examples sharing board layers. cdefault: cdefault.yml csolution: USB.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml cprojects: - cproject: Device/HID/HID.cproject.yml clayers: - clayer: $Board-Layer$ - cproject: Device/MassStorage/MassStorage.cproject.yml clayers: - clayer: $Board-Layer$ cbuilds: - cbuild: Device/HID/HID.Debug+B-U585I-IOT02A.cbuild.yml project: HID configuration: .Debug+B-U585I-IOT02A - cbuild: Device/MassStorage/MassStorage.Release+B-U585I-IOT02A.cbuild.yml project: MassStorage configuration: .Release+B-U585I-IOT02A errors: true # indicates error packs-missing: # lists missing packs - pack: ARM::CMSIS-RTX # with unspecified version - pack: ARM::CMSIS@6.0.0 # with specified version","title":"File Structure of *.cbuild-idx.yml"},{"location":"YML-CBuild-Format/#file-structure-of-cbuildyml","text":"The cbuild.yml file is structured into several sections. The top-level structure is outlined below. build: Content generated-by: Reference to csolution tool along with version information used to generate this application. context: Project context of this build description. compiler: Compiler toolchain used for code generation. board: Board name used for this context. board-pack: BSP that is defining the Board name used for this context. device: Device name with processor core selection used in this project context. device-pack: DFP that is defining the Device name with processor core selection used in this project context. processor: List of processor attributes used in this project context. packs: List of software packs along with path information used to generate this project context. optimize: Generic optimize level for code generation. debug: Global control the generation of debug information. warnings: Global control warning level for compiler diagnostics. misc: Global control of miscellaneous literal tool-specific controls. define: List of global define symbol settings. add-path: List of global include path settings. output-type: Select the output type (exe or lib) for this project context. output-dirs: Specifies the directories used to generate the output files. linker: Specifies the linker script processing used to generate the output files. components: List of software components used. apis: List of API interfaces used. groups: List of source file groups along with source files. constructed-files: List of files that are generated by RTE management of csolution tool. licenses: List of licenses used by the various software components of this project context. Example: build: context: HelloWorld_cm0plus.Debug+FRDM-K32L3A6 compiler: AC6 device: K32L3A60VPJ1A:cm0plus processor: fpu: off endian: little trustzone: non-secure packs: - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 - pack: NXP::K32L3A60_DFP@15.0.0 path: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 optimize: none debug: on misc: C: - -std=c99 - -fno-builtin CPP: - -fno-builtin Link: - --diag_suppress 6314 - --entry=Reset_Handler define: - CPU_K32L3A60VPJ1A_cm0plus - MCMGR_HANDLE_EXCEPTIONS=1 : - _RTE_ add-path: - ../middleware/multicore/mcmgr/src - RTE/Board_Support/K32L3A60VPJ1A_cm0plus - RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6 - ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0/CMSIS/Core/Include - ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 : output-type: exe output-dirs: gendir: generated intdir: ../tmp/HelloWorld_cm0plus/FRDM-K32L3A6/Debug outdir: ../out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug rtedir: RTE components: - component: ARM::CMSIS:CORE@5.6.0 condition: ARMv6_7_8-M Device from-pack: ARM::CMSIS@5.9.0 selected-by: ARM::CMSIS:CORE - component: NXP::Device:CMSIS:K32L3A60_system@1.0.0 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:CMSIS:K32L3A60_system files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/system_K32L3A60_cm0plus.c category: sourceC - component: NXP::Device:SDK Drivers:clock@2.2.1 condition: device.K32L3A60_AND_driver.common from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:clock files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_clock.c category: sourceC - component: NXP::Device:SDK Drivers:common@2.3.2 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS_AND_driver.clock from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:common files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common.c category: sourceC - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common_arm.c category: sourceC : groups: - group: Application files: - file: ./hello_world_core1.c category: sourceC - file: ./RTE/Device/K32L3A60VPJ1A_cm0plus/K32L3A60xxx_cm0plus_flash.scf category: linkerScript - group: Middleware files: - file: ../middleware/multicore/mcmgr/src/mcmgr.c category: sourceC : constructed-files: - file: RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6/RTE_Components.h category: header","title":"File Structure of *.cbuild.yml"},{"location":"YML-CBuild-Format/#file-structure-of-cbuild-packyml","text":"The cbuild-pack.yml file is structured into several sections. The top-level structure is outlined below. cbuild-pack: Content resolved-packs: List of packs used to create the project contexts. resolved-packs: Content - resolved-pack: pack name used. selected-by-pack: List of components included from the pack. Example: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by: - ARM::CMSIS - resolved-pack: ARM::V2M_MPS3_SSE_300_BSP@1.2.0 selected-by: - ARM::V2M_MPS3_SSE_300_BSP@1.2.0 - resolved-pack: Keil::ARM_Compiler@1.7.2 selected-by: - Keil::ARM_Compiler","title":"File Structure of *.cbuild-pack.yml"},{"location":"YML-CBuild-Format/#file-structure-of-cbuild-setyml","text":"The cbuild-set.yml file is structured into several sections. The top-level structure is outlined below. cbuild-set: Content generated-by: Reference to tool along with version information that generated this file. contexts: List of context names for the context-set: option. Example: cbuild-set: generated-by: csolution version 2.2.0 contexts: - context: CM33_s.Release+AVH - context: CM33_ns.Debug+AVH","title":"File Structure of *.cbuild-set.yml"},{"location":"YML-CBuild-Format/#cbuild-specific-nodes","text":"","title":"cbuild-specific Nodes"},{"location":"YML-CBuild-Format/#configurations","text":"The configurations: node lists possible configurations for reference applications that have undefined variable settings. configurations: Content - target-type: Name of target-type for which configurations are listed. target-configurations: List of possible configurations for the target-type. - configuration: Possible configuration for the reference application. - variables: List of variable names with configuration information. <layer-name>: Layer name with value that is the path to the clayer.yml file. description: Brief description text taken from *.clayer.yml . settings: Usage instructions for this layer. - set: Value of set and info taken from connect: in *.clayer.yml . path: Path to the directory that contains the layer (from *.PDSC file). file: Name of the *.clayer.yml file (optional with relative path to the directory specified with path) (from *.PDSC file). copy-to: Proposed directory for the layer in the csolution project (from *.PDSC file). Example: configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml description: \"Configuration including FXLS8962 sensor\" - target-type: MyBoard - configuration: - variables: - Board-Layer: ./layer/board/frdmk22f/frdmk22f.clayer.yml description: \"Configuration: Ethernet, UART, and WiFi\" settings: - set: set1.select1 (connect A - set 1 select 1) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f - Shield-Layer: ./layer/shield/agmp03/agmp03.clayer.yml description: \"Shield with FXLS8962 and FXAS21002\" settings: - set: Bus.SPI (FXLS8962 SPI Bus - Jumper configuration: I2C/SPI=SPI) - set: Bus.SPI (FXAS21002 SPI Bus - Jumper configuration: I2C/SPI=SPI) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f","title":"configurations:"},{"location":"YML-CBuild-Format/#cprojects","text":"The cprojects: node lists all *.cproject.yml input files along with *.clayer.yml files that are used to compose the application. cprojects: Content - cproject: Relative path and name of a *.cproject.yml input file. clayers: List of *.clayer.yml input files used by this *.cproject.yml file. Example: cprojects: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml clayers: - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/FreeRTOS+TCP/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/WiFi/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/VSocket/Socket.clayer.yml :","title":"cprojects:"},{"location":"YML-CBuild-Format/#cbuilds","text":"The cbuilds: node lists all project context configurations that are generated with this build. cbuilds: Content - cbuild: Build description file of a single context for a *.cproject.yml input file; project: Project name configuration: Context configuration for this build description file errors: Error indication packs-missing: List of missing packs messages: List of errors: , warnings: , or info: messages Example: cbuilds: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml project: Demo configuration: .Debug+AVH errors: true messages: errors: - no compatible software layer found. Review required connections of the project info: - test.cbuild-set.yml - file is already up-to-date","title":"cbuilds:"},{"location":"YML-CBuild-Format/#select-compiler","text":"If no compiler is specified in the csolution project , the cbuild setup command lists the available compilers based on the compiler registration and select-compiler: node in the file *.csolution.yml or cdefault.yml . select-compiler: Content - compiler: Name (optionally with version) of the compiler toolchain; copied from the select-compiler: node in the csolution project .","title":"select-compiler:"},{"location":"YML-CBuild-Format/#packs","text":"The packs: node is the start of a pack list that is used for the project context. packs: Content - pack: Explicit pack specification with exact version information used. path: Path name that stores the software pack (see note). Note Packs that are located in the CMSIS-Pack root directory are prefixed with %CMSIS_PACK_ROOT% . Example: packs: - pack: ARM::CMSIS-FreeRTOS@10.4.6 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS-FreeRTOS/10.4.6 - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 : - pack: MDK-Packs::IoT_Socket@1.3.1 path: ../IoT_Socket","title":"packs:"},{"location":"YML-CBuild-Format/#generators","text":"The generators: node contains information for calling a generator. generators: Content - generator: Section for a specific generator. path: Path name for storing the files generated. gdpsc: File name of the *.GDPSC file that stores the information in path: . command: Section for invoking the generator on different Host operating systems. Example: generators: - generator: STM32CubeMX path: RTE/Device gpdsc: RTE/Device/STM32L475VGTx/FrameworkCubeMX.gpdsc command: win: file: ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1/MDK/CubeMX/STM32CubeMxLauncher.exe arguments: - STM32L475VGTx - ../../Release+STM32L4.cprj - ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1","title":"generators:"},{"location":"YML-CBuild-Format/#source-file-management","text":"Keyword Description groups: Start of a list that adds source groups and files. components: Start of a list that adds software components.","title":"Source File Management"},{"location":"YML-CBuild-Format/#linker","text":"linker: Content - regions: Path and file name of regions_<device_or_board>.h , used to generate a Linker Script via pre-processor. - script: Path and file name of the Linker Script template that is pre-processed. - define: Define symbol settings for the linker script file preprocessor.","title":"linker:"},{"location":"YML-CBuild-Format/#groups","text":"groups: Content - group: Name of the group. optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. groups: Start a nested list of groups. files: List of files that belong to a group","title":"groups:"},{"location":"YML-CBuild-Format/#files-of-a-group","text":"files: Content - file: Name of the file. category: File category according Open-CMSIS-Pack specification optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls.","title":"files: of a group"},{"location":"YML-CBuild-Format/#components","text":"components: Content - component: Name of the software component. condition: Reference to the condition ID of the software pack that triggered inclusion of this component. from-pack: Pack that defines this component. selected-by: The original component name used in cproject/clayer.YML . optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. instances: Number of component instances configured. generator: Generator information for components that are configurable via a generator. implements: Refers to the API that the component is based on. files: List of files that belong to this component.","title":"components:"},{"location":"YML-CBuild-Format/#apis","text":"apis: Content - api: Name of the API. condition: Reference to the condition ID of the software pack that triggered inclusion of this API. from-pack: Pack that defines this API. implemented-by: Refers to the software componeent that implements the API. files: List of files that belong to this API.","title":"apis:"},{"location":"YML-CBuild-Format/#generator","text":"generator: Content - id: Generator identifier used for this component path: File name and path to the *.cgen.yml file that is generated.","title":"generator:"},{"location":"YML-CBuild-Format/#files-of-a-component","text":"files: Content - file: Name and path to the file. category: File category according Open-CMSIS-Pack specification attr: File category according Open-CMSIS-Pack specification; api refers to header files that define the api of a component. condition: Reference to the condition ID of the software pack that triggered inclusion of this file. select: Selection text for user code template files and api header files. version: For files that belong to components the version specified in the PDSC file. base: Unmodified configuration file (base file from the software pack ) that is currently in use. update: New configuration file from an updated software pack . status: Action for configuration file update: suggested, recommended, required.","title":"files: of a component"},{"location":"YML-CBuild-Format/#constructed-files","text":"A list of files that are generated by the RTE management of the csolution tool. constructed-files: Content - file: Name and path to the file. category: File category according Open-CMSIS-Pack specification","title":"constructed-files:"},{"location":"YML-CBuild-Format/#licenses","text":"The *.cbuild.yml files contains license information about each software component that is included from software packs. Each different license that is used in an a project context has a sepearate section. licenses: Content - license: License identifier or short description. lisense-agreement: File category according Open-CMSIS-Pack specification packs: List of software packs used to generate this project context. components: List of software components used to generate this project context. Example: licenses: - license: <proprietary> END USER LICENSE AGREEMENT FOR ARM SOFTWARE DEVELOPMENT TOOLS license-agreement: ${CMSIS_PACK_ROOT}/Keil/MDK-Middleware/8.0.0/license_terms/license_agreement.txt packs: - pack: Keil::MDK-Middleware@8.0.0 components: - component: Keil::USB&MDK:CORE@8.0.0 - component: Keil::USB&MDK:Device:HID@8.0.0 - component: Keil::USB&MDK:Device@8.0.0 - license: Apache-2.0 packs: - pack: ARM::CMSIS-Compiler@2.1.0 - pack: ARM::CMSIS-Driver_STM32@1.0.0 - pack: ARM::CMSIS-RTX@5.9.0 : components: - component: CMSIS Driver:GPIO(API) - component: CMSIS Driver:I2C(API) - component: CMSIS Driver:SPI(API) : - component: ARM::CMSIS-Compiler:CORE@1.1.0 - component: ARM::CMSIS-Compiler:STDERR:Custom@1.1.0 - component: ARM::CMSIS-Compiler:STDIN:Custom@1.1.0 :","title":"licenses:"},{"location":"YML-CBuild-Format/#generator-information-files","text":"The csolution run command generates the following build information files in the intdir: of the related context . These files are the input to a generator and provide the information about the csolution project to the generator. The files are generated in the tmp directory of the project and contain absolute paths. File Description *.cbuild-gen-idx.yml Index file of all *.cbuild-gen.yml build descriptions; contains also overall information for the application. *.cbuild-gen.yml Build description of a single *.cproject.yml input file. The format is identical with the *.cbuild.yml file.","title":"Generator Information Files"},{"location":"YML-CBuild-Format/#file-structure-of-cbuild-gen-idxyml","text":"build-gen-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. generators: List of generators that are called with the run command generators: Content - id: generator identifier specified with the option --generator in the csolution run command. output: Specifies the directory for generated files board: Board name used for the generator device: Device name used for the generator project-type: Describes the project type \"single-core\", \"multi-core\", \"trustzone\" cbuild-gens: List of *.cbuild-gen.yml files with options that are generated for the generator run cbuild-gens: Content - cbuild-gen: Build information file with name <context>.cbuild-gen.yml ; structure identical with *.cbuild.yml . project: Project name (used as name for *.cgen.yml when name: is not specified) configuration: Specifies .build-type+target-type of this context. name: Explicit name for the *.cgen.yml generator import file specified by generator options . map: Mapping to a generator specific run-time context name specified by generator options . Example: build-gen-idx: generated-by: csolution version 2.3.0 generators: - id: CubeMX output: C:/w/csolution-examples/CubeMX/STM32CubeMX/MyBoard # output directory device: STM32U585AIIx board: B-U585I-IOT02A project-type: single-core cbuild-gens: - cbuild-gen: C:/w/csolution-examples/CubeMX/tmp/CubeMX/MyBoard/Debug/CubeMX.Debug+MyBoard.cbuild-gen.yml project: CubeMX # user selected name of the project configuration: .Debug+MyBoard name: BoardLayer # create BoardLayer.cgen.yml in output directory (new in CMSIS-Toolbox 2.4.0) map: Boot # map to STM32CubeMX run-time context (new in CMSIS-Toolbox 2.4.0)","title":"File Structure of *.cbuild-gen-idx.yml"},{"location":"YML-CBuild-Format/#generator-import-file","text":"The *.cgen.yml file is lists the generated csolution project part and starts with the node generator-import: . It defines similar to a Software Layer additional parameters, files, and components that are included in the project.","title":"Generator Import File"},{"location":"YML-CBuild-Format/#file-structure-of-cgenyml","text":"generator-import: Content generated-by: Tool name that generated this file for-device: Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Board information, used for consistency check (board selection is in *.csolution.yml ). packs: Defines packs that are required for this layer. define: Define symbol settings for code generation. undefine: Remove define symbol settings for code generation. add-path: Additional include file paths. del-path: Remove specific include file paths. groups: List of source file groups along with source files. components: List of software components used.","title":"File Structure of *.cgen.yml"},{"location":"YML-Input-Format%20-%20Preinclude/","text":"CMSIS Solution Project File Format The following chapter explains the CMSIS Solution Project File Format (short form csolution project files ), the YAML files that that describes the software of an embedded application. Name Conventions Filename Extensions The csolution Project Manager recognizes the categories of files based on the filename extension in the YAML input files as shown in the table below. File Extension Category Description .c , .C sourceC C source file .cpp , .c++ , .C++ , .cxx , .cc , .CC sourceCpp C++ source file .h , .hpp header Header file .asm , .s , .S sourceAsm Assembly source file .ld , .scf , .sct , .icf linkerScript Linker Script file .a , .lib library Library file .o object Object file .txt , .md , .pdf , .htm , .html doc Documentation .scvd other Software Component View Description for CMSIS-View pack: Name Conventions The csolution Project Manager uses the following syntax to specify the pack: names in the *.yml files. vendor [:: pack-name [@[~ | >=] version] ] Element Description vendor Required Vendor name of the software pack. pack-name Optional Name of the software pack; wildcards (*, ?) can be used. version Optional Version number of the software pack, with @1.2.3 that must exactly match, @~1.2 / @~1 that matches with semantic versioning, or @>=1.2.3 that allows any version higher or equal. Note When no version is specified, the csolution Project Manager only loads the latests version of a software pack. This also applies when wildcards are used in the pack-name . Examples: - pack: ARM::CMSIS@5.5.0 # 'CMSIS' Pack (with version 5.5.0) - pack: Keil::MDK-Middleware@>=7.13.0 # 'MDK-Middleware' Software Pack from vendor Keil (with version 7.13.0 or higher, latest available to the tool) - pack: Keil::TFM # 'TFM' Software Pack from vendor Keil (with latest version available to the tool) - pack: AWS # All latest versions of Software Packs from vendor 'AWS' - pack: Keil::STM* # All latest versions of Software Packs that start with 'STM' from vendor 'Keil' component: Name Conventions The csolution Project Manager uses the following syntax to specify the component: names in the *.yml files. [Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[~ | >=]Cversion] Components are defined using the Open-CMSIS-Pack - <component> element . Several parts of a component are optional. For example it is possible to just define a component using Cclass and Cgroup name. All elements of a component name are summarized in the following table. Element Description Cvendor Optional Name of the component vendor as defined in <components> element or by the package vendor of the software pack. Cclass Required Component class name as defined in <components> element of the software pack. Cbundle Optional Bundle name of the component class as defined in <bundle> element of the software pack. Cgroup Required Component group name as defined in <components> element of the software pack. Csub Optional Component sub-group name as defined in <components> element of the software pack. Cvariant Optional Component sub-group name as defined in <components> element of the software pack. Cversion Optional Version number of the component, with @1.2.3 that must exactly match, @~1.2 / @~1 that matches with semantic versioning, or @>=1.2.3 that allows any version higher or equal. Partly defined components A component can be partly defined in csolution project files ( *.cproject.yml , *.clayer.yml , *.genlayer.yml ) by omitting Cvendor , Cvariant , and Cversion , even when this are part of the components element of the software pack. The component select algorithm resolves this to a fully defined component by: when a partly specified component resolves to several possible choices, the tool selects: (a) the default Cvariant of the component as defined in the PDSC file. (b) the component with the higher Cversion value. (c) and error message is issued when two identical components are defined by multiple vendors and Cvendor is not specified. the partly specified component is extended by: version information from the software pack. default variant definition from the software pack. The fully resolved component name is shown in the *.cbuild.yml output file. Multiple component definitions are rejected If a component is added more then once in the csolution project files and an error is issued. An attempt to select multiple variants (using Cvariant ) of a component results in an error . Examples: - component: CMSIS:CORE # CMSIS Core component (vendor selected by `csolution` ARM) - component: ARM::CMSIS:CORE # CMSIS Core component from vendor ARM (any version) - component: ARM::CMSIS:CORE@5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0) - component: ARM::CMSIS:CORE@>=5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0 or higher) - component: Device:Startup # Device Startup component from any vendor - component: CMSIS:RTOS2:Keil RTX5 # CMSIS RTOS2 Keil RTX5 component with default variant (any version) - component: ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3 # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3 - component: Keil::USB&MDK-Pro:CORE&Release@6.15.1 # USB CORE component from bundle MDK-Pro in variant 'Release' and version 6.15.1 device: Name Conventions The device specifies multiple attributes about the target that ranges from the processor architecture to Flash algorithms used for device programming. The following syntax is used to specify a device: value in the *.yml files. [ [ Dvendor:: ] Dname] [:Pname] Element Description Dvendor Optional Name (without enum field) of the device vendor defined in <devices><family> element of the software pack. Dname Optional Device name (Dname attribute) or when used the variant name (Dvariant attribute) as defined in the \\<devices> element. Pname Optional Processor identifier (Pname attribute) as defined in the <devices> element. Note All elements of a device name are optional which allows to supply additional information, such as the :Pname at different stages of the project. However the Dname itself is a mandatory element and must be specified in context of the various project files. Dvendor:: must be used in combination with the Dname . Examples: device: NXP::LPC1768 # The LPC1788 device from NXP device: LPC1788 # The LPC1788 device (vendor is evaluated from DFP) device: LPC55S69JEV98 # Device name (exact name as defined in the DFP) device: LPC55S69JEV98:cm33_core0 # Device name (exact name as defined in the DFP) with Pname specified device: :cm33_core0 # Pname added to a previously defined device name (or a device derived from a board) board: Name Conventions Evaluation Boards define indirectly a device via the related BSP. The following syntax is used to specify a board: value in the *.yml files. [vendor::] board_name [:revision] Element Description vendor Optional Name of the board vendor defined in <boards><board> element of the board support pack (BSP). Bname Required Board name (name attribute) as defined in the \\<board> element of the BSP. revision Optional Board revision (revision attribute) as defined in the \\<board> element of the BSP. Note When a board: is specified, the device: specification can be omitted, however it is possible to overwrite the device setting in the BSP with an explicit device: setting. Examples: board: Keil::MCB54110 # The Keil MCB54110 board (with device NXP::LPC54114J256BD64) board: LPCXpresso55S28 # The LPCXpresso55S28 board board: STMicroelectronics::NUCLEO-L476RG:Rev.C # A board with revision specification context: Name Conventions A context: name combines project-name , built-type , and target-type and is used on various places in the CMSIS-Toolbox. The following syntax is used to specify a context: name. [project-name][.build-type][+target-type] Element Description project-name Optional Project name of a project (base name of the *.cproject.yml file). .build-type Optional The build-type name that is currently processed (specified with - type: name ). +target-type Optional The target-type name that is currently processed (specified with - type: name ). Note The .build-type and +target-type name allows letters (A-Z, a-z), digits (0-9), dash ('-'), and underscore ('_'); the maximum length is 32 characters. When project-name is omitted, the project-name is the base name of the *.cproject.yml file. When .build-type is omitted, it matches with any possible .build-type . When +target-type is omitted, it matches with any possible +target-type . By default, the specified - type: name of build-types: and target-types: nodes in the *.csolution.yml file are directly mapped to the context name. Using the context-map: node it is possible to assign a different .build-type and/or +target-type mapping for a specific project-name . Example: Show the different possible context settings of a *.csolution.yml file. AWS_MQTT_MutualAuth_SW_Framework>csolution list contexts -s Demo.csolution.yml Demo.Debug+AVH Demo.Debug+IP-Stack Demo.Debug+WiFi Demo.Release+AVH Demo.Release+IP-Stack Demo.Release+WiFi The context name is also used in for-context: and not-for-context: nodes that allow to include or exclude items depending on the context . In many cases the project-name can be omitted as the context name is within a specific *.cproject.yml file or applied to a specific *.cproject.yml file. Access Sequences The following access sequences allow to use arguments from the CMSIS Project Manager as arguments of the various *.yml files in the key values for define: , add-path: , misc: , files: , and executes: . The access sequences can refer in a different project and provide therefore a method to describe project dependencies. Access Sequence Description Target Access to target and build related settings $Bname$ Bname of the selected board as specified in the board: node. $Dname$ Dname of the selected device as specified in the device: node. $Pname$ Pname of the selected device as specified in the device: node. $BuildType$ Build-type name of the currently processed project. $TargetType$ Target-type name of the currently processed project. $Compiler$ Compiler name of the compiler used in this project context as specified in the compiler: node. YML Input Access to YML Input Directories and Files $Solution$ Solution name (base name of the *.csolution.yml file). $SolutionDir()$ Path to the directory of the current processed csolution.yml file. $Project$ Project name of the current processed cproject.yml file. $ProjectDir(context)$ Path to the directory of a related cproject.yml file. Output Access to Output Directories and Files $OutDir(context)$ Path to the output directory of a related project that is defined in the *.csolution.yml file. $bin(context)$ Path and filename of the binary output file generated by the related context. $cmse-lib(context)$ Path and filename of the object file with secure gateways of a TrustZone application generated by the related context. $elf(context)$ Path and filename of the ELF/DWARF output file generated by the related context. $hex(context)$ Path and filename of the HEX output file generated by the related context. $lib(context)$ Path and filename of the library file of the related context. For a context the project-name , .build-type , and +target-type are optional; when omitted the current processed context is used. Example: $ProjectDir()$ is the directory of the current processed cproject.yml file. Note The access sequences below are not completed yet, as they require a change to CMSIS-Build. Access Sequence Description $Bpack$ Path to the pack that defines the selected board (BSP). $Dpack$ Path to the pack that defines the selected device (DFP). $Pack(vendor.name)$ Path to a specific pack. Example: $Pack(NXP.K32L3A60_DFP)$ . Example: For the example below we assume the following build-type , target-type , and projects definitions. solution: target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q # specifies board - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device build-types: - type: Debug # build-type: Debug optimize: none debug: on - type: Release # build-type: Release optimize: size projects: - project: ./bootloader/Bootloader.cproject.yml # relative path - project: /MyDevelopmentTree/security/TFM.cproject.yml # absolute path - project: ./application/MQTT_AWS.cproject.yml # relative path The project: /application/MQTT_AWS.cproject.yml can now use Access Sequences to reference files or directories in other projects that belong to a solution. For example, these references are possible in the file MQTT_AWS.cproject.yml . The example below uses the build-type and target-type of the current processed context. In practice this means that the same build-type and target-type is used as for the MQTT_AWS.cproject.yml project. files: - file: $cmse-lib(TFM)$ # use the symbol output file of the TFM Project The example below uses from the TFM project always build-type: Debug and the target-type: Production-HW . files: - file: `$cmse-lib(TFM.Release+Production-HW)$` # use the symbol output file of the TFM Project The example below uses the build-type: Debug . The target-type of the current processed context is used. Note Implementation of executes: is scheduled for implementation in CMSIS-Toolbox 2.4 (Q2'24) executes: - execute: Generate Image run: gen_image %input% -o %output% # DFP the get_image tool input: - $elf(TFM.Debug)$ - $elf(Bootloader.Release)$ output: - $OutDir(TFM.Debug)$ The example below creates a define that uses the device name. groups: - group: \"Main File Group\" define: - $Dname$ # Generate a #define 'device-name' for this file group Variables The variables: node defines are key/value pairs that can be used to refer to *.clayer.yml files. The key is the name of the variable and can be used in the following nodes: layers: , define: , add-path: , misc: , files: , and executes: Using variables that are defined in the *.csolution.yml file, a *.cproject.yml file requires no modifications when new target-types: are introduced. The required layers: could be instead specified in the *.csolution.yml file using a new node variables: . Example: Example.csolution.yml solution: target-types: - type: NXP Board board: IMXRT1050-EVKB variables: - Socket-Layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml - Board-Layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml - type: ST Board board: B-U585I-IOT02A variables: - Socket-Layer: ./Socket/WiFi/Socket.clayer.yml - Board-Layer: ./Board/B-U585I-IOT02A/Board.clayer.yml Example.cproject.yml layers: - layer: $Socket-Layer$ type: Socket - layer: $Board-Layer$ # no `*.clayer.yml` specified. Compatible layers are listed type: Board # layer of type `Board` is expected Order of List Nodes The key / value pairs in a list node can be in any order. The two following list nodes are logically identical. This might be confusing for yml files that are generated by an IDE. build-types: - type: Release # build-type name optimize: size # optimize for size debug: off # generate no debug information for the release build build-types: - debug: off # generate no debug information for the release build optimize: size # optimize for size type: Release # build-type name Project File Structure The table below explains the top-level elements in each of the different *.yml input files that define the overall application. Keyword Description default: Start of cdefault.yml file that is used to setup the compiler along with some compiler-specific controls. solution: Start of *.csolution.yml file that collects related projects along with build-types: and target-types: . project: Start of *.cproject.yml file that defines files, components, and layers which can be independently translated to a binary image or library. layer: Start of *.clayer.yml file that contains pre-configured software components along with source files. cdefault: When cdefault: is specified in the *.csolution.yml file, the csolution Project Manager uses a file with the name cdefault.yml or cdefault.yaml to setup the compiler along with some specific default controls. The search order for this file is: A cdefault.yml or cdefault.yaml file in the same directory as the <solution-name>.csolution.yml file. A cdefault.yml or cdefault.yaml file in the directory specified by the environment variable CMSIS_COMPILER_ROOT . A cdefault.yml or cdefault.yaml file in the directory <cmsis-toolbox-installation-dir>/etc . The default: node is the start of a cdefault.yml or cdefault.yaml file and contains the following. default: Content compiler: Toolchain selection. misc: Literal tool-specific controls. Example: default: compiler: AC6 misc: - ASM: - -masm=auto - Link: - --info sizes --info totals --info unused --info veneers --info summarysizes - --map solution: The solution: node is the start of a *.csolution.yml file that collects related projects as described in the section \"Project setup for related projects\" . solution: Content created-by: Optional Identifies the tool that created this solution. created-for: Optional Specifies the tool for building this solution, i.e. CMSIS-Toolbox@2.2.0 description: Optional Brief description text of this solution. cdefault: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. compiler: Optional Overall toolchain selection for this solution. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. output-dirs: Optional Control the output directories for the build output. generators: Optional Control the directory structure for generator output. packs: Optional Defines local packs and/or scope of packs that are used. target-types: Required List of target-types that define the target system (device or board). build-types: Optional List of build-types (i.e. Release, Debug, Test). projects: Required List of projects that belong to the solution. executes: Optional Additional pre or post build steps using external tools. Example: solution: created-for: cmsis-toolbox@2.0 # minimum CMSIS-Toolbox version required for project build cdefault: # use default setup of toolchain specific controls. compiler: GCC # overwrite compiler definition in 'cdefaults.yml' packs: - pack: ST # add ST packs in 'cdefaults.yml' build-types: # additional build types - type: Test # build-type: Test optimize: none debug: on packs: # with explicit pack specification - pack: ST::TestSW path: ./MyDev/TestSW target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device projects: - project: ./blinky/Bootloader.cproject.yml - project: /security/TFM.cproject.yml - project: /application/MQTT_AWS.cproject.yml project: The project: node is the start of a *.cproject.yml file and can contain the following: project: Content description: Optional Brief description text of this project. output: Optional Configure the generated output files. generators: Optional Control the directory structure for generator output. rte: Optional Control the directory structure for RTE (run-time environment) files. packs: Optional Defines packs that are required for this project. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. linker: Optional Instructions for the linker. debug: Optional Generation of debug information. define: Optional Preprocessor (#define) symbols for code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Device setting (specify processor core). processor: Optional Processor specific settings. groups: Required List of source file groups along with source files. components: Optional List of software components used. layers: Optional List of software layers that belong to the project. connections: Optional List of consumed and provided resources. executes: Optional Additional pre or post build steps using external tools. Example: project: misc: - compiler: AC6 # specify misc controls for Arm Compiler 6 C: [-fshort-enums, -fshort-wchar] # set options for C files add-path: - $OutDir(Secure)$ # add the path to the secure project's output directory components: - component: Startup # Add startup component - component: CMSIS CORE - component: Keil RTX5 Library_NS groups: - group: Non-secure Code # Create group files: - file: main_ns.c # Add files to group - file: $Source(Secure)$interface.h - file: $Output(Secure)$_CMSE_Lib.o layer: The layer: node is the start of a *.clayer.yml file and defines a Software Layer . It can contain the following nodes: layer: Content type: Optional Layer type for combining layers; used to identify compatible layers . description: Optional Brief description text of the layer. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. generators: Optional Control the directory structure for generator output. packs: Optional Defines packs that are required for this layer. for-device: Optional Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Optional Board information, used for consistency check (board selection is in *.csolution.yml ). connections: Optional List of consumed and provided resources. processor: Optional Processor specific settings. linker: Optional Instructions for the linker. groups: Optional List of source file groups along with source files. components: Optional List of software components used. Example: layer: type: Board description: Setup with Ethernet and WiFi interface processor: trustzone: secure # set processor to secure components: - component: Startup - component: CMSIS CORE groups: - group: Secure Code files: - file: main_s.c - group: CMSE files: - file: interface.c - file: interface.h - file: tz_context.c Directory Control The following nodes control the directory structure for the application. output-dirs: Allows to control the directory structure for build output files. Note: This control is only possible at csolution.yml level. Only relative paths to the base directory of the csolution.yml file are permitted. Use command line options of the cbuild tool to redirect the absolute path for this working directory. output-dirs: Content intdir: Optional Specifies the directory for the interim files (temporary or object files) when using cbuild with option outdir: Optional Specifies the directory for the build output files (ELF, binary, MAP files). tmpdir: Optional Specifies the directory for the interim temporary files. The default setting for the output-dirs: are: tmpdir: tmp outdir: $SolutionDir()$/out/$TargetType$ Example: output-dirs: intdir: ./tmp2 # relative path to csolution.yml file outdir: ./out/$Project$/$TargetType$ # $BuildType$ no longer part of the outdir generators: Allows to control the directory structure for generator output files. When no explicit generators: is specified, the csolution Project Manager uses as path: The workingDir defined in the generators element of the PDSC file. When no workingDir is defined the default directory $ProjectDir()$/generated/<generator-id> is used; <generator-id> is defined by the id in the generators element of the PDSC file. The generators: node can be added at various levels of the *.yml input files. The following order is used: Use generators: specification of the *.clayer.yml input file, if not exist: Use generators: specification of the *.cproject.yml input file, if not exist: Use generators: specification of the *.csolution.yml input file. Notes: Only relative paths are permitted to support portablity of projects. The location of the *.yml file that contains the generators: node is the reference for relative paths. generators: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/generated . options: Optional Specific generator options; allows explicit directory configuration for a generator. Note The base directory is extended for each generator with /<generator-id> ; <generator-id> is defined by the id in the generators element of the PDSC file. generators: - options: options: Content - generator: Optional Identifier of the generator tool, specified with id in the generators element of the PDSC file. path: Optional Specifies the directory for generated files. Relative paths used location of *.cproject.yml or *.clayer.yml file as base directory. name: Optional Specifies the base name of the generator import file (added in CMSIS-Toolbox 2.4.0); typically used for a board layer. map: Optional Mapping of the csolution project to a generator specific run-time context name (added in CMSIS-Toolbox 2.4.0). Example: generators: base-dir: $SolutionDir()$/MyGenerators # Path for all generators extended by '/<generator-id>' options: - generator: CubeMX # for the generator id `CubeMX` use this path path: ./CubeFiles # relative path to generated files and the generator import file name: MyConf # results in generator import file ./CubeFiles/MyConf.cgen.yml map: Boot # Map this project part to the CubeMX run-time context Boot rte: Allows to control the directory structure for RTE (run-time environment) files. Notes: This control is only possible at *.cproject.yml level. Only relative paths are permitted to support portablity of projects. The location of the *.cproject.yml file is the reference for relative paths. rte: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/RTE . rte: base-dir: $TargetType$/RTE # Path extended with target-type, results in `$ProjectDir()$/$TargetType$/RTE` Toolchain Options The following code translation options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project compiler: Selects the compiler toolchain used for code generation. Optionally the compiler can have a version number specification. Compiler Name Supported Compiler AC6 Arm Compiler version 6 GCC GCC Compiler IAR IAR Compiler CLANG CLANG Compiler based on LLVM technlogy Example: compiler: GCC # Select GCC Compiler compiler: AC6@6.18.0 # Select Arm Compiler version 6 linker: The linker: node specifies an explicit Linker Script and/or memory regions header file. It can be applied in *.cproject.yml and *.clayer.yml files. Refer to Linker Script Management for detailed information. linker: Content - regions: Optional Path and file name of <regions_file>.h , used to generate a Linker Script. script: Optional Explicit file name of the Linker Script, overrules files provided with file: or components. auto: Optional Request automatic Linker Script generation . define: Optional Define symbol settings for the linker script file preprocessor. for-compiler: Optional Include Linker Script for the specified toolchain. for-context: Optional Include Linker Script for a list of build and target type names. not-for-context: Optional Exclude Linker Script for a list of build and target type names. Notes: The linker: node must have at least regions: , script: , auto: , or define: . If no script: file is specified, compiler specific Linker Script template files are used. A Linker Script file is preprocessed when regions: or a define: is or the file extension is *.src . If both auto: and script: is specified a warning is issued and automatic Linker Script generation is performed and the specified script: is ignored. Examples: linker: - script: MyLinker.scf.src # linker script file regions: MyRegions.h # pre-processed using header file linker: - regions: MyRegions.h # Default linker script is used and pre-processed using header file linker: - script: MyLinker.scf.src # linker script file, not pre-processed for-compiler: AC6 # for Arm Compiler 6 - script: MyLinker.ld # linker script file, not pre-processed for-compiler: CLANG # for CLANG LLVM based compiler linker: - script: MyLinker.scf.src # linker script file for-compiler: AC6 # for Arm Compiler 6 regions: MyRegions.h # pre-processed using header file - script: MyLinker.ld.src # linker script file for-compiler: CLANG # for CLANG LLVM based compiler regions: MyRegions.h # pre-processed using header file define: # with define setting - Setup: 1 # define with value output: Configure the generated output files. output: Content base-name: Optional Specify a common base name for all output files. type: Optional A list of output types for code generation (see list below). type: Description - lib Library or archive. Note: GCC uses the prefix lib in the base name for archive files. - elf Executable in ELF format. The file extension is toolchain specific. - hex Intel HEX file in HEX-386 format. - bin Binary image. The default setting for output: is: output: base-name: $Project$ # used the base name of the `cproject.yml` file. type: elf # Generate executeable file. Example: output: # configure output files base-name: MyProject # used for all output files, including linker map file. type: - elf # Generate executeable file. - hex # generate a HEX file - bin # generate a BIN file Generate a library : output: # configure output files type: lib # Generate library file. Translation Control The following translation control options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project groups: level to specify options for a specify source file group files: level to specify options for a specify source file Note The keys define: , add-path: , del-path: , and misc: are additive. All other keys can only be defined once at the level of solution: , project: , setup: , layer: , build-types: . or target-types: . However, it is possible to overwrite these keys at the level of group: , file: , or component: , for example it is possible to translate a file group with a different optimize level. language-C: Set the language standard for C source file compilation. Value Select C Language Standard c90 compile C source files as defined in C90 standard (ISO/IEC 9899:1990). gnu90 same as c90 but with additional GNU extensions. c99 (default) compile C source files as defined in C99 standard (ISO/IEC 9899:1999). gnu99 same as c99 but with additional GNU extensions. c11 compile C source files as defined in C11 standard (ISO/IEC 9899:2011). gnu11 same as c11 but with additional GNU extensions. language-CPP: Set the language standard for C++ source file compilation. Value Select C++ Language Standard c++98 compile C++ source files as defined in C++98 standard (ISO/IEC 14882:1998). gnu++98 same as c++98 but with additional GNU extensions. c++03 compile C++ source files as defined in C++03 standard (ISO/IEC 14882:2003). gnu++03 same as c++03 but with additional GNU extensions. c++11 compile C++ source files as defined in C++11 standard (ISO/IEC 14882:2011). gnu++11 same as c++11 but with additional GNU extensions. c++14 (default) compile C++ source files as defined in C++14 standard (ISO/IEC 14882:2014). gnu++14 same as c++14 but with additional GNU extensions. c++17 compile C++ source files as defined in C++17 standard (ISO/IEC 14882:2014). gnu++17 same as c++17 but with additional GNU extensions. c++20 compile C++ source files as defined in C++20 standard (ISO/IEC 14882:2020). gnu++20 same as c++20 but with additional GNU extensions. optimize: Generic optimize levels for code generation. Value Code Generation balanced Balanced optimization size Optimized for code size speed Optimized for execution speed debug Optimize for debug experience none No optimization Note When optimize: is not specified, the default optimize setting of the compiler is used. Example: groups: - group: \"Main File Group\" optimize: none # optimize this file group for debug illusion files: - file: file1a.c - file: file1b.c debug: Control the generation of debug information. Value Code Generation on Generate debug information (default) off Generate no debug information Example: build-types: - type: Release optimize: size # optimize for size debug: off # generate no debug information for the release build warnings: Control warning level for compiler diagnostics. Value Control diagnostic messages (warnings) on Generate warning messages all Enable all compiler warning messages (compiler option -Wall) off No warning messages generated define: Contains a list of symbol #define statements that are passed via the command line to the development tools for C, C++ source files, or the linker script file preprocessor. define: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Note: This control only applies to C and C++ source files (or to the linker script preprocessor). For assembler source files use the misc: node. Example: define: # Start a list of define statements - TestValue: 12 # add symbol 'TestValue' with value 12 - TestMode # add symbol 'TestMode' undefine: Remove symbol #define statements from the command line of the development tools. undefine: Content - <symbol-name> Remove #define symbol Examples: groups: - group: \"Main File Group\" undefine: - TestValue # remove define symbol `TestValue` for this file group files: - file: file1a.c undefine: - TestMode # remove define symbol `TestMode` for this file - file: file1b.c add-path: Add include paths to the command line of the development tools for C and C++ source files. add-path: Content - <path-name> Named path to be added Note: This control only applies to C and C++ source files. For assembler source files use the misc: node. Example: project: misc: - for-compiler: AC6 C: [-fshort-enums, -fshort-wchar] - for-compiler: GCC C: [-fshort-enums, -fshort-wchar] add-path: - $OutDir(Secure)$ # add path to secure project's output directory del-path: Remove include paths (that are defined at the cproject level) from the command line of the development tools. del-paths: Content - <path-name> Named path to be removed; * for all Examle: target-types: - type: CM3 device: ARMCM3 del-paths: - /path/solution/to-be-removed pre-include: Note **New in CMSIS-Toolbox 2.5.0; requires cbuild2cmake backend (todo) Add pre-include files to the command line of the development tools for C and C++ source files. pre-include: Content - file: Name of the pre-include file. Examle: groups: - group: MyGroup pre-include: - file: my_include.h misc: Add miscellaneous literal tool-specific controls that are directly passed to the individual tools depending on the file type. misc: Content - for-compiler: Optional Name of the toolchain that the literal control string applies to. C-CPP: Optional Applies to *.c and *.cpp files (added before C and CPP: ). C: Optional Applies to *.c files only. CPP: Optional Applies to *.cpp files only. ASM: Optional Applies to assembler source files only. Link: Optional Applies to the linker (added before Link-C: or Link-CPP: ). Link-C: Optional Applies to the linker; added when no C++ files are part of the project. Link-CPP: Optional Applies to the linker; added when C++ files are part of the project. Library: Optional Applies to the library manager or archiver. Example: build-types: - type: Debug misc: - for-compiler: AC6 C-CPP: - -O1 - -g - for-compiler: GCC C-CPP: - -Og - type: Release compiler: AC6 misc: - C: - -O3 - type: GCC-LibDebug compiler: GCC misc: - Library: - -lm - -lc - -lgcc - -lnosys Project Setups The setups: node can be used to create setups that are specific to a compiler, target-type, and/or built-type. setups: The setups: node collects a list of setup: notes. For each context, only one setup will be selected. The result is a setup: that collects various toolchain options and that is valid for all files and components in the project. It is however possible to change that setup: settings on a group: or file: level. setups: Content - setup: Required Description of the setup for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. output: Optional Configure the generated output files. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. linker: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. processor: Optional Processor configuration. project: setups: - setup: Arm Compiler 6 project setup for-compiler: AC6 linker: - script: my-project.sct define: - test: 12 - setup: GCC project setup for-compiler: GCC linker: - script: my-project.inc define: - test: 11 Pack Selection The packs: node can be specified in the *.csolution.yml file allows you to: Reduce the scope of software packs that are available for projects. Add specific software packs optional with a version specification. Provide a path to a local installation of a software pack that is for example project specific or under development. The Pack Name Conventions are used to specify the name of the software packs. The pack: definition may be specific to a context that specifies target-types: and/or build-types: or provide a local path to a development repository of a software pack. Notes: By default, the csolution Project Manager only loads the latest version of the installed software packs. It is however possible to request specific versions using the - pack: node. An attempt to add two different versions of the same software pack results in an error. packs: The packs: node is the start of a pack selection. packs: Content - pack: Explicit pack specification (additive) pack: The pack: list allows to add specific software packs, optional with a version specification. The version number can have also the format @~1.2 / @~1 that matches with semantic versioning. pack: Content path: Explicit path name that stores the software pack. This can be a relative path to your project workspace. for-context: Include pack for a list of build and target types. not-for-context: Exclude pack for a list of build and target types. Note When an explicit path: to the pack is specified, an explicit pack version cannot be specified as the path directly specifies the pack to include. Example: packs: # start section that specifics software packs - pack: AWS # use packs from AWS - pack: NXP::*K32L* # use packs from NXP relating to K32L series (would match K32L3A60_DFP + FRDM-K32L3A6_BSP) - pack: ARM # use packs from Arm - pack: Keil::Arm_Compiler # add latest version of Keil::Arm_Compiler pack - pack: Keil::MDK-Middleware@7.13.0 # add Keil::MDK-Middleware pack at version 7.13.0 - pack: ARM::CMSIS-FreeRTOS@~10.4 # add CMSIS-FreeRTOS with version 10.4.x - pack: NXP::K32L3A60_DFP # add pack for NXP device path: ./local/NXP/K32L3A60_DFP # with path to the pack (local copy, repo, etc.) - pack: AWS::coreHTTP # add pack path: ./development/AWS/coreHTTP # with path to development source directory for-context: +DevTest # pack is only used for target-type \"DevTest\" Target Selection board: Specifies a unique board name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. device: Specifies a unique device name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. A device: is derived from the board: setting, but an explicit device: setting overrules the board: device. If device: specifies a device with a multi-core processor, and no explicit pname for the processor core selection is specified, the default pname of the device is used. At the level of a cproject.yml file, only the pname can be specified as the device itself is selected at the level of a csolution.yml file. Processor Attributes processor: The processor: keyword specifies the usage of processor features for this project. processor: Content fpu: Select usage of FPU instructions: dp (double precision) | sp (single precision) | off (disabled). dsp: Select usage of SIMD instructions: on (enabled) | off (disabled). mve: Select usage of M-Profile vector extension: fp (floating point and integer instructions) | int (integer instructions) | off (disabled). trustzone: Select TrustZone mode: secure | non-secure | off . branch-protection: Select Branch Protection mode: bti (branch target identification) | bti-signret (branch target identification and pointer authentication) | off (disabled). The default setting enables the available features of the device. For example fpu: dp is selected for devices that offer double precision floating point hardware. For trustzone: the default setting is: off for devices that support this option, but TrustZone is configurable. non-secure for devices that have TrustZone enabled. Example: project: processor: trustzone: secure fpu: off # do not use FPU instructions mve: off # do not use vector instructions. Context A context is an enviroment setup for a project that is composed of: project-name that is the base name of the *.cproject.yml file. .build-type that defines typically build specific settings such as for debug, release, or test. +target-type that defines typically target specific settings such as device, board, or usage of processor features. The section Project setup for multiple targets and test builds explains the overall concept of target-types and build-types . These target-types and build-types are defined in the *.csolution.yml that defines the overall application for a system. The settings of the target-types: are processed first; then the settings of the build-types: that potentially overwrite the target-types: settings. target-types: The target-types: node may include toolchain options , target selection , and processor attributes : target-types: Content - type: Required The target-type name that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control Generation of debug information. define: Optional Preprocessor (#define) symbols for code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. board: see Note Board specification. device: see Note Device specification. processor: Optional Processor specific settings. context-map: Optional Use different target-types: for specific projects. variables: Optional Variables that can be used to define project components. Note:: Either device: or board: is required. build-types: The build-types: node may include toolchain options : build-types: Content - type: Required The build-type name that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. define: Optional Preprocessor (#define) symbols for code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. context-map: Optional Use different build-types: for specific projects. variables: Optional Variables that can be used to define project components. Example: target-types: - type: Board # target-type name, used in context with: +Board board: NUCLEO-L552ZE-Q # board specifies indirectly also the device - type: Production-HW # target-type name, used in context with: +Production-HW device: STM32L552RC # specifies device build-types: - type: Debug # build-type name, used in context with: .Debug optimize: none # specifies code optimization level debug: debug # generates debug information - type: Test # build-type name, used in context with: .Test optimize: size debug: on The board: , device: , and processor: settings are used to configure the code translation for the toolchain. These settings are processed in the following order: board: relates to a BSP software pack that defines board parameters, including the mounted device . If board: is not specified, a device: must be specified. device: defines the target device. If board: is specified, the device: setting can be used to overwrite the device or specify the processor core used. processor: overwrites default settings for code generation, such as endianess, TrustZone mode, or disable Floating Point code generation. Examples: target-types: - type: Production-HW board: NUCLEO-L552ZE-Q # hardware is similar to a board (to use related software layers) device: STM32L552RC # but uses a slightly different device processor: trustzone: off # TrustZone disabled for this project target-types: - type: Production-HW board: FRDM-K32L3A6 # NXP board with K32L3A6 device device: :cm0plus # use the Cortex-M0+ processor context-map: The context-map: node allows for a specific project-name the remapping of target-types: and/or build-types: to a different context: which enables: Integrating an existing *.cproject.yml file in a different *.csolution.yml file that uses different build-types: and/or target-types: for the overall application. Defines how different *.cproject.yml files of a *.csolution.yml are to the binary image of the final target (needs reflection in cbuild-idx.yml). The context-map: node lists a remapping of the context-name for a project-name and specific target-types: and build-types: . context-map: Content - <context-name> Required Specify an alternative context-name for a project. For the context-map: it is required to specify the <project-name> as part of the context-name . This project will use a different .build-type and/or +target-type as applied in the context-name . This remapping of the context applies for the specific type in the build-types: or target-types: list. Example 1: This application combines two projects for a multi-processor device, but the project HelloCM7 requires a different setting for the build-type name Release as this enables different settings within the *.cproject.yml file. target-types: - type: DualCore device: MyDualCoreDevice build-types: - type: Release # When applying build-type name 'release': context-map: - HelloCM7.flex_release # project HelloCM7 uses build-type name \"flex_release\" instead of \"release\" projects: - project: ./CM7/HelloCM7.cproject.yml - project: ./CM4/HelloCM4.cproject.yml Example 2: The following example uses three projects Demo , TFM and Boot . The project TFM should be always build using the context TFM.Release+LibMode . For the target-type name Board , the Boot project requires the +Flash target, but any build-type could be used. target-types: - type: Board # When applying target-type: 'Board': context-map: - TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode - Boot+Flash # for project Boot use target-type: Flash board: B-U585I-IOT02A - type: AVH # When applying target-type: 'AVH': context-map: - context: TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode device: ARM::SSE-300-MPS3 projects: - project: ./App/Demo.cproject.yml - project: ./Security/TFM.cproject.yml - project: ./Loader/Boot.cproject.yml Conditional Build It is possible to include or exclude items of a list node in the build process. for-compiler: includes items only for a compiler toolchain. for-context: includes items only for a context list. not-for-context: excludes items for a context list. Note for-context and not-for-context are mutually exclusive, only one occurrence can be specified for a list node . for-compiler: Depending on a compiler toolchain it is possible to include list nodes in the build process. Examples: for-compiler: AC6@6.16 # add item for Arm Compiler version 6.16 only for-compiler: GCC # for GCC Compiler (any version) for-context: A context list that adds a list-node for specific target-type and/or build-type names. not-for-context: A context list that removes a list-node for specific target-types: and/or build-types: . Context List It is also possible to provide a context list with: - [.build-type][+target-type] - [.build-type][+target-type] Examples: for-context: - .Test # add item for build-type: Test (any target-type) for-context: # add item - .Debug # for build-type: Debug and - .Release+Production-HW # build-type: Release / target-type: Production-HW not-for-context: +Virtual # remove item for target-type: Virtual (any build-type) not-for-context: .Release+Virtual # remove item for build-type: Release with target-type: Virtual Usage The keyword for-context: and not-for-context: can be applied to the following list nodes : List Node Description - project: At projects: level it is possible to control inclusion of project. - layer: At layers: level it is possible to control inclusion of a software layer. The keyword for-context: , not-for-context: , and for-compiler: can be applied to the following list nodes : List Node Description - component: At components: level it is possible to control inclusion of a software component. - group: At groups: level it is possible to control inclusion of a file group. - setup: At setups: level it is define toolchain specific options that apply to the whole project. - file: At files: level it is possible to control inclusion of a file. The inclusion of a list node is processed for a given project context respecting its hierarchy from top to bottom: project --> layer --> component / group --> file In other words, the restrictions specified by for-context: or not-for-context for a list node are automatically applied to its children nodes. Children list nodes inherit the restrictions from their parent. Multiple Projects The section Project setup for related projects describes the organization of multiple projects. The file *.csolution.yml describes the relationship of this projects and may also re-map target-types: and build-types: for this projects using context-map: . projects: The YAML structure of the section projects: is: projects: Content - project: Required Path to the project file. for-context: Optional Include project for a list of build and target types. not-for-context: Optional Exclude project for a list of build and target types. Examples: This example uses two projects that are build in parallel using the same build-type: and target-type: . Such a setup is typical for multi-processor systems. projects: - project: ./CM0/CM0.cproject.yml # include project for Cortex-M0 processor - project: ./CM4/CM4.cproject.yml # include project for Cortex-M4 processor This example uses multiple projects, but with additional controls. projects: - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # build only when 'target-type: CM0-Addon' is selected for-compiler: GCC # build only when 'compiler: GCC' is selected define: # add additional defines during build process - test: 12 - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # specify use case for-compiler: AC6 # build only when 'compiler: AC6' is selected define: # add additional defines during build process - test: 9 - project: ./Debug/Debug.cproject.yml # specify cproject.yml file not-for-context: .Release # generated for any 'build-type:' except 'Release' Source File Management Keyword Used in files Description groups: *.cproject.yml , *.clayer.yml Start of a list that adds source groups and files to a project or layer. layers: *.cproject.yml Start of a list that adds software layers to a project. components: *.cproject.yml , *.clayer.yml Start of a list that adds software components to a project or layer. groups: The groups: keyword specifies a list that adds source groups and files to a project or layer: groups: Content - group: Required Name of the group. for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. groups: Optional Start a nested list of groups. files: Optional Start a list of files. Example: See files: section. files: Add source files to a project. files: Content - file: Required Name of the file. for-context: Optional Include file for a list of build and target types. not-for-context: Optional Exclude file for a list of build and target types. for-compiler: Optional Include file for a list of compilers. category: Optional Explicit file category to overwrite filename extension assignment. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. Note It is also possible to specify a Linker Script . Files with the extension .sct , .scf , .ld , and .icf are recognized as Linker Script files. Example: Add source files to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. groups: - group: \"Main File Group\" not-for-context: # includes this group not for the following: - .Release+Virtual # build-type 'Release' and target-type 'Virtual' - .Test-DSP+Virtual # build-type 'Test-DSP' and target-type 'Virtual' - +Board # target-type 'Board' files: - file: file1a.c - file: file1b.c define: - a: 1 undefine: - b optimize: size - group: \"Other File Group\" files: - file: file2a.c for-context: +Virtual # include this file only for target-type 'Virtual' define: - test: 2 - file: file2a.c not-for-context: +Virtual # include this file not for target-type 'Virtual' - file: file2b.c - group: \"Nested Group\" groups: - group: Subgroup1 files: - file: file-sub1-1.c - file: file-sub1-2.c - group: Subgroup2 files: - file: file-sub2-1.c - file: file-sub2-2.c It is also possible to include a file group for a specific compiler using for-compiler: or a specific target-type and/or build-type using for-context: or not-for-context: . groups: - group: \"Main File Group\" for-compiler: AC6 # includes this group only for Arm Compiler 6 files: - file: file1a.c - file: file2a.c - group: \"Main File Group\" for-compiler: GCC # includes this group only for GCC Compiler files: - file: file1b.c - file: file2b.c layers: Add a software layer to a project. Used in *.cproject.yml files. layers: Content - layer: Optional Path to the *.clayer.yml file that defines the layer. type: Optional Refers to an expected layer type. for-context: Optional Include layer for a list of build and target types. not-for-context: Optional Exclude layer for a list of build and target types. Example: layers: # Socket - layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml for-context: - +IP-Stack - layer: ./Socket/WiFi/Socket.clayer.yml for-context: - +WiFi - layer: ./Socket/VSocket/Socket.clayer.yml for-context: - +AVH # Board - layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml for-context: - +IP-Stack # - +WiFi - layer: ./Board/B-U585I-IOT02A/Board.clayer.yml for-context: - +WiFi - layer: ./Board/AVH_MPS3_Corstone-300/Board.clayer.yml for-context: - +AVH layer: - type: The layer: - type: is used in combination with the meta-data of the connections: to check the list of available *.clayer.yml files for matching layers. Instead of an explicit layer: node that specifies a *.clayer.yml file, the type: is used to search for matching layers with the csolution command list layers . Example: layers: - type: Socket # search for matching layers of type `Socket` - type: Board # search for matching layers of type `Board` When combined with variables: it is possible to define the required *.clayer.yml files at the level of the *.csolution.yml file. Refer to variables: for an example. components: Add software components to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. components: Content - component: Required Name of the software component. for-context: Optional Include component for a list of build and target types. not-for-context: Optional Exclude component for a list of build and target types. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. instances: Optional Add multiple instances of component configuration files (default: 1) Example: components: - component: ARM::CMSIS:RTOS2:FreeRTOS&Cortex-M - component: ARM::RTOS&FreeRTOS:Config&CMSIS RTOS2 - component: ARM::RTOS&FreeRTOS:Core&Cortex-M - component: ARM::RTOS&FreeRTOS:Event Groups - component: ARM::RTOS&FreeRTOS:Heap&Heap_5 - component: ARM::RTOS&FreeRTOS:Stream Buffer - component: ARM::RTOS&FreeRTOS:Timers - component: ARM::Security:mbed TLS define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" - component: AWS::FreeRTOS:backoffAlgorithm - component: AWS::FreeRTOS:coreMQTT - component: AWS::FreeRTOS:coreMQTT Agent - component: AWS::FreeRTOS:corePKCS11&Custom define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" Note The name format for a software component is described under Name Conventions - Component Name Conventions . instances: Allows to add multiple instances of a component and actually applies to configuration files. For detailed description refer to Open-CMSIS-Pack specification - Component Instances Example: components: - component: USB:Device instances: 2 If the user selects multiple instances of the same component, all files with attribute config in the *.PDSC file will be copied multiple times to the project. The name of the component (for example config_mylib.h) will get a postfix _n whereby n is the instance number starting with 0. Instance 0: config_usb_device_0.h Instance 1: config_usb_device_1.h The availability of instances in a project can be made public in the RTE_Components.h file. The existing way to extend the %Instance% with the instance number n . Pre/Post build steps The CMSIS-Toolbox supports pre-build and post-build steps that utilize external tools or scripts. Such external commands can be used for various tasks such as: pre-process source files. add checksums to a binary file. combine multiple ELF files into a single image. add a timestamp to an image ( always: ensures execution in every build). sign images for a boot laoder. executes: Execute and external command for pre or post build steps used in *.csolution.yml and *.cproject.yml files. The input: and output: files are used for dependency checking and schedule the execution (as pre-build or post-build step) during the build process. The structure of the executes: node is: executes: Content - execute: Required Description of the build step. run: Required Command string with name of the program or script (optionally with path) along with argument string. always: Optional When present, the build step always runs and bypasses check for outdated output: files. input: Optional A list of input files (may contain Access Sequences ). output: Optional A list of output files (may contain Access Sequences ). for-context: Optional Run command for a list of build and target types (only supported in *.cproject.yml ). not-for-context: Optional Exclude run command for a list of build and target types (only supported in *.cproject.yml ). The run: command string uses these sequences to access input files and output files: run: command file access Description $input$ Comma separated list of all input files. $input(<n>)$ Input file in the list with index <n> ; first item is <n>=0 . $output$ Comma separated list of all output files. $output(<n>)$ Output file in the list with index <n> ; first item is <n>=0 . Examples: solution: # executed as part of a project build executes: - execute: Generate Download Image run: gen_image $input$ -o $output$ --sign # Command line string input: - $elf(Application)$ # combine these project parts - $elf(TFM)$ - $elf(Bootloader)$ output: - $SolutionDir$/$Solution$.out # output file name project: # executed as part of a project build executes: - execute: Generate Encryption Keys run: KeyGen $input$ -o $output$ always: # always generate the keyfile.c as it contains a timestamp input: keyfile.txt # contains the key in text format output: keyfile.c # output as C source file that is part of this project solution: # executed as part of a solution build executes: # uses a CMake script - execute: Archive Artifacts run: ${CMAKE_COMMAND} -DINPUT=$input$ -DOUTPUT=$output$ -P $input(0)$ always: input: - script/archive.cmake - $elf(project.Release+ARMCM0)$ - $elf(project.Release+ARMCM0)$.signed - $elf(bootloader.Release+ARMCM0)$ output: - $SolutionDir()$/artifacts.zip project: # executed as part of a project build executes: # uses a CMake script - execute: Sign ELF Image run: ${CMAKE_COMMAND} -DINPUT=$input(1)$ -DOUTPUT=$output$ -P $input(0)$ input: - $SolutionDir()$/script/sign.cmake #CMake script - $elf()$ # ELF file generated by project output: - $elf()$.signed for-context: # only for build-type: Release - .Release connections: The connections: node contains meta-data that describes the compatiblity of *.cproject.yml and *.clayer.yml project parts. The connections: node lists functionality (drivers, pins, and other software or hardware resources). The node consumes: lists required functionality; the node provides: is the implemented functionality of that project part. This enables reference applications that work across a range of different hardware targets where: The *.cproject.yml file of the reference application lists with the connections: node the required functionality with consumes: . The *.clayer.yml project part lists with the connections: node the implemented functionality with provides: . This works across multiple levels, which means that a *.clayer.yml file could also require other functionality using consumes: . The connections: node is used to identify compatible software layers. These software layers could be stored in CMSIS software packs using the following structure: A reference application described in a *.cproject.yml file could be provided in a git repository. This reference application uses software layers that are provided in CMSIS software packs. A CMSIS Board Support Pack (BSP) contains a configured board layer desribed in a *.clayer.yml file. This software layer is pre-configured for a range of use-cases and provides drivers for I2C and SPI interfaces along with pin definitions and provisions for an Ardunio shield. For a sensor, a CMSIS software pack contains the sensor middleware and software layer ( *.clayer.yml ) that describes the hardware of the Ardunio sensor shield. This shield can be applied to many different hardware boards that provide an Ardunio shield connector. This connections: node enables therefore software reuse in multiple ways: The board layer can be used by many different reference applications, as the provided: functionlity enables a wide range of use cases. The sensor hardware shield along with the middleware can be used across many different boards that provide an Ardunio shield connector along with board layer support. The structure of the connections: node is: connections: Description - connect: Required Lists specific functionality with a brief verbal description connect: The connect: node describes one or more functionalities that belong together. connect: Description set: Optional Specifies a config-id . select value that identifies a configuration option info: Optional Verbal desription displayed when this connect is selected provides: Optional List of functionality ( key / value pairs) that are provided consumes: Optional List of functionality ( key / value pairs) that are required set: Some hardware boards have configuration settings (DIP switch or jumper) that configure interfaces. These settings have impact to the functionality (for example hardware interfaces). With set: config-id . select the possible configration options are considered when evaluating compatible *.cproject.yml and *.clayer.yml project parts. The csolution Project Manager iterates the connect: node with a set: config-id . select as described below: For each config-id only one connect: node with a select value is active at a time. Each possible select value is checked for a matching configuration. When project parts have a matching configuration, the set: value along with the info: is shown to the user. This allows the user to enable the correct hardware options. Refer to Example: Sensor Shield for a usage example. provides: A user-defined key / value pair list of functionality that is implemented or provided by a project: or layer: . The csolution Project Manager combines all the key / value pairs that listed under provides: and matches it with the key / value pairs that are listed under consumes: . For key / value pairs listed under provides: the following rules exist for a match with consumes: key / value pair: It is possible to omit the value . It matches with an identical key listed in consumes: A value is interpreted as number. Depending on the value prefix, this number must be: when consumes: value is a plain number, identical with this value. when consumes: value is prefixed with + , higher or equal then this value or the sum of all values in multiple consumes: nodes. consumes: A user-defined key / value pair list of functionality that is requried or consumed by a project: or layer: . For key / value pairs listed under consumed: the following rules exist: When no value is specified, it matches with any value of an identical key listed under provides: . A value is interpreted as number. This number must be identical in the provides: value pair. A value that is prefixed with + is interpreted as a number that is added together in case that the same key is listed multiple times under consumes: . The sum of this value must be lower or equal to the value upper limit of the provides: key . Example: Board This connections: node of a board layer describes the available interfaces. The WiFi interface requires a CMSIS-RTOS2 function. connections: # describes functionality of a board layer - connect: WiFi interface provides: - CMSIS-Driver WiFi: requires: - CMSIS-RTOS2: - connect: SPI and UART interface provides: - CMSIS-Driver SPI: - CMSIS-Driver UART: Example: Simple Project This shows a the connections: node of a complete application project that is composed of two software layers. MyProject.cproject.yml connections: - connect: all resources provides: - RTOS2: # implements RTOS2 API interface consumes: - IoT_Socket: # requires IoT_Socket interface - STDOUT: # requires STDOUT interface - Heap: +30000 # requires additional 30000 bytes memory heap : layers: - layer: MySocket.clayer.yml - layer: MyBoard.clayer.yml MySocket.clayer.yml connections: - connect: consumes: - RTOS2: # requires RTOS2 API interface - VSocket: # requires VSocket interface - Heap: +20000 # requires additional 20000 bytes memory heap provides: - IoT_Socket: # provides IoT_Socket interface MyBoard.clayer.yml connections: - connect: consumes: - RTOS2: provides: - VSocket: - STDOUT: - Heap: 65536 Example: Sensor Shield This sensor shield layer provides a set of interfaces that are configurable. connections: - connect: I2C Interface 'Std' set: comm.I2C-Std info: JP1=Off JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C: - connect: I2C Interface 'Alt' set: comm.I2C-Alt info: JP1=On JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C-Alt: - connect: SPI Interface 'Alt' set: comm.SPI info: JP2=On provides: - Sensor_SPI: consumes: - Ardunio_Uno_SPI: - connect: Sensor Interrupt INT0 set: SensorIRQ.0 info: JP3=Off provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D2: - connect: Sensor Interrupt INT1 set: SensorIRQ.1 info: JP3=On provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D3:","title":"CMSIS Solution Project File Format"},{"location":"YML-Input-Format%20-%20Preinclude/#cmsis-solution-project-file-format","text":"The following chapter explains the CMSIS Solution Project File Format (short form csolution project files ), the YAML files that that describes the software of an embedded application.","title":"CMSIS Solution Project File Format"},{"location":"YML-Input-Format%20-%20Preinclude/#name-conventions","text":"","title":"Name Conventions"},{"location":"YML-Input-Format%20-%20Preinclude/#filename-extensions","text":"The csolution Project Manager recognizes the categories of files based on the filename extension in the YAML input files as shown in the table below. File Extension Category Description .c , .C sourceC C source file .cpp , .c++ , .C++ , .cxx , .cc , .CC sourceCpp C++ source file .h , .hpp header Header file .asm , .s , .S sourceAsm Assembly source file .ld , .scf , .sct , .icf linkerScript Linker Script file .a , .lib library Library file .o object Object file .txt , .md , .pdf , .htm , .html doc Documentation .scvd other Software Component View Description for CMSIS-View","title":"Filename Extensions"},{"location":"YML-Input-Format%20-%20Preinclude/#pack-name-conventions","text":"The csolution Project Manager uses the following syntax to specify the pack: names in the *.yml files. vendor [:: pack-name [@[~ | >=] version] ] Element Description vendor Required Vendor name of the software pack. pack-name Optional Name of the software pack; wildcards (*, ?) can be used. version Optional Version number of the software pack, with @1.2.3 that must exactly match, @~1.2 / @~1 that matches with semantic versioning, or @>=1.2.3 that allows any version higher or equal. Note When no version is specified, the csolution Project Manager only loads the latests version of a software pack. This also applies when wildcards are used in the pack-name . Examples: - pack: ARM::CMSIS@5.5.0 # 'CMSIS' Pack (with version 5.5.0) - pack: Keil::MDK-Middleware@>=7.13.0 # 'MDK-Middleware' Software Pack from vendor Keil (with version 7.13.0 or higher, latest available to the tool) - pack: Keil::TFM # 'TFM' Software Pack from vendor Keil (with latest version available to the tool) - pack: AWS # All latest versions of Software Packs from vendor 'AWS' - pack: Keil::STM* # All latest versions of Software Packs that start with 'STM' from vendor 'Keil'","title":"pack: Name Conventions"},{"location":"YML-Input-Format%20-%20Preinclude/#component-name-conventions","text":"The csolution Project Manager uses the following syntax to specify the component: names in the *.yml files. [Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[~ | >=]Cversion] Components are defined using the Open-CMSIS-Pack - <component> element . Several parts of a component are optional. For example it is possible to just define a component using Cclass and Cgroup name. All elements of a component name are summarized in the following table. Element Description Cvendor Optional Name of the component vendor as defined in <components> element or by the package vendor of the software pack. Cclass Required Component class name as defined in <components> element of the software pack. Cbundle Optional Bundle name of the component class as defined in <bundle> element of the software pack. Cgroup Required Component group name as defined in <components> element of the software pack. Csub Optional Component sub-group name as defined in <components> element of the software pack. Cvariant Optional Component sub-group name as defined in <components> element of the software pack. Cversion Optional Version number of the component, with @1.2.3 that must exactly match, @~1.2 / @~1 that matches with semantic versioning, or @>=1.2.3 that allows any version higher or equal. Partly defined components A component can be partly defined in csolution project files ( *.cproject.yml , *.clayer.yml , *.genlayer.yml ) by omitting Cvendor , Cvariant , and Cversion , even when this are part of the components element of the software pack. The component select algorithm resolves this to a fully defined component by: when a partly specified component resolves to several possible choices, the tool selects: (a) the default Cvariant of the component as defined in the PDSC file. (b) the component with the higher Cversion value. (c) and error message is issued when two identical components are defined by multiple vendors and Cvendor is not specified. the partly specified component is extended by: version information from the software pack. default variant definition from the software pack. The fully resolved component name is shown in the *.cbuild.yml output file. Multiple component definitions are rejected If a component is added more then once in the csolution project files and an error is issued. An attempt to select multiple variants (using Cvariant ) of a component results in an error . Examples: - component: CMSIS:CORE # CMSIS Core component (vendor selected by `csolution` ARM) - component: ARM::CMSIS:CORE # CMSIS Core component from vendor ARM (any version) - component: ARM::CMSIS:CORE@5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0) - component: ARM::CMSIS:CORE@>=5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0 or higher) - component: Device:Startup # Device Startup component from any vendor - component: CMSIS:RTOS2:Keil RTX5 # CMSIS RTOS2 Keil RTX5 component with default variant (any version) - component: ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3 # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3 - component: Keil::USB&MDK-Pro:CORE&Release@6.15.1 # USB CORE component from bundle MDK-Pro in variant 'Release' and version 6.15.1","title":"component: Name Conventions"},{"location":"YML-Input-Format%20-%20Preinclude/#device-name-conventions","text":"The device specifies multiple attributes about the target that ranges from the processor architecture to Flash algorithms used for device programming. The following syntax is used to specify a device: value in the *.yml files. [ [ Dvendor:: ] Dname] [:Pname] Element Description Dvendor Optional Name (without enum field) of the device vendor defined in <devices><family> element of the software pack. Dname Optional Device name (Dname attribute) or when used the variant name (Dvariant attribute) as defined in the \\<devices> element. Pname Optional Processor identifier (Pname attribute) as defined in the <devices> element. Note All elements of a device name are optional which allows to supply additional information, such as the :Pname at different stages of the project. However the Dname itself is a mandatory element and must be specified in context of the various project files. Dvendor:: must be used in combination with the Dname . Examples: device: NXP::LPC1768 # The LPC1788 device from NXP device: LPC1788 # The LPC1788 device (vendor is evaluated from DFP) device: LPC55S69JEV98 # Device name (exact name as defined in the DFP) device: LPC55S69JEV98:cm33_core0 # Device name (exact name as defined in the DFP) with Pname specified device: :cm33_core0 # Pname added to a previously defined device name (or a device derived from a board)","title":"device: Name Conventions"},{"location":"YML-Input-Format%20-%20Preinclude/#board-name-conventions","text":"Evaluation Boards define indirectly a device via the related BSP. The following syntax is used to specify a board: value in the *.yml files. [vendor::] board_name [:revision] Element Description vendor Optional Name of the board vendor defined in <boards><board> element of the board support pack (BSP). Bname Required Board name (name attribute) as defined in the \\<board> element of the BSP. revision Optional Board revision (revision attribute) as defined in the \\<board> element of the BSP. Note When a board: is specified, the device: specification can be omitted, however it is possible to overwrite the device setting in the BSP with an explicit device: setting. Examples: board: Keil::MCB54110 # The Keil MCB54110 board (with device NXP::LPC54114J256BD64) board: LPCXpresso55S28 # The LPCXpresso55S28 board board: STMicroelectronics::NUCLEO-L476RG:Rev.C # A board with revision specification","title":"board: Name Conventions"},{"location":"YML-Input-Format%20-%20Preinclude/#context-name-conventions","text":"A context: name combines project-name , built-type , and target-type and is used on various places in the CMSIS-Toolbox. The following syntax is used to specify a context: name. [project-name][.build-type][+target-type] Element Description project-name Optional Project name of a project (base name of the *.cproject.yml file). .build-type Optional The build-type name that is currently processed (specified with - type: name ). +target-type Optional The target-type name that is currently processed (specified with - type: name ). Note The .build-type and +target-type name allows letters (A-Z, a-z), digits (0-9), dash ('-'), and underscore ('_'); the maximum length is 32 characters. When project-name is omitted, the project-name is the base name of the *.cproject.yml file. When .build-type is omitted, it matches with any possible .build-type . When +target-type is omitted, it matches with any possible +target-type . By default, the specified - type: name of build-types: and target-types: nodes in the *.csolution.yml file are directly mapped to the context name. Using the context-map: node it is possible to assign a different .build-type and/or +target-type mapping for a specific project-name . Example: Show the different possible context settings of a *.csolution.yml file. AWS_MQTT_MutualAuth_SW_Framework>csolution list contexts -s Demo.csolution.yml Demo.Debug+AVH Demo.Debug+IP-Stack Demo.Debug+WiFi Demo.Release+AVH Demo.Release+IP-Stack Demo.Release+WiFi The context name is also used in for-context: and not-for-context: nodes that allow to include or exclude items depending on the context . In many cases the project-name can be omitted as the context name is within a specific *.cproject.yml file or applied to a specific *.cproject.yml file.","title":"context: Name Conventions"},{"location":"YML-Input-Format%20-%20Preinclude/#access-sequences","text":"The following access sequences allow to use arguments from the CMSIS Project Manager as arguments of the various *.yml files in the key values for define: , add-path: , misc: , files: , and executes: . The access sequences can refer in a different project and provide therefore a method to describe project dependencies. Access Sequence Description Target Access to target and build related settings $Bname$ Bname of the selected board as specified in the board: node. $Dname$ Dname of the selected device as specified in the device: node. $Pname$ Pname of the selected device as specified in the device: node. $BuildType$ Build-type name of the currently processed project. $TargetType$ Target-type name of the currently processed project. $Compiler$ Compiler name of the compiler used in this project context as specified in the compiler: node. YML Input Access to YML Input Directories and Files $Solution$ Solution name (base name of the *.csolution.yml file). $SolutionDir()$ Path to the directory of the current processed csolution.yml file. $Project$ Project name of the current processed cproject.yml file. $ProjectDir(context)$ Path to the directory of a related cproject.yml file. Output Access to Output Directories and Files $OutDir(context)$ Path to the output directory of a related project that is defined in the *.csolution.yml file. $bin(context)$ Path and filename of the binary output file generated by the related context. $cmse-lib(context)$ Path and filename of the object file with secure gateways of a TrustZone application generated by the related context. $elf(context)$ Path and filename of the ELF/DWARF output file generated by the related context. $hex(context)$ Path and filename of the HEX output file generated by the related context. $lib(context)$ Path and filename of the library file of the related context. For a context the project-name , .build-type , and +target-type are optional; when omitted the current processed context is used. Example: $ProjectDir()$ is the directory of the current processed cproject.yml file. Note The access sequences below are not completed yet, as they require a change to CMSIS-Build. Access Sequence Description $Bpack$ Path to the pack that defines the selected board (BSP). $Dpack$ Path to the pack that defines the selected device (DFP). $Pack(vendor.name)$ Path to a specific pack. Example: $Pack(NXP.K32L3A60_DFP)$ . Example: For the example below we assume the following build-type , target-type , and projects definitions. solution: target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q # specifies board - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device build-types: - type: Debug # build-type: Debug optimize: none debug: on - type: Release # build-type: Release optimize: size projects: - project: ./bootloader/Bootloader.cproject.yml # relative path - project: /MyDevelopmentTree/security/TFM.cproject.yml # absolute path - project: ./application/MQTT_AWS.cproject.yml # relative path The project: /application/MQTT_AWS.cproject.yml can now use Access Sequences to reference files or directories in other projects that belong to a solution. For example, these references are possible in the file MQTT_AWS.cproject.yml . The example below uses the build-type and target-type of the current processed context. In practice this means that the same build-type and target-type is used as for the MQTT_AWS.cproject.yml project. files: - file: $cmse-lib(TFM)$ # use the symbol output file of the TFM Project The example below uses from the TFM project always build-type: Debug and the target-type: Production-HW . files: - file: `$cmse-lib(TFM.Release+Production-HW)$` # use the symbol output file of the TFM Project The example below uses the build-type: Debug . The target-type of the current processed context is used. Note Implementation of executes: is scheduled for implementation in CMSIS-Toolbox 2.4 (Q2'24) executes: - execute: Generate Image run: gen_image %input% -o %output% # DFP the get_image tool input: - $elf(TFM.Debug)$ - $elf(Bootloader.Release)$ output: - $OutDir(TFM.Debug)$ The example below creates a define that uses the device name. groups: - group: \"Main File Group\" define: - $Dname$ # Generate a #define 'device-name' for this file group","title":"Access Sequences"},{"location":"YML-Input-Format%20-%20Preinclude/#variables","text":"The variables: node defines are key/value pairs that can be used to refer to *.clayer.yml files. The key is the name of the variable and can be used in the following nodes: layers: , define: , add-path: , misc: , files: , and executes: Using variables that are defined in the *.csolution.yml file, a *.cproject.yml file requires no modifications when new target-types: are introduced. The required layers: could be instead specified in the *.csolution.yml file using a new node variables: . Example: Example.csolution.yml solution: target-types: - type: NXP Board board: IMXRT1050-EVKB variables: - Socket-Layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml - Board-Layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml - type: ST Board board: B-U585I-IOT02A variables: - Socket-Layer: ./Socket/WiFi/Socket.clayer.yml - Board-Layer: ./Board/B-U585I-IOT02A/Board.clayer.yml Example.cproject.yml layers: - layer: $Socket-Layer$ type: Socket - layer: $Board-Layer$ # no `*.clayer.yml` specified. Compatible layers are listed type: Board # layer of type `Board` is expected","title":"Variables"},{"location":"YML-Input-Format%20-%20Preinclude/#order-of-list-nodes","text":"The key / value pairs in a list node can be in any order. The two following list nodes are logically identical. This might be confusing for yml files that are generated by an IDE. build-types: - type: Release # build-type name optimize: size # optimize for size debug: off # generate no debug information for the release build build-types: - debug: off # generate no debug information for the release build optimize: size # optimize for size type: Release # build-type name","title":"Order of List Nodes"},{"location":"YML-Input-Format%20-%20Preinclude/#project-file-structure","text":"The table below explains the top-level elements in each of the different *.yml input files that define the overall application. Keyword Description default: Start of cdefault.yml file that is used to setup the compiler along with some compiler-specific controls. solution: Start of *.csolution.yml file that collects related projects along with build-types: and target-types: . project: Start of *.cproject.yml file that defines files, components, and layers which can be independently translated to a binary image or library. layer: Start of *.clayer.yml file that contains pre-configured software components along with source files.","title":"Project File Structure"},{"location":"YML-Input-Format%20-%20Preinclude/#cdefault","text":"When cdefault: is specified in the *.csolution.yml file, the csolution Project Manager uses a file with the name cdefault.yml or cdefault.yaml to setup the compiler along with some specific default controls. The search order for this file is: A cdefault.yml or cdefault.yaml file in the same directory as the <solution-name>.csolution.yml file. A cdefault.yml or cdefault.yaml file in the directory specified by the environment variable CMSIS_COMPILER_ROOT . A cdefault.yml or cdefault.yaml file in the directory <cmsis-toolbox-installation-dir>/etc . The default: node is the start of a cdefault.yml or cdefault.yaml file and contains the following. default: Content compiler: Toolchain selection. misc: Literal tool-specific controls. Example: default: compiler: AC6 misc: - ASM: - -masm=auto - Link: - --info sizes --info totals --info unused --info veneers --info summarysizes - --map","title":"cdefault:"},{"location":"YML-Input-Format%20-%20Preinclude/#solution","text":"The solution: node is the start of a *.csolution.yml file that collects related projects as described in the section \"Project setup for related projects\" . solution: Content created-by: Optional Identifies the tool that created this solution. created-for: Optional Specifies the tool for building this solution, i.e. CMSIS-Toolbox@2.2.0 description: Optional Brief description text of this solution. cdefault: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. compiler: Optional Overall toolchain selection for this solution. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. output-dirs: Optional Control the output directories for the build output. generators: Optional Control the directory structure for generator output. packs: Optional Defines local packs and/or scope of packs that are used. target-types: Required List of target-types that define the target system (device or board). build-types: Optional List of build-types (i.e. Release, Debug, Test). projects: Required List of projects that belong to the solution. executes: Optional Additional pre or post build steps using external tools. Example: solution: created-for: cmsis-toolbox@2.0 # minimum CMSIS-Toolbox version required for project build cdefault: # use default setup of toolchain specific controls. compiler: GCC # overwrite compiler definition in 'cdefaults.yml' packs: - pack: ST # add ST packs in 'cdefaults.yml' build-types: # additional build types - type: Test # build-type: Test optimize: none debug: on packs: # with explicit pack specification - pack: ST::TestSW path: ./MyDev/TestSW target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device projects: - project: ./blinky/Bootloader.cproject.yml - project: /security/TFM.cproject.yml - project: /application/MQTT_AWS.cproject.yml","title":"solution:"},{"location":"YML-Input-Format%20-%20Preinclude/#project","text":"The project: node is the start of a *.cproject.yml file and can contain the following: project: Content description: Optional Brief description text of this project. output: Optional Configure the generated output files. generators: Optional Control the directory structure for generator output. rte: Optional Control the directory structure for RTE (run-time environment) files. packs: Optional Defines packs that are required for this project. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. linker: Optional Instructions for the linker. debug: Optional Generation of debug information. define: Optional Preprocessor (#define) symbols for code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Device setting (specify processor core). processor: Optional Processor specific settings. groups: Required List of source file groups along with source files. components: Optional List of software components used. layers: Optional List of software layers that belong to the project. connections: Optional List of consumed and provided resources. executes: Optional Additional pre or post build steps using external tools. Example: project: misc: - compiler: AC6 # specify misc controls for Arm Compiler 6 C: [-fshort-enums, -fshort-wchar] # set options for C files add-path: - $OutDir(Secure)$ # add the path to the secure project's output directory components: - component: Startup # Add startup component - component: CMSIS CORE - component: Keil RTX5 Library_NS groups: - group: Non-secure Code # Create group files: - file: main_ns.c # Add files to group - file: $Source(Secure)$interface.h - file: $Output(Secure)$_CMSE_Lib.o","title":"project:"},{"location":"YML-Input-Format%20-%20Preinclude/#layer","text":"The layer: node is the start of a *.clayer.yml file and defines a Software Layer . It can contain the following nodes: layer: Content type: Optional Layer type for combining layers; used to identify compatible layers . description: Optional Brief description text of the layer. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. generators: Optional Control the directory structure for generator output. packs: Optional Defines packs that are required for this layer. for-device: Optional Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Optional Board information, used for consistency check (board selection is in *.csolution.yml ). connections: Optional List of consumed and provided resources. processor: Optional Processor specific settings. linker: Optional Instructions for the linker. groups: Optional List of source file groups along with source files. components: Optional List of software components used. Example: layer: type: Board description: Setup with Ethernet and WiFi interface processor: trustzone: secure # set processor to secure components: - component: Startup - component: CMSIS CORE groups: - group: Secure Code files: - file: main_s.c - group: CMSE files: - file: interface.c - file: interface.h - file: tz_context.c","title":"layer:"},{"location":"YML-Input-Format%20-%20Preinclude/#directory-control","text":"The following nodes control the directory structure for the application.","title":"Directory Control"},{"location":"YML-Input-Format%20-%20Preinclude/#output-dirs","text":"Allows to control the directory structure for build output files. Note: This control is only possible at csolution.yml level. Only relative paths to the base directory of the csolution.yml file are permitted. Use command line options of the cbuild tool to redirect the absolute path for this working directory. output-dirs: Content intdir: Optional Specifies the directory for the interim files (temporary or object files) when using cbuild with option outdir: Optional Specifies the directory for the build output files (ELF, binary, MAP files). tmpdir: Optional Specifies the directory for the interim temporary files. The default setting for the output-dirs: are: tmpdir: tmp outdir: $SolutionDir()$/out/$TargetType$ Example: output-dirs: intdir: ./tmp2 # relative path to csolution.yml file outdir: ./out/$Project$/$TargetType$ # $BuildType$ no longer part of the outdir","title":"output-dirs:"},{"location":"YML-Input-Format%20-%20Preinclude/#generators","text":"Allows to control the directory structure for generator output files. When no explicit generators: is specified, the csolution Project Manager uses as path: The workingDir defined in the generators element of the PDSC file. When no workingDir is defined the default directory $ProjectDir()$/generated/<generator-id> is used; <generator-id> is defined by the id in the generators element of the PDSC file. The generators: node can be added at various levels of the *.yml input files. The following order is used: Use generators: specification of the *.clayer.yml input file, if not exist: Use generators: specification of the *.cproject.yml input file, if not exist: Use generators: specification of the *.csolution.yml input file. Notes: Only relative paths are permitted to support portablity of projects. The location of the *.yml file that contains the generators: node is the reference for relative paths. generators: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/generated . options: Optional Specific generator options; allows explicit directory configuration for a generator. Note The base directory is extended for each generator with /<generator-id> ; <generator-id> is defined by the id in the generators element of the PDSC file.","title":"generators:"},{"location":"YML-Input-Format%20-%20Preinclude/#generators-options","text":"options: Content - generator: Optional Identifier of the generator tool, specified with id in the generators element of the PDSC file. path: Optional Specifies the directory for generated files. Relative paths used location of *.cproject.yml or *.clayer.yml file as base directory. name: Optional Specifies the base name of the generator import file (added in CMSIS-Toolbox 2.4.0); typically used for a board layer. map: Optional Mapping of the csolution project to a generator specific run-time context name (added in CMSIS-Toolbox 2.4.0). Example: generators: base-dir: $SolutionDir()$/MyGenerators # Path for all generators extended by '/<generator-id>' options: - generator: CubeMX # for the generator id `CubeMX` use this path path: ./CubeFiles # relative path to generated files and the generator import file name: MyConf # results in generator import file ./CubeFiles/MyConf.cgen.yml map: Boot # Map this project part to the CubeMX run-time context Boot","title":"generators: - options:"},{"location":"YML-Input-Format%20-%20Preinclude/#rte","text":"Allows to control the directory structure for RTE (run-time environment) files. Notes: This control is only possible at *.cproject.yml level. Only relative paths are permitted to support portablity of projects. The location of the *.cproject.yml file is the reference for relative paths. rte: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/RTE . rte: base-dir: $TargetType$/RTE # Path extended with target-type, results in `$ProjectDir()$/$TargetType$/RTE`","title":"rte:"},{"location":"YML-Input-Format%20-%20Preinclude/#toolchain-options","text":"The following code translation options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project","title":"Toolchain Options"},{"location":"YML-Input-Format%20-%20Preinclude/#compiler","text":"Selects the compiler toolchain used for code generation. Optionally the compiler can have a version number specification. Compiler Name Supported Compiler AC6 Arm Compiler version 6 GCC GCC Compiler IAR IAR Compiler CLANG CLANG Compiler based on LLVM technlogy Example: compiler: GCC # Select GCC Compiler compiler: AC6@6.18.0 # Select Arm Compiler version 6","title":"compiler:"},{"location":"YML-Input-Format%20-%20Preinclude/#linker","text":"The linker: node specifies an explicit Linker Script and/or memory regions header file. It can be applied in *.cproject.yml and *.clayer.yml files. Refer to Linker Script Management for detailed information. linker: Content - regions: Optional Path and file name of <regions_file>.h , used to generate a Linker Script. script: Optional Explicit file name of the Linker Script, overrules files provided with file: or components. auto: Optional Request automatic Linker Script generation . define: Optional Define symbol settings for the linker script file preprocessor. for-compiler: Optional Include Linker Script for the specified toolchain. for-context: Optional Include Linker Script for a list of build and target type names. not-for-context: Optional Exclude Linker Script for a list of build and target type names. Notes: The linker: node must have at least regions: , script: , auto: , or define: . If no script: file is specified, compiler specific Linker Script template files are used. A Linker Script file is preprocessed when regions: or a define: is or the file extension is *.src . If both auto: and script: is specified a warning is issued and automatic Linker Script generation is performed and the specified script: is ignored. Examples: linker: - script: MyLinker.scf.src # linker script file regions: MyRegions.h # pre-processed using header file linker: - regions: MyRegions.h # Default linker script is used and pre-processed using header file linker: - script: MyLinker.scf.src # linker script file, not pre-processed for-compiler: AC6 # for Arm Compiler 6 - script: MyLinker.ld # linker script file, not pre-processed for-compiler: CLANG # for CLANG LLVM based compiler linker: - script: MyLinker.scf.src # linker script file for-compiler: AC6 # for Arm Compiler 6 regions: MyRegions.h # pre-processed using header file - script: MyLinker.ld.src # linker script file for-compiler: CLANG # for CLANG LLVM based compiler regions: MyRegions.h # pre-processed using header file define: # with define setting - Setup: 1 # define with value","title":"linker:"},{"location":"YML-Input-Format%20-%20Preinclude/#output","text":"Configure the generated output files. output: Content base-name: Optional Specify a common base name for all output files. type: Optional A list of output types for code generation (see list below). type: Description - lib Library or archive. Note: GCC uses the prefix lib in the base name for archive files. - elf Executable in ELF format. The file extension is toolchain specific. - hex Intel HEX file in HEX-386 format. - bin Binary image. The default setting for output: is: output: base-name: $Project$ # used the base name of the `cproject.yml` file. type: elf # Generate executeable file. Example: output: # configure output files base-name: MyProject # used for all output files, including linker map file. type: - elf # Generate executeable file. - hex # generate a HEX file - bin # generate a BIN file Generate a library : output: # configure output files type: lib # Generate library file.","title":"output:"},{"location":"YML-Input-Format%20-%20Preinclude/#translation-control","text":"The following translation control options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project groups: level to specify options for a specify source file group files: level to specify options for a specify source file Note The keys define: , add-path: , del-path: , and misc: are additive. All other keys can only be defined once at the level of solution: , project: , setup: , layer: , build-types: . or target-types: . However, it is possible to overwrite these keys at the level of group: , file: , or component: , for example it is possible to translate a file group with a different optimize level.","title":"Translation Control"},{"location":"YML-Input-Format%20-%20Preinclude/#language-c","text":"Set the language standard for C source file compilation. Value Select C Language Standard c90 compile C source files as defined in C90 standard (ISO/IEC 9899:1990). gnu90 same as c90 but with additional GNU extensions. c99 (default) compile C source files as defined in C99 standard (ISO/IEC 9899:1999). gnu99 same as c99 but with additional GNU extensions. c11 compile C source files as defined in C11 standard (ISO/IEC 9899:2011). gnu11 same as c11 but with additional GNU extensions.","title":"language-C:"},{"location":"YML-Input-Format%20-%20Preinclude/#language-cpp","text":"Set the language standard for C++ source file compilation. Value Select C++ Language Standard c++98 compile C++ source files as defined in C++98 standard (ISO/IEC 14882:1998). gnu++98 same as c++98 but with additional GNU extensions. c++03 compile C++ source files as defined in C++03 standard (ISO/IEC 14882:2003). gnu++03 same as c++03 but with additional GNU extensions. c++11 compile C++ source files as defined in C++11 standard (ISO/IEC 14882:2011). gnu++11 same as c++11 but with additional GNU extensions. c++14 (default) compile C++ source files as defined in C++14 standard (ISO/IEC 14882:2014). gnu++14 same as c++14 but with additional GNU extensions. c++17 compile C++ source files as defined in C++17 standard (ISO/IEC 14882:2014). gnu++17 same as c++17 but with additional GNU extensions. c++20 compile C++ source files as defined in C++20 standard (ISO/IEC 14882:2020). gnu++20 same as c++20 but with additional GNU extensions.","title":"language-CPP:"},{"location":"YML-Input-Format%20-%20Preinclude/#optimize","text":"Generic optimize levels for code generation. Value Code Generation balanced Balanced optimization size Optimized for code size speed Optimized for execution speed debug Optimize for debug experience none No optimization Note When optimize: is not specified, the default optimize setting of the compiler is used. Example: groups: - group: \"Main File Group\" optimize: none # optimize this file group for debug illusion files: - file: file1a.c - file: file1b.c","title":"optimize:"},{"location":"YML-Input-Format%20-%20Preinclude/#debug","text":"Control the generation of debug information. Value Code Generation on Generate debug information (default) off Generate no debug information Example: build-types: - type: Release optimize: size # optimize for size debug: off # generate no debug information for the release build","title":"debug:"},{"location":"YML-Input-Format%20-%20Preinclude/#warnings","text":"Control warning level for compiler diagnostics. Value Control diagnostic messages (warnings) on Generate warning messages all Enable all compiler warning messages (compiler option -Wall) off No warning messages generated","title":"warnings:"},{"location":"YML-Input-Format%20-%20Preinclude/#define","text":"Contains a list of symbol #define statements that are passed via the command line to the development tools for C, C++ source files, or the linker script file preprocessor. define: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Note: This control only applies to C and C++ source files (or to the linker script preprocessor). For assembler source files use the misc: node. Example: define: # Start a list of define statements - TestValue: 12 # add symbol 'TestValue' with value 12 - TestMode # add symbol 'TestMode'","title":"define:"},{"location":"YML-Input-Format%20-%20Preinclude/#undefine","text":"Remove symbol #define statements from the command line of the development tools. undefine: Content - <symbol-name> Remove #define symbol Examples: groups: - group: \"Main File Group\" undefine: - TestValue # remove define symbol `TestValue` for this file group files: - file: file1a.c undefine: - TestMode # remove define symbol `TestMode` for this file - file: file1b.c","title":"undefine:"},{"location":"YML-Input-Format%20-%20Preinclude/#add-path","text":"Add include paths to the command line of the development tools for C and C++ source files. add-path: Content - <path-name> Named path to be added Note: This control only applies to C and C++ source files. For assembler source files use the misc: node. Example: project: misc: - for-compiler: AC6 C: [-fshort-enums, -fshort-wchar] - for-compiler: GCC C: [-fshort-enums, -fshort-wchar] add-path: - $OutDir(Secure)$ # add path to secure project's output directory","title":"add-path:"},{"location":"YML-Input-Format%20-%20Preinclude/#del-path","text":"Remove include paths (that are defined at the cproject level) from the command line of the development tools. del-paths: Content - <path-name> Named path to be removed; * for all Examle: target-types: - type: CM3 device: ARMCM3 del-paths: - /path/solution/to-be-removed","title":"del-path:"},{"location":"YML-Input-Format%20-%20Preinclude/#pre-include","text":"Note **New in CMSIS-Toolbox 2.5.0; requires cbuild2cmake backend (todo) Add pre-include files to the command line of the development tools for C and C++ source files. pre-include: Content - file: Name of the pre-include file. Examle: groups: - group: MyGroup pre-include: - file: my_include.h","title":"pre-include:"},{"location":"YML-Input-Format%20-%20Preinclude/#misc","text":"Add miscellaneous literal tool-specific controls that are directly passed to the individual tools depending on the file type. misc: Content - for-compiler: Optional Name of the toolchain that the literal control string applies to. C-CPP: Optional Applies to *.c and *.cpp files (added before C and CPP: ). C: Optional Applies to *.c files only. CPP: Optional Applies to *.cpp files only. ASM: Optional Applies to assembler source files only. Link: Optional Applies to the linker (added before Link-C: or Link-CPP: ). Link-C: Optional Applies to the linker; added when no C++ files are part of the project. Link-CPP: Optional Applies to the linker; added when C++ files are part of the project. Library: Optional Applies to the library manager or archiver. Example: build-types: - type: Debug misc: - for-compiler: AC6 C-CPP: - -O1 - -g - for-compiler: GCC C-CPP: - -Og - type: Release compiler: AC6 misc: - C: - -O3 - type: GCC-LibDebug compiler: GCC misc: - Library: - -lm - -lc - -lgcc - -lnosys","title":"misc:"},{"location":"YML-Input-Format%20-%20Preinclude/#project-setups","text":"The setups: node can be used to create setups that are specific to a compiler, target-type, and/or built-type.","title":"Project Setups"},{"location":"YML-Input-Format%20-%20Preinclude/#setups","text":"The setups: node collects a list of setup: notes. For each context, only one setup will be selected. The result is a setup: that collects various toolchain options and that is valid for all files and components in the project. It is however possible to change that setup: settings on a group: or file: level. setups: Content - setup: Required Description of the setup for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. output: Optional Configure the generated output files. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. linker: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. processor: Optional Processor configuration. project: setups: - setup: Arm Compiler 6 project setup for-compiler: AC6 linker: - script: my-project.sct define: - test: 12 - setup: GCC project setup for-compiler: GCC linker: - script: my-project.inc define: - test: 11","title":"setups:"},{"location":"YML-Input-Format%20-%20Preinclude/#pack-selection","text":"The packs: node can be specified in the *.csolution.yml file allows you to: Reduce the scope of software packs that are available for projects. Add specific software packs optional with a version specification. Provide a path to a local installation of a software pack that is for example project specific or under development. The Pack Name Conventions are used to specify the name of the software packs. The pack: definition may be specific to a context that specifies target-types: and/or build-types: or provide a local path to a development repository of a software pack. Notes: By default, the csolution Project Manager only loads the latest version of the installed software packs. It is however possible to request specific versions using the - pack: node. An attempt to add two different versions of the same software pack results in an error.","title":"Pack Selection"},{"location":"YML-Input-Format%20-%20Preinclude/#packs","text":"The packs: node is the start of a pack selection. packs: Content - pack: Explicit pack specification (additive)","title":"packs:"},{"location":"YML-Input-Format%20-%20Preinclude/#pack","text":"The pack: list allows to add specific software packs, optional with a version specification. The version number can have also the format @~1.2 / @~1 that matches with semantic versioning. pack: Content path: Explicit path name that stores the software pack. This can be a relative path to your project workspace. for-context: Include pack for a list of build and target types. not-for-context: Exclude pack for a list of build and target types. Note When an explicit path: to the pack is specified, an explicit pack version cannot be specified as the path directly specifies the pack to include. Example: packs: # start section that specifics software packs - pack: AWS # use packs from AWS - pack: NXP::*K32L* # use packs from NXP relating to K32L series (would match K32L3A60_DFP + FRDM-K32L3A6_BSP) - pack: ARM # use packs from Arm - pack: Keil::Arm_Compiler # add latest version of Keil::Arm_Compiler pack - pack: Keil::MDK-Middleware@7.13.0 # add Keil::MDK-Middleware pack at version 7.13.0 - pack: ARM::CMSIS-FreeRTOS@~10.4 # add CMSIS-FreeRTOS with version 10.4.x - pack: NXP::K32L3A60_DFP # add pack for NXP device path: ./local/NXP/K32L3A60_DFP # with path to the pack (local copy, repo, etc.) - pack: AWS::coreHTTP # add pack path: ./development/AWS/coreHTTP # with path to development source directory for-context: +DevTest # pack is only used for target-type \"DevTest\"","title":"pack:"},{"location":"YML-Input-Format%20-%20Preinclude/#target-selection","text":"","title":"Target Selection"},{"location":"YML-Input-Format%20-%20Preinclude/#board","text":"Specifies a unique board name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings.","title":"board:"},{"location":"YML-Input-Format%20-%20Preinclude/#device","text":"Specifies a unique device name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. A device: is derived from the board: setting, but an explicit device: setting overrules the board: device. If device: specifies a device with a multi-core processor, and no explicit pname for the processor core selection is specified, the default pname of the device is used. At the level of a cproject.yml file, only the pname can be specified as the device itself is selected at the level of a csolution.yml file.","title":"device:"},{"location":"YML-Input-Format%20-%20Preinclude/#processor-attributes","text":"","title":"Processor Attributes"},{"location":"YML-Input-Format%20-%20Preinclude/#processor","text":"The processor: keyword specifies the usage of processor features for this project. processor: Content fpu: Select usage of FPU instructions: dp (double precision) | sp (single precision) | off (disabled). dsp: Select usage of SIMD instructions: on (enabled) | off (disabled). mve: Select usage of M-Profile vector extension: fp (floating point and integer instructions) | int (integer instructions) | off (disabled). trustzone: Select TrustZone mode: secure | non-secure | off . branch-protection: Select Branch Protection mode: bti (branch target identification) | bti-signret (branch target identification and pointer authentication) | off (disabled). The default setting enables the available features of the device. For example fpu: dp is selected for devices that offer double precision floating point hardware. For trustzone: the default setting is: off for devices that support this option, but TrustZone is configurable. non-secure for devices that have TrustZone enabled. Example: project: processor: trustzone: secure fpu: off # do not use FPU instructions mve: off # do not use vector instructions.","title":"processor:"},{"location":"YML-Input-Format%20-%20Preinclude/#context","text":"A context is an enviroment setup for a project that is composed of: project-name that is the base name of the *.cproject.yml file. .build-type that defines typically build specific settings such as for debug, release, or test. +target-type that defines typically target specific settings such as device, board, or usage of processor features. The section Project setup for multiple targets and test builds explains the overall concept of target-types and build-types . These target-types and build-types are defined in the *.csolution.yml that defines the overall application for a system. The settings of the target-types: are processed first; then the settings of the build-types: that potentially overwrite the target-types: settings.","title":"Context"},{"location":"YML-Input-Format%20-%20Preinclude/#target-types","text":"The target-types: node may include toolchain options , target selection , and processor attributes : target-types: Content - type: Required The target-type name that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control Generation of debug information. define: Optional Preprocessor (#define) symbols for code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. board: see Note Board specification. device: see Note Device specification. processor: Optional Processor specific settings. context-map: Optional Use different target-types: for specific projects. variables: Optional Variables that can be used to define project components. Note:: Either device: or board: is required.","title":"target-types:"},{"location":"YML-Input-Format%20-%20Preinclude/#build-types","text":"The build-types: node may include toolchain options : build-types: Content - type: Required The build-type name that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. define: Optional Preprocessor (#define) symbols for code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. context-map: Optional Use different build-types: for specific projects. variables: Optional Variables that can be used to define project components. Example: target-types: - type: Board # target-type name, used in context with: +Board board: NUCLEO-L552ZE-Q # board specifies indirectly also the device - type: Production-HW # target-type name, used in context with: +Production-HW device: STM32L552RC # specifies device build-types: - type: Debug # build-type name, used in context with: .Debug optimize: none # specifies code optimization level debug: debug # generates debug information - type: Test # build-type name, used in context with: .Test optimize: size debug: on The board: , device: , and processor: settings are used to configure the code translation for the toolchain. These settings are processed in the following order: board: relates to a BSP software pack that defines board parameters, including the mounted device . If board: is not specified, a device: must be specified. device: defines the target device. If board: is specified, the device: setting can be used to overwrite the device or specify the processor core used. processor: overwrites default settings for code generation, such as endianess, TrustZone mode, or disable Floating Point code generation. Examples: target-types: - type: Production-HW board: NUCLEO-L552ZE-Q # hardware is similar to a board (to use related software layers) device: STM32L552RC # but uses a slightly different device processor: trustzone: off # TrustZone disabled for this project target-types: - type: Production-HW board: FRDM-K32L3A6 # NXP board with K32L3A6 device device: :cm0plus # use the Cortex-M0+ processor","title":"build-types:"},{"location":"YML-Input-Format%20-%20Preinclude/#context-map","text":"The context-map: node allows for a specific project-name the remapping of target-types: and/or build-types: to a different context: which enables: Integrating an existing *.cproject.yml file in a different *.csolution.yml file that uses different build-types: and/or target-types: for the overall application. Defines how different *.cproject.yml files of a *.csolution.yml are to the binary image of the final target (needs reflection in cbuild-idx.yml). The context-map: node lists a remapping of the context-name for a project-name and specific target-types: and build-types: . context-map: Content - <context-name> Required Specify an alternative context-name for a project. For the context-map: it is required to specify the <project-name> as part of the context-name . This project will use a different .build-type and/or +target-type as applied in the context-name . This remapping of the context applies for the specific type in the build-types: or target-types: list. Example 1: This application combines two projects for a multi-processor device, but the project HelloCM7 requires a different setting for the build-type name Release as this enables different settings within the *.cproject.yml file. target-types: - type: DualCore device: MyDualCoreDevice build-types: - type: Release # When applying build-type name 'release': context-map: - HelloCM7.flex_release # project HelloCM7 uses build-type name \"flex_release\" instead of \"release\" projects: - project: ./CM7/HelloCM7.cproject.yml - project: ./CM4/HelloCM4.cproject.yml Example 2: The following example uses three projects Demo , TFM and Boot . The project TFM should be always build using the context TFM.Release+LibMode . For the target-type name Board , the Boot project requires the +Flash target, but any build-type could be used. target-types: - type: Board # When applying target-type: 'Board': context-map: - TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode - Boot+Flash # for project Boot use target-type: Flash board: B-U585I-IOT02A - type: AVH # When applying target-type: 'AVH': context-map: - context: TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode device: ARM::SSE-300-MPS3 projects: - project: ./App/Demo.cproject.yml - project: ./Security/TFM.cproject.yml - project: ./Loader/Boot.cproject.yml","title":"context-map:"},{"location":"YML-Input-Format%20-%20Preinclude/#conditional-build","text":"It is possible to include or exclude items of a list node in the build process. for-compiler: includes items only for a compiler toolchain. for-context: includes items only for a context list. not-for-context: excludes items for a context list. Note for-context and not-for-context are mutually exclusive, only one occurrence can be specified for a list node .","title":"Conditional Build"},{"location":"YML-Input-Format%20-%20Preinclude/#for-compiler","text":"Depending on a compiler toolchain it is possible to include list nodes in the build process. Examples: for-compiler: AC6@6.16 # add item for Arm Compiler version 6.16 only for-compiler: GCC # for GCC Compiler (any version)","title":"for-compiler:"},{"location":"YML-Input-Format%20-%20Preinclude/#for-context","text":"A context list that adds a list-node for specific target-type and/or build-type names.","title":"for-context:"},{"location":"YML-Input-Format%20-%20Preinclude/#not-for-context","text":"A context list that removes a list-node for specific target-types: and/or build-types: .","title":"not-for-context:"},{"location":"YML-Input-Format%20-%20Preinclude/#context-list","text":"It is also possible to provide a context list with: - [.build-type][+target-type] - [.build-type][+target-type] Examples: for-context: - .Test # add item for build-type: Test (any target-type) for-context: # add item - .Debug # for build-type: Debug and - .Release+Production-HW # build-type: Release / target-type: Production-HW not-for-context: +Virtual # remove item for target-type: Virtual (any build-type) not-for-context: .Release+Virtual # remove item for build-type: Release with target-type: Virtual","title":"Context List"},{"location":"YML-Input-Format%20-%20Preinclude/#usage","text":"The keyword for-context: and not-for-context: can be applied to the following list nodes : List Node Description - project: At projects: level it is possible to control inclusion of project. - layer: At layers: level it is possible to control inclusion of a software layer. The keyword for-context: , not-for-context: , and for-compiler: can be applied to the following list nodes : List Node Description - component: At components: level it is possible to control inclusion of a software component. - group: At groups: level it is possible to control inclusion of a file group. - setup: At setups: level it is define toolchain specific options that apply to the whole project. - file: At files: level it is possible to control inclusion of a file. The inclusion of a list node is processed for a given project context respecting its hierarchy from top to bottom: project --> layer --> component / group --> file In other words, the restrictions specified by for-context: or not-for-context for a list node are automatically applied to its children nodes. Children list nodes inherit the restrictions from their parent.","title":"Usage"},{"location":"YML-Input-Format%20-%20Preinclude/#multiple-projects","text":"The section Project setup for related projects describes the organization of multiple projects. The file *.csolution.yml describes the relationship of this projects and may also re-map target-types: and build-types: for this projects using context-map: .","title":"Multiple Projects"},{"location":"YML-Input-Format%20-%20Preinclude/#projects","text":"The YAML structure of the section projects: is: projects: Content - project: Required Path to the project file. for-context: Optional Include project for a list of build and target types. not-for-context: Optional Exclude project for a list of build and target types. Examples: This example uses two projects that are build in parallel using the same build-type: and target-type: . Such a setup is typical for multi-processor systems. projects: - project: ./CM0/CM0.cproject.yml # include project for Cortex-M0 processor - project: ./CM4/CM4.cproject.yml # include project for Cortex-M4 processor This example uses multiple projects, but with additional controls. projects: - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # build only when 'target-type: CM0-Addon' is selected for-compiler: GCC # build only when 'compiler: GCC' is selected define: # add additional defines during build process - test: 12 - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # specify use case for-compiler: AC6 # build only when 'compiler: AC6' is selected define: # add additional defines during build process - test: 9 - project: ./Debug/Debug.cproject.yml # specify cproject.yml file not-for-context: .Release # generated for any 'build-type:' except 'Release'","title":"projects:"},{"location":"YML-Input-Format%20-%20Preinclude/#source-file-management","text":"Keyword Used in files Description groups: *.cproject.yml , *.clayer.yml Start of a list that adds source groups and files to a project or layer. layers: *.cproject.yml Start of a list that adds software layers to a project. components: *.cproject.yml , *.clayer.yml Start of a list that adds software components to a project or layer.","title":"Source File Management"},{"location":"YML-Input-Format%20-%20Preinclude/#groups","text":"The groups: keyword specifies a list that adds source groups and files to a project or layer: groups: Content - group: Required Name of the group. for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. groups: Optional Start a nested list of groups. files: Optional Start a list of files. Example: See files: section.","title":"groups:"},{"location":"YML-Input-Format%20-%20Preinclude/#files","text":"Add source files to a project. files: Content - file: Required Name of the file. for-context: Optional Include file for a list of build and target types. not-for-context: Optional Exclude file for a list of build and target types. for-compiler: Optional Include file for a list of compilers. category: Optional Explicit file category to overwrite filename extension assignment. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. Note It is also possible to specify a Linker Script . Files with the extension .sct , .scf , .ld , and .icf are recognized as Linker Script files. Example: Add source files to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. groups: - group: \"Main File Group\" not-for-context: # includes this group not for the following: - .Release+Virtual # build-type 'Release' and target-type 'Virtual' - .Test-DSP+Virtual # build-type 'Test-DSP' and target-type 'Virtual' - +Board # target-type 'Board' files: - file: file1a.c - file: file1b.c define: - a: 1 undefine: - b optimize: size - group: \"Other File Group\" files: - file: file2a.c for-context: +Virtual # include this file only for target-type 'Virtual' define: - test: 2 - file: file2a.c not-for-context: +Virtual # include this file not for target-type 'Virtual' - file: file2b.c - group: \"Nested Group\" groups: - group: Subgroup1 files: - file: file-sub1-1.c - file: file-sub1-2.c - group: Subgroup2 files: - file: file-sub2-1.c - file: file-sub2-2.c It is also possible to include a file group for a specific compiler using for-compiler: or a specific target-type and/or build-type using for-context: or not-for-context: . groups: - group: \"Main File Group\" for-compiler: AC6 # includes this group only for Arm Compiler 6 files: - file: file1a.c - file: file2a.c - group: \"Main File Group\" for-compiler: GCC # includes this group only for GCC Compiler files: - file: file1b.c - file: file2b.c","title":"files:"},{"location":"YML-Input-Format%20-%20Preinclude/#layers","text":"Add a software layer to a project. Used in *.cproject.yml files. layers: Content - layer: Optional Path to the *.clayer.yml file that defines the layer. type: Optional Refers to an expected layer type. for-context: Optional Include layer for a list of build and target types. not-for-context: Optional Exclude layer for a list of build and target types. Example: layers: # Socket - layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml for-context: - +IP-Stack - layer: ./Socket/WiFi/Socket.clayer.yml for-context: - +WiFi - layer: ./Socket/VSocket/Socket.clayer.yml for-context: - +AVH # Board - layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml for-context: - +IP-Stack # - +WiFi - layer: ./Board/B-U585I-IOT02A/Board.clayer.yml for-context: - +WiFi - layer: ./Board/AVH_MPS3_Corstone-300/Board.clayer.yml for-context: - +AVH","title":"layers:"},{"location":"YML-Input-Format%20-%20Preinclude/#layer-type","text":"The layer: - type: is used in combination with the meta-data of the connections: to check the list of available *.clayer.yml files for matching layers. Instead of an explicit layer: node that specifies a *.clayer.yml file, the type: is used to search for matching layers with the csolution command list layers . Example: layers: - type: Socket # search for matching layers of type `Socket` - type: Board # search for matching layers of type `Board` When combined with variables: it is possible to define the required *.clayer.yml files at the level of the *.csolution.yml file. Refer to variables: for an example.","title":"layer: - type:"},{"location":"YML-Input-Format%20-%20Preinclude/#components","text":"Add software components to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. components: Content - component: Required Name of the software component. for-context: Optional Include component for a list of build and target types. not-for-context: Optional Exclude component for a list of build and target types. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. pre-include: Optional Add pre-include files for C and C++ source files. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. instances: Optional Add multiple instances of component configuration files (default: 1) Example: components: - component: ARM::CMSIS:RTOS2:FreeRTOS&Cortex-M - component: ARM::RTOS&FreeRTOS:Config&CMSIS RTOS2 - component: ARM::RTOS&FreeRTOS:Core&Cortex-M - component: ARM::RTOS&FreeRTOS:Event Groups - component: ARM::RTOS&FreeRTOS:Heap&Heap_5 - component: ARM::RTOS&FreeRTOS:Stream Buffer - component: ARM::RTOS&FreeRTOS:Timers - component: ARM::Security:mbed TLS define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" - component: AWS::FreeRTOS:backoffAlgorithm - component: AWS::FreeRTOS:coreMQTT - component: AWS::FreeRTOS:coreMQTT Agent - component: AWS::FreeRTOS:corePKCS11&Custom define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" Note The name format for a software component is described under Name Conventions - Component Name Conventions .","title":"components:"},{"location":"YML-Input-Format%20-%20Preinclude/#instances","text":"Allows to add multiple instances of a component and actually applies to configuration files. For detailed description refer to Open-CMSIS-Pack specification - Component Instances Example: components: - component: USB:Device instances: 2 If the user selects multiple instances of the same component, all files with attribute config in the *.PDSC file will be copied multiple times to the project. The name of the component (for example config_mylib.h) will get a postfix _n whereby n is the instance number starting with 0. Instance 0: config_usb_device_0.h Instance 1: config_usb_device_1.h The availability of instances in a project can be made public in the RTE_Components.h file. The existing way to extend the %Instance% with the instance number n .","title":"instances:"},{"location":"YML-Input-Format%20-%20Preinclude/#prepost-build-steps","text":"The CMSIS-Toolbox supports pre-build and post-build steps that utilize external tools or scripts. Such external commands can be used for various tasks such as: pre-process source files. add checksums to a binary file. combine multiple ELF files into a single image. add a timestamp to an image ( always: ensures execution in every build). sign images for a boot laoder.","title":"Pre/Post build steps"},{"location":"YML-Input-Format%20-%20Preinclude/#executes","text":"Execute and external command for pre or post build steps used in *.csolution.yml and *.cproject.yml files. The input: and output: files are used for dependency checking and schedule the execution (as pre-build or post-build step) during the build process. The structure of the executes: node is: executes: Content - execute: Required Description of the build step. run: Required Command string with name of the program or script (optionally with path) along with argument string. always: Optional When present, the build step always runs and bypasses check for outdated output: files. input: Optional A list of input files (may contain Access Sequences ). output: Optional A list of output files (may contain Access Sequences ). for-context: Optional Run command for a list of build and target types (only supported in *.cproject.yml ). not-for-context: Optional Exclude run command for a list of build and target types (only supported in *.cproject.yml ). The run: command string uses these sequences to access input files and output files: run: command file access Description $input$ Comma separated list of all input files. $input(<n>)$ Input file in the list with index <n> ; first item is <n>=0 . $output$ Comma separated list of all output files. $output(<n>)$ Output file in the list with index <n> ; first item is <n>=0 . Examples: solution: # executed as part of a project build executes: - execute: Generate Download Image run: gen_image $input$ -o $output$ --sign # Command line string input: - $elf(Application)$ # combine these project parts - $elf(TFM)$ - $elf(Bootloader)$ output: - $SolutionDir$/$Solution$.out # output file name project: # executed as part of a project build executes: - execute: Generate Encryption Keys run: KeyGen $input$ -o $output$ always: # always generate the keyfile.c as it contains a timestamp input: keyfile.txt # contains the key in text format output: keyfile.c # output as C source file that is part of this project solution: # executed as part of a solution build executes: # uses a CMake script - execute: Archive Artifacts run: ${CMAKE_COMMAND} -DINPUT=$input$ -DOUTPUT=$output$ -P $input(0)$ always: input: - script/archive.cmake - $elf(project.Release+ARMCM0)$ - $elf(project.Release+ARMCM0)$.signed - $elf(bootloader.Release+ARMCM0)$ output: - $SolutionDir()$/artifacts.zip project: # executed as part of a project build executes: # uses a CMake script - execute: Sign ELF Image run: ${CMAKE_COMMAND} -DINPUT=$input(1)$ -DOUTPUT=$output$ -P $input(0)$ input: - $SolutionDir()$/script/sign.cmake #CMake script - $elf()$ # ELF file generated by project output: - $elf()$.signed for-context: # only for build-type: Release - .Release","title":"executes:"},{"location":"YML-Input-Format%20-%20Preinclude/#connections","text":"The connections: node contains meta-data that describes the compatiblity of *.cproject.yml and *.clayer.yml project parts. The connections: node lists functionality (drivers, pins, and other software or hardware resources). The node consumes: lists required functionality; the node provides: is the implemented functionality of that project part. This enables reference applications that work across a range of different hardware targets where: The *.cproject.yml file of the reference application lists with the connections: node the required functionality with consumes: . The *.clayer.yml project part lists with the connections: node the implemented functionality with provides: . This works across multiple levels, which means that a *.clayer.yml file could also require other functionality using consumes: . The connections: node is used to identify compatible software layers. These software layers could be stored in CMSIS software packs using the following structure: A reference application described in a *.cproject.yml file could be provided in a git repository. This reference application uses software layers that are provided in CMSIS software packs. A CMSIS Board Support Pack (BSP) contains a configured board layer desribed in a *.clayer.yml file. This software layer is pre-configured for a range of use-cases and provides drivers for I2C and SPI interfaces along with pin definitions and provisions for an Ardunio shield. For a sensor, a CMSIS software pack contains the sensor middleware and software layer ( *.clayer.yml ) that describes the hardware of the Ardunio sensor shield. This shield can be applied to many different hardware boards that provide an Ardunio shield connector. This connections: node enables therefore software reuse in multiple ways: The board layer can be used by many different reference applications, as the provided: functionlity enables a wide range of use cases. The sensor hardware shield along with the middleware can be used across many different boards that provide an Ardunio shield connector along with board layer support. The structure of the connections: node is: connections: Description - connect: Required Lists specific functionality with a brief verbal description","title":"connections:"},{"location":"YML-Input-Format%20-%20Preinclude/#connect","text":"The connect: node describes one or more functionalities that belong together. connect: Description set: Optional Specifies a config-id . select value that identifies a configuration option info: Optional Verbal desription displayed when this connect is selected provides: Optional List of functionality ( key / value pairs) that are provided consumes: Optional List of functionality ( key / value pairs) that are required","title":"connect:"},{"location":"YML-Input-Format%20-%20Preinclude/#set","text":"Some hardware boards have configuration settings (DIP switch or jumper) that configure interfaces. These settings have impact to the functionality (for example hardware interfaces). With set: config-id . select the possible configration options are considered when evaluating compatible *.cproject.yml and *.clayer.yml project parts. The csolution Project Manager iterates the connect: node with a set: config-id . select as described below: For each config-id only one connect: node with a select value is active at a time. Each possible select value is checked for a matching configuration. When project parts have a matching configuration, the set: value along with the info: is shown to the user. This allows the user to enable the correct hardware options. Refer to Example: Sensor Shield for a usage example.","title":"set:"},{"location":"YML-Input-Format%20-%20Preinclude/#provides","text":"A user-defined key / value pair list of functionality that is implemented or provided by a project: or layer: . The csolution Project Manager combines all the key / value pairs that listed under provides: and matches it with the key / value pairs that are listed under consumes: . For key / value pairs listed under provides: the following rules exist for a match with consumes: key / value pair: It is possible to omit the value . It matches with an identical key listed in consumes: A value is interpreted as number. Depending on the value prefix, this number must be: when consumes: value is a plain number, identical with this value. when consumes: value is prefixed with + , higher or equal then this value or the sum of all values in multiple consumes: nodes.","title":"provides:"},{"location":"YML-Input-Format%20-%20Preinclude/#consumes","text":"A user-defined key / value pair list of functionality that is requried or consumed by a project: or layer: . For key / value pairs listed under consumed: the following rules exist: When no value is specified, it matches with any value of an identical key listed under provides: . A value is interpreted as number. This number must be identical in the provides: value pair. A value that is prefixed with + is interpreted as a number that is added together in case that the same key is listed multiple times under consumes: . The sum of this value must be lower or equal to the value upper limit of the provides: key .","title":"consumes:"},{"location":"YML-Input-Format%20-%20Preinclude/#example-board","text":"This connections: node of a board layer describes the available interfaces. The WiFi interface requires a CMSIS-RTOS2 function. connections: # describes functionality of a board layer - connect: WiFi interface provides: - CMSIS-Driver WiFi: requires: - CMSIS-RTOS2: - connect: SPI and UART interface provides: - CMSIS-Driver SPI: - CMSIS-Driver UART:","title":"Example: Board"},{"location":"YML-Input-Format%20-%20Preinclude/#example-simple-project","text":"This shows a the connections: node of a complete application project that is composed of two software layers. MyProject.cproject.yml connections: - connect: all resources provides: - RTOS2: # implements RTOS2 API interface consumes: - IoT_Socket: # requires IoT_Socket interface - STDOUT: # requires STDOUT interface - Heap: +30000 # requires additional 30000 bytes memory heap : layers: - layer: MySocket.clayer.yml - layer: MyBoard.clayer.yml MySocket.clayer.yml connections: - connect: consumes: - RTOS2: # requires RTOS2 API interface - VSocket: # requires VSocket interface - Heap: +20000 # requires additional 20000 bytes memory heap provides: - IoT_Socket: # provides IoT_Socket interface MyBoard.clayer.yml connections: - connect: consumes: - RTOS2: provides: - VSocket: - STDOUT: - Heap: 65536","title":"Example: Simple Project"},{"location":"YML-Input-Format%20-%20Preinclude/#example-sensor-shield","text":"This sensor shield layer provides a set of interfaces that are configurable. connections: - connect: I2C Interface 'Std' set: comm.I2C-Std info: JP1=Off JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C: - connect: I2C Interface 'Alt' set: comm.I2C-Alt info: JP1=On JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C-Alt: - connect: SPI Interface 'Alt' set: comm.SPI info: JP2=On provides: - Sensor_SPI: consumes: - Ardunio_Uno_SPI: - connect: Sensor Interrupt INT0 set: SensorIRQ.0 info: JP3=Off provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D2: - connect: Sensor Interrupt INT1 set: SensorIRQ.1 info: JP3=On provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D3:","title":"Example: Sensor Shield"},{"location":"YML-Input-Format/","text":"CMSIS Solution Project File Format The following chapter explains the CMSIS Solution Project File Format (short form csolution project files ), the YAML files that describe the software of an embedded application. Name Conventions Filename Extensions The csolution Project Manager recognizes the categories of files based on the filename extension in the YAML input files as shown in the table below. File Extension Category Description .c , .C sourceC C source file .cpp , .c++ , .C++ , .cxx , .cc , .CC sourceCpp C++ source file .h , .hpp header Header file .asm , .s , .S sourceAsm Assembly source file .ld , .scf , .sct , .icf linkerScript Linker Script file .a , .lib library Library file .o object Object file .txt , .md , .pdf , .htm , .html doc Documentation .scvd other Software Component View Description for CMSIS-View pack: Name Conventions The csolution Project Manager uses the following syntax to specify the pack: names in the *.yml files. [vendor ::] pack-name [@version] # If specified, with exact version [vendor ::] pack-name [@>=version] # If specified, with version equal or higher [vendor ::] pack-name [@^version] # If specified, with version equal or higher but same major version [vendor ::] pack-name [@~version] # If specified, with version equal or higher but same major and minor version Element Description vendor Optional Vendor name of the software pack. pack-name Required Name of the software pack; wildcards (*, ?) can be used. @version Optional Software pack version number must exactly match, i.e. @1.2.3 @>=version Optional Automatically update to any version higher or equal. @^version Optional Automatically update minor/patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 2.0.0 . @~version Optional Automatically update patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 1.3.0 . Notes: When no version is specified, the csolution Project Manager only loads the latests installed version of a software pack. This also applies when wildcards are used in the pack-name . Use cpackget to download and install new pack versions. Examples: - pack: ARM::CMSIS@5.9.0 # 'CMSIS' Pack (with version 5.5.0) - pack: MDK-Middleware@>=7.13.0 # 'MDK-Middleware` latest installed version 7.13.0 or higher - pack: MDK-Middleware@^7.13.0 # 'MDK-Middleware' latest installed version 7.13.0 or higher but lower then 8.0.0 - pack: Keil::TFM # 'TFM' Software Pack from vendor Keil, latest installed version - pack: AWS # All latest versions of Software Packs from vendor 'AWS' - pack: Keil::STM* # All latest versions of Software Packs that start with 'STM' from vendor 'Keil' - pack: MDK-Middleware@>=8.0.0-0 # `MDK-Middleware` version 8.0.0 or higher including development versions component: Name Conventions The csolution Project Manager uses the following syntax to specify the component: names in the *.yml files. [Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[>=]Cversion] Components are defined using the Open-CMSIS-Pack - <component> element . Several parts of a component are optional. For example it is possible to just define a component using Cclass and Cgroup name. All elements of a component name are summarized in the following table. Element Description Cvendor Optional Name of the component vendor as defined in <components> element or by the package vendor of the software pack. Cclass Required Component class name as defined in <components> element of the software pack. Cbundle Optional Bundle name of the component class as defined in <bundle> element of the software pack. Cgroup Required Component group name as defined in <components> element of the software pack. Csub Optional Component sub-group name as defined in <components> element of the software pack. Cvariant Optional Component sub-group name as defined in <components> element of the software pack. Cversion Optional Version number of the component, with @1.2.3 that must exactly match, or @>=1.2.3 that allows any version higher or equal. Partly defined components A component can be partly defined in csolution project files ( *.cproject.yml , *.clayer.yml , *.genlayer.yml ) by omitting Cvendor , Cvariant , and Cversion , even when this are part of the components element of the software pack. The component select algorithm resolves this to a fully defined component by: when a partly specified component resolves to several possible choices, the tool selects: (a) the default Cvariant of the component as defined in the PDSC file. (b) the component with the higher Cversion value. (c) and error message is issued when two identical components are defined by multiple vendors and Cvendor is not specified. the partly specified component is extended by: version information from the software pack. default variant definition from the software pack. The fully resolved component name is shown in the *.cbuild.yml output file. Multiple component definitions are rejected If a component is added more then once in the csolution project files and an error is issued. An attempt to select multiple variants (using Cvariant ) of a component results in an error . Examples: - component: CMSIS:CORE # CMSIS Core component (vendor selected by `csolution` ARM) - component: ARM::CMSIS:CORE # CMSIS Core component from vendor ARM (any version) - component: ARM::CMSIS:CORE@5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0) - component: ARM::CMSIS:CORE@>=5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0 or higher) - component: Device:Startup # Device Startup component from any vendor - component: CMSIS:RTOS2:Keil RTX5 # CMSIS RTOS2 Keil RTX5 component with default variant (any version) - component: ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3 # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3 - component: Keil::USB&MDK-Pro:CORE&Release@6.15.1 # USB CORE component from bundle MDK-Pro in variant 'Release' and version 6.15.1 device: Name Conventions The device specifies multiple attributes about the target that ranges from the processor architecture to Flash algorithms used for device programming. The following syntax is used to specify a device: value in the *.yml files. [ [ Dvendor:: ] Dname] [:Pname] Element Description Dvendor Optional Name (without enum field) of the device vendor defined in <devices><family> element of the software pack. Dname Optional Device name (Dname attribute) or when used the variant name (Dvariant attribute) as defined in the \\<devices> element. Pname Optional Processor identifier (Pname attribute) as defined in the <devices> element. Note All elements of a device name are optional which allows to supply additional information, such as the :Pname at different stages of the project. However the Dname itself is a mandatory element and must be specified in context of the various project files. Dvendor:: must be used in combination with the Dname . Examples: device: NXP::LPC1768 # The LPC1788 device from NXP device: LPC1788 # The LPC1788 device (vendor is evaluated from DFP) device: LPC55S69JEV98 # Device name (exact name as defined in the DFP) device: LPC55S69JEV98:cm33_core0 # Device name (exact name as defined in the DFP) with Pname specified device: :cm33_core0 # Pname added to a previously defined device name (or a device derived from a board) board: Name Conventions Evaluation Boards define indirectly a device via the related BSP. The following syntax is used to specify a board: value in the *.yml files. [vendor::] board_name [:revision] Element Description vendor Optional Name of the board vendor defined in <boards><board> element of the board support pack (BSP). Bname Required Board name (name attribute) as defined in the \\<board> element of the BSP. revision Optional Board revision (revision attribute) as defined in the \\<board> element of the BSP. Note When a board: is specified, the device: specification can be omitted, however it is possible to overwrite the device setting in the BSP with an explicit device: setting. Examples: board: Keil::MCB54110 # The Keil MCB54110 board (with device NXP::LPC54114J256BD64) board: LPCXpresso55S28 # The LPCXpresso55S28 board board: STMicroelectronics::NUCLEO-L476RG:Rev.C # A board with revision specification context: Name Conventions A context: name combines project-name , built-type , and target-type and is used on various places in the CMSIS-Toolbox. The following syntax is used to specify a context: name. [project-name][.build-type][+target-type] Element Description project-name Optional Project name of a project (base name of the *.cproject.yml file). .build-type Optional The build-type name that is currently processed (specified with - type: name ). +target-type Optional The target-type name that is currently processed (specified with - type: name ). Note The .build-type and +target-type name allows letters (A-Z, a-z), digits (0-9), dash ('-'), and underscore ('_'); the maximum length is 32 characters. When project-name is omitted, the project-name is the base name of the *.cproject.yml file. When .build-type is omitted, it matches with any possible .build-type . When +target-type is omitted, it matches with any possible +target-type . By default, the specified - type: name of build-types: and target-types: nodes in the *.csolution.yml file are directly mapped to the context name. Using the context-map: node it is possible to assign a different .build-type and/or +target-type mapping for a specific project-name . Example: Show the different possible context settings of a *.csolution.yml file. AWS_MQTT_MutualAuth_SW_Framework>csolution list contexts -s Demo.csolution.yml Demo.Debug+AVH Demo.Debug+IP-Stack Demo.Debug+WiFi Demo.Release+AVH Demo.Release+IP-Stack Demo.Release+WiFi The context name is also used in for-context: and not-for-context: nodes that allow to include or exclude items depending on the context . In many cases the project-name can be omitted as the context name is within a specific *.cproject.yml file or applied to a specific *.cproject.yml file. Access Sequences The access sequences export values from the CMSIS Project Manager for the *.yml file nodes define: , define-asm: , add-path: , misc: , files: , and executes: . The access sequences can specify a different project and describe therefore project dependencies. Access Sequence Description Target Access to target and build related settings $Bname$ Bname of the selected board as specified in the board: node. $Dname$ Dname of the selected device as specified in the device: node. $Pname$ Pname of the selected device as specified in the device: node. $BuildType$ Build-type name of the currently processed project. $TargetType$ Target-type name of the currently processed project. $Compiler$ Compiler name of the compiler used in this project context as specified in the compiler: node. YML Input Access to YML Input Directories and Files $Solution$ Solution name (base name of the *.csolution.yml file). $SolutionDir()$ Path to the directory of the current processed csolution.yml file. $Project$ Project name of the current processed cproject.yml file. $ProjectDir(context)$ Path to the directory of a related cproject.yml file. Output Access to Output Directories and Files $OutDir(context)$ Path to the output directory of a related project that is defined in the *.csolution.yml file. $bin(context)$ Path and filename of the binary output file generated by the related context. $cmse-lib(context)$ Path and filename of the object file with secure gateways of a TrustZone application generated by the related context. $elf(context)$ Path and filename of the ELF/DWARF output file generated by the related context. $hex(context)$ Path and filename of the HEX output file generated by the related context. $lib(context)$ Path and filename of the library file of the related context. Pack Access to Pack Directories and Files $Bpack$ Path to the pack that defines the selected board (BSP). $Dpack$ Path to the pack that defines the selected device (DFP). $Pack(vendor::name)$ Path to a specific pack. Example: $Pack(NXP::K32L3A60_DFP)$ . For a context the project-name , .build-type , and +target-type are optional. An access sequence that specifies only project-name uses the context that is currently processed. It is important that the project is part of the context-set in the build process. Example: $ProjectDir()$ is the directory of the current processed cproject.yml file. Example: This example uses the following build-type , target-type , and projects definitions. solution: target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q # specifies board - type: Production-HW # target-type: Production-HW device: STM32L5X # specifies device build-types: - type: Debug # build-type: Debug optimize: none debug: on - type: Release # build-type: Release optimize: size projects: - project: ./bootloader/Bootloader.cproject.yml # relative path - project: /MyDevelopmentTree/security/TFM.cproject.yml # absolute path - project: ./application/MQTT_AWS.cproject.yml # relative path The project: /application/MQTT_AWS.cproject.yml may use access sequences to reference files or directories in other projects that belong to the same csolution project . For example, these references are possible in the file MQTT_AWS.cproject.yml . files: - file: $cmse-lib(TFM)$ # use symbol output file of TFM Project The example above uses the build-type and target-type of the processed context for the project TFM . With a context-set you may mix different build-types for an application. Note that it is important to build both projects in the same build process. cbuild iot-product.csolution.yml --context-set --context TFM.Release+Board --context MQTT_AWS.Debug+Board The example below uses from the TFM project always build-type: Debug and the target-type: Production-HW . files: - file: `$cmse-lib(TFM.Release+Production-HW)$` # use symbol output file of TFM Project The example below uses the build-type: Debug and the target-type of the current processed context is used. executes: - execute: GenImage run: gen_image %input% -o %output% input: - $elf(TFM.Debug)$ - $elf(Bootloader.Release)$ output: - $OutDir(TFM.Debug)$ The example below creates a define that uses the device name. groups: - group: \"Main File Group\" define: - $Dname$ # Generate a #define 'device-name' for this file group Variables The variables: node defines are key/value pairs that can be used to refer to *.clayer.yml files. The key is the name of the variable and can be used in the following nodes: layers: , define: , define-asm: , add-path: , add-path-asm: , misc: , files: , and executes: Using variables that are defined in the *.csolution.yml file, a *.cproject.yml file requires no modifications when new target-types: are introduced. The required layers: could be instead specified in the *.csolution.yml file using a new node variables: . Example: Example.csolution.yml solution: target-types: - type: NXP Board board: IMXRT1050-EVKB variables: - Socket-Layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml - Board-Layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml - type: ST Board board: B-U585I-IOT02A variables: - Socket-Layer: ./Socket/WiFi/Socket.clayer.yml - Board-Layer: ./Board/B-U585I-IOT02A/Board.clayer.yml Example.cproject.yml layers: - layer: $Socket-Layer$ type: Socket - layer: $Board-Layer$ # no `*.clayer.yml` specified. Compatible layers are listed type: Board # layer of type `Board` is expected Order of List Nodes The key / value pairs in a list node can be in any order. The two following list nodes are logically identical. This might be confusing for yml files that are generated by an IDE. build-types: - type: Release # build-type name optimize: size # optimize for size debug: off # generate no debug information for the release build build-types: - debug: off # generate no debug information for the release build optimize: size # optimize for size type: Release # build-type name Project File Structure The table below explains the top-level elements in each of the different *.yml input files that define the overall application. Keyword Description default: Start of cdefault.yml file that is used to setup the compiler along with some compiler-specific controls. solution: Start of *.csolution.yml file that collects related projects along with build-types: and target-types: . project: Start of *.cproject.yml file that defines files, components, and layers which can be independently translated to a binary image or library. layer: Start of *.clayer.yml file that contains pre-configured software components along with source files. cdefault: When cdefault: is specified in the *.csolution.yml file, the csolution Project Manager uses a file with the name cdefault.yml to setup the compiler with specific default controls. The search order for this file is: A cdefault.yml file in the same directory as the <solution-name>.csolution.yml file. A cdefault.yml file in the directory specified by the environment variable CMSIS_COMPILER_ROOT . A cdefault.yml file in the directory <cmsis-toolbox-installation-dir>/etc . The default: node is the start of a cdefault.yml file and contains the following. default: Content misc: Optional Literal tool-specific controls. Refer to Build Overview - cdefault.yml for an example. Note The compiler: selection in cdefault.yml has been deprecated in CMSIS-Toolbox 2.6.0. solution: The solution: node is the start of a *.csolution.yml file that collects related projects as described in the section \"Project setup for related projects\" . solution: Content created-by: Optional Identifies the tool that created this solution. created-for: Optional Specifies the tool for building this solution, i.e. CMSIS-Toolbox@2.5.0 description: Optional Brief description text of this solution. select-compiler: Optional Lists the possible compiler selection that this project is tested with. cdefault: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. compiler: Optional Overall toolchain selection for this solution. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. output-dirs: Optional Control the output directories for the build output. generators: Optional Control the directory structure for generator output. packs: Optional Defines local packs and/or scope of packs that are used. target-types: Required List of target-types that define the target system (device or board). build-types: Optional List of build-types (i.e. Release, Debug, Test). projects: Required List of projects that belong to the solution. executes: Optional Additional pre or post build steps using external tools. Example: solution: created-for: cmsis-toolbox@2.0 # minimum CMSIS-Toolbox version required for project build cdefault: # use default setup of toolchain specific controls. compiler: GCC # overwrite compiler definition in 'cdefaults.yml' packs: - pack: ST # add ST packs in 'cdefaults.yml' build-types: # additional build types - type: Test # build-type: Test optimize: none debug: on packs: # with explicit pack specification - pack: ST::TestSW path: ./MyDev/TestSW target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device projects: - project: ./blinky/Bootloader.cproject.yml - project: /security/TFM.cproject.yml - project: /application/MQTT_AWS.cproject.yml project: The project: node is the start of a *.cproject.yml file and can contain the following: project: Content description: Optional Brief description text of this project. output: Optional Configure the generated output files. generators: Optional Control the directory structure for generator output. rte: Optional Control the directory structure for RTE (run-time environment) files. packs: Optional Defines packs that are required for this project. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. linker: Optional Instructions for the linker. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Specify processor core. processor: Optional Processor specific settings. setups: Optional Configurations specific to a compiler, target-type, and/or built-type. groups: Required List of source file groups along with source files. components: Optional List of software components used. layers: Optional List of software layers that belong to the project. connections: Optional List of consumed and provided resources. executes: Optional Additional pre or post build steps using external tools. Example: project: misc: - compiler: AC6 # specify misc controls for Arm Compiler 6 C: [-fshort-enums, -fshort-wchar] # set options for C files add-path: - $OutDir(Secure)$ # add the path to the secure project's output directory components: - component: Startup # Add startup component - component: CMSIS CORE - component: Keil RTX5 Library_NS groups: - group: Non-secure Code # Create group files: - file: main_ns.c # Add files to group - file: $Source(Secure)$interface.h - file: $Output(Secure)$_CMSE_Lib.o layer: The layer: node is the start of a *.clayer.yml file and defines a Software Layer . It can contain the following nodes: layer: Content type: Optional Layer type for combining layers; used to identify compatible layers . description: Optional Brief description text of the layer. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. generators: Optional Control the directory structure for generator output. packs: Optional Defines packs that are required for this layer. for-device: Optional Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Optional Board information, used for consistency check (board selection is in *.csolution.yml ). connections: Optional List of consumed and provided resources. processor: Optional Processor specific settings. linker: Optional Instructions for the linker. groups: Optional List of source file groups along with source files. components: Optional List of software components used. Example: layer: type: Board description: Setup with Ethernet and WiFi interface processor: trustzone: secure # set processor to secure components: - component: Startup - component: CMSIS CORE groups: - group: Secure Code files: - file: main_s.c - group: CMSE files: - file: interface.c - file: interface.h - file: tz_context.c Directory Control The following nodes control the directory structure for the application. output-dirs: Allows to control the directory structure for build output files and temporary files. Note: This control is only possible at csolution.yml level. CMake manages the temporary directory of all projects therefore tmpdir: does not support access sequences. output-dirs: Content outdir: Optional Specifies the directory for the build output files (ELF, binary, MAP files). tmpdir: Optional Specifies the directory for the interim temporary files. intdir: Optional Legacy node, applied instead of tmpdir: when using cbuild with option --cbuildgen . The default setting for the output-dirs: are: tmpdir: tmp # All projects use the same temporary directory outdir: $SolutionDir()$/out/$TargetType$/$BuildType$ With the tool option --output an prefix top-level directory can be added. The effective outdir: with the command below is: MyOut/out/$TargetType$/$BuildType$ . cbuild <name>.csolution.yml --output MyOut Example: output-dirs: tmpdir: ./tmp2 # relative path to csolution.yml file outdir: ./out/$Project$/$TargetType$ # $BuildType$ no longer part of the outdir generators: Allows to control the directory structure for generator output files. When no explicit generators: is specified, the csolution Project Manager uses as path: The workingDir defined in the generators element of the PDSC file. When no workingDir is defined the default directory $ProjectDir()$/generated/<generator-id> is used; <generator-id> is defined by the id in the generators element of the PDSC file. The generators: node can be added at various levels of the *.yml input files. The following order is used: Use generators: specification of the *.clayer.yml input file, if not exist: Use generators: specification of the *.cproject.yml input file, if not exist: Use generators: specification of the *.csolution.yml input file. Notes: Only relative paths are permitted to support portablity of projects. The location of the *.yml file that contains the generators: node is the reference for relative paths. generators: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/generated . options: Optional Specific generator options; allows explicit directory configuration for a generator. Note The base directory is extended for each generator with /<generator-id> ; <generator-id> is defined by the id in the generators element of the PDSC file. generators: - options: options: Content - generator: Optional Identifier of the generator tool, specified with id in the generators element of the PDSC file. path: Optional Specifies the directory for generated files. Relative paths used location of *.cproject.yml or *.clayer.yml file as base directory. name: Optional Specifies the base name of the generator import file (added in CMSIS-Toolbox 2.4.0); typically used for a board layer. map: Optional Mapping of the csolution project to a generator specific run-time context name (added in CMSIS-Toolbox 2.4.0). Example: generators: base-dir: $SolutionDir()$/MyGenerators # Path for all generators extended by '/<generator-id>' options: - generator: CubeMX # for the generator id `CubeMX` use this path path: ./CubeFiles # relative path to generated files and the generator import file name: MyConf # results in generator import file ./CubeFiles/MyConf.cgen.yml map: Boot # Map this project part to the CubeMX run-time context Boot rte: Allows to control the directory structure for RTE (run-time environment) files. Notes: This control is only possible at *.cproject.yml level. Only relative paths are permitted to support portablity of projects. The location of the *.cproject.yml file is the reference for relative paths. rte: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/RTE . rte: base-dir: $TargetType$/RTE # Path extended with target-type, results in `$ProjectDir()$/$TargetType$/RTE` Toolchain Options Toolchain options may be used at various places such as: solution: level to specify options for a collection of related projects. project: level to specify options for a project. select-compiler: Lists the compilers that this csolution project is tested with. This information is used by the cbuild setup command to determine possible compiler choices. The actual compiler to be used is selected with the compiler: node. Notes: select-compiler: is only supported in the *.csolution.yml project file. This control is new in CMSIS-Toolbox 2.5.0 select-compiler: Content - compiler: Required Specifies a supported compiler. Example: solution: created-for: cmsis-toolbox@2.5 # minimum CMSIS-Toolbox version required for project build select-compiler: # list tested compilers that can be selected - compiler: GCC # GCC is supported - compiler: AC6@6.22 # AC6 is supported, version number is an hint on what was tested compiler: Selects the compiler toolchain used for code generation. It can be applied in *.csolution.yml files. Optionally the compiler can have a version number specification. Compiler Name Supported Compiler AC6 Arm Compiler version 6 GCC GCC Compiler IAR IAR Compiler CLANG CLANG Compiler based on LLVM technlogy Example: compiler: GCC # Select GCC Compiler compiler: AC6@6.18.0 # Select Arm Compiler version 6.18.0 linker: The linker: node specifies an explicit Linker Script and/or memory regions header file. It can be applied in *.cproject.yml and *.clayer.yml files. Refer to Linker Script Management for detailed information. linker: Content - regions: Optional Path and file name of <regions_file>.h , used to generate a Linker Script. script: Optional Explicit file name of the Linker Script, overrules files provided with file: or components. auto: Optional Request automatic Linker Script generation . define: Optional Define symbol settings for the linker script file preprocessor. for-compiler: Optional Include Linker Script for the specified toolchain. for-context: Optional Include Linker Script for a list of build and target type names. not-for-context: Optional Exclude Linker Script for a list of build and target type names. Notes: The linker: node must have at least regions: , script: , auto: , or define: . If no script: file is specified, compiler specific Linker Script template files are used. A Linker Script file is preprocessed when regions: or a define: is or the file extension is *.src . If both auto: and script: is specified a warning is issued and automatic Linker Script generation is performed and the specified script: is ignored. Examples: linker: - script: MyLinker.scf.src # linker script file regions: MyRegions.h # pre-processed using header file linker: - regions: MyRegions.h # Default linker script is used and pre-processed using header file linker: - script: MyLinker.scf.src # linker script file, not pre-processed for-compiler: AC6 # for Arm Compiler 6 - script: MyLinker.ld # linker script file, not pre-processed for-compiler: CLANG # for CLANG LLVM based compiler linker: - script: MyLinker.scf.src # linker script file for-compiler: AC6 # for Arm Compiler 6 regions: MyRegions.h # pre-processed using header file - script: MyLinker.ld.src # linker script file for-compiler: CLANG # for CLANG LLVM based compiler regions: MyRegions.h # pre-processed using header file define: # with define setting - Setup: 1 # define with value output: Configure the generated output files. output: Content base-name: Optional Specify a common base name for all output files. type: Optional A list of output types for code generation (see list below). type: Description - lib Library or archive. Note: GCC uses the prefix lib in the base name for archive files. - elf Executable in ELF format. The file extension is toolchain specific. - hex Intel HEX file in HEX-386 format. - bin Binary image. The default setting for output: is: output: base-name: $Project$ # used the base name of the `cproject.yml` file. type: elf # Generate executeable file. Example: output: # configure output files base-name: MyProject # used for all output files, including linker map file. type: - elf # Generate executeable file. - hex # generate a HEX file - bin # generate a BIN file Generate a library : output: # configure output files type: lib # Generate library file. Translation Control The following translation control options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project groups: level to specify options for a specify source file group files: level to specify options for a specify source file Note The keys define: , define-asm: , add-path: , add-path-asm: , del-path: , and misc: are additive. All other keys can only be defined once at the level of solution: , project: , setup: , layer: , build-types: . or target-types: . However, it is possible to overwrite these keys at the level of group: , file: , or component: , for example it is possible to translate a file group with a different optimize level. language-C: Set the language standard for C source file compilation. Value Select C Language Standard c90 compile C source files as defined in C90 standard (ISO/IEC 9899:1990). gnu90 same as c90 but with additional GNU extensions. c99 (default) compile C source files as defined in C99 standard (ISO/IEC 9899:1999). gnu99 same as c99 but with additional GNU extensions. c11 compile C source files as defined in C11 standard (ISO/IEC 9899:2011). gnu11 same as c11 but with additional GNU extensions. c17 compile C source files as defined in C17 standard (ISO/IEC 9899:2017). Experimental compiler feature new in CMSIS-Toolbox 2.6.0. c23 compile C source files as defined in C23 standard (ISO/IEC 9899:2023). Experimental compiler feature new in CMSIS-Toolbox 2.6.0. language-CPP: Set the language standard for C++ source file compilation. Value Select C++ Language Standard c++98 compile C++ source files as defined in C++98 standard (ISO/IEC 14882:1998). gnu++98 same as c++98 but with additional GNU extensions. c++03 compile C++ source files as defined in C++03 standard (ISO/IEC 14882:2003). gnu++03 same as c++03 but with additional GNU extensions. c++11 compile C++ source files as defined in C++11 standard (ISO/IEC 14882:2011). gnu++11 same as c++11 but with additional GNU extensions. c++14 (default) compile C++ source files as defined in C++14 standard (ISO/IEC 14882:2014). gnu++14 same as c++14 but with additional GNU extensions. c++17 compile C++ source files as defined in C++17 standard (ISO/IEC 14882:2014). gnu++17 same as c++17 but with additional GNU extensions. c++20 compile C++ source files as defined in C++20 standard (ISO/IEC 14882:2020). gnu++20 same as c++20 but with additional GNU extensions. optimize: Generic optimize levels for code generation. Value Code Generation balanced Balanced optimization size Optimized for code size speed Optimized for execution speed debug Optimize for debug experience none No optimization Note When optimize: is not specified, the default optimize setting of the compiler is used. Example: groups: - group: \"Main File Group\" optimize: none # optimize this file group for debug illusion files: - file: file1a.c - file: file1b.c debug: Control the generation of debug information. Value Code Generation on Generate debug information (default) off Generate no debug information Example: build-types: - type: Release optimize: size # optimize for size debug: off # generate no debug information for the release build warnings: Control warning level for compiler diagnostics. Value Control diagnostic messages (warnings) on Generate warning messages all Enable all compiler warning messages (compiler option -Wall) off No warning messages generated define: Contains a list of symbol #define statements that are passed via the command line to the development tools for C, C++ source files, or the linker script file preprocessor. define: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Note: This control only applies to C and C++ source files (or to the linker script preprocessor). For assembler source files use the define-asm: node. Example: define: # Start a list of define statements - TestValue: 12 # add symbol 'TestValue' with value 12 - TestMode # add symbol 'TestMode' define-asm: Contains a list of symbol #define statements that are passed via the command line to the development tools for Assembler source files. define-asm: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Example: define-asm: # Start a list of define statements for Assembler source code - AsmValue: 12 # add symbol 'AsmValue' with value 12 undefine: Remove symbol #define statements from the command line of the development tools. undefine: Content - <symbol-name> Remove #define symbol Examples: groups: - group: \"Main File Group\" undefine: - TestValue # remove define symbol `TestValue` for this file group files: - file: file1a.c undefine: - TestMode # remove define symbol `TestMode` for this file - file: file1b.c add-path: Add include paths to the command line of the development tools for C and C++ source files. add-path: Content - <path-name> Named path to be added Note: This control only applies to C and C++ source files. For assembler source files use the add-path-asm: node. Example: project: misc: - for-compiler: AC6 C: [-fshort-enums, -fshort-wchar] - for-compiler: GCC C: [-fshort-enums, -fshort-wchar] add-path: - $OutDir(Secure)$ # add path to secure project's output directory add-path-asm: Add include paths to the command line of the development tools for assembly source files. add-path-asm: Content - <path-name> Named path to be added Note: This control only applies to assembler source files. For C and C++ source files use the add-path: node. Example: project: add-path-asm: - .\\MyAsmIncludes # add path to assembler include filessecure project's output directory del-path: Remove include paths (that are defined at the cproject level) from the command line of the development tools. del-paths: Content - <path-name> Named path to be removed; * for all Examle: target-types: - type: CM3 device: ARMCM3 del-paths: - /path/solution/to-be-removed misc: Add miscellaneous literal tool-specific controls that are directly passed to the individual tools depending on the file type. misc: Content - for-compiler: Optional Name of the toolchain that the literal control string applies to. C-CPP: Optional Applies to *.c and *.cpp files (added before C and CPP: ). C: Optional Applies to *.c files only. CPP: Optional Applies to *.cpp files only. ASM: Optional Applies to assembler source files only. Link: Optional Applies to the linker (added before Link-C: or Link-CPP: ). Link-C: Optional Applies to the linker; added when no C++ files are part of the project. Link-CPP: Optional Applies to the linker; added when C++ files are part of the project. Library: Optional Set libraries to the correct position in the linker command line (for GCC). Example: build-types: - type: Debug misc: - for-compiler: AC6 C-CPP: - -O1 - -g - for-compiler: GCC C-CPP: - -Og - type: Release compiler: AC6 misc: - C: - -O3 - type: GCC-LibDebug compiler: GCC misc: - Library: - -lm - -lc - -lgcc - -lnosys Project Setups The setups: node can be used to create setups that are specific to a compiler, target-type, and/or built-type. setups: The setups: node collects a list of setup: notes. For each context, only one setup will be selected. The result is a setup: that collects various toolchain options and that is valid for all files and components in the project. It is however possible to change that setup: settings on a group: or file: level. setups: Content - setup: Required Description of the setup for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. output: Optional Configure the generated output files. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. linker: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. processor: Optional Processor configuration. project: setups: - setup: Arm Compiler 6 project setup for-compiler: AC6 linker: - script: my-project.sct define: - test: 12 - setup: GCC project setup for-compiler: GCC linker: - script: my-project.inc define: - test: 11 Pack Selection The packs: node can be specified in the *.csolution.yml file allows you to: Reduce the scope of software packs that are available for projects. Add specific software packs optional with a version specification. Provide a path to a local installation of a software pack that is for example project specific or under development. The Pack Name Conventions are used to specify the name of the software packs. The pack: definition may be specific to a context that specifies target-types: and/or build-types: or provide a local path to a development repository of a software pack. Notes: By default, the csolution Project Manager only loads the latest version of the installed software packs. It is however possible to request specific versions using the - pack: node. An attempt to add two different versions of the same software pack results in an error. packs: The packs: node is the start of a pack selection. packs: Content - pack: Explicit pack specification (additive) pack: The pack: list allows to add specific software packs , optional with a version specification. pack: Content path: Explicit path name that stores the software pack. This can be a relative path to your project workspace. for-context: Include pack for a list of build and target types. not-for-context: Exclude pack for a list of build and target types. Note When an explicit path: to the pack is specified, an explicit pack version cannot be specified as the path directly specifies the pack to include. Example: packs: # start section that specifics software packs - pack: AWS # use packs from AWS - pack: NXP::*K32L* # use packs from NXP relating to K32L series (would match K32L3A60_DFP + FRDM-K32L3A6_BSP) - pack: ARM # use packs from Arm - pack: Keil::Arm_Compiler # add latest version of Keil::Arm_Compiler pack - pack: Keil::MDK-Middleware@7.13.0 # add Keil::MDK-Middleware pack at version 7.13.0 - pack: ARM::CMSIS-FreeRTOS@~10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 10.5.0 - pack: ARM::CMSIS-FreeRTOS@^10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 11.0.0 - pack: NXP::K32L3A60_DFP # add pack for NXP device path: ./local/NXP/K32L3A60_DFP # with path to the pack (local copy, repo, etc.) - pack: AWS::coreHTTP # add pack path: ./development/AWS/coreHTTP # with path to development source directory for-context: +DevTest # pack is only used for target-type \"DevTest\" Target Selection board: Specifies a unique board name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. device: Specifies a unique device name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. A device: is derived from the board: setting, but an explicit device: setting overrules the board: device. If device: specifies a device with a multi-core processor, and no explicit pname for the processor core selection is specified, the default pname of the device is used. At the level of a cproject.yml file, only the pname can be specified as the device itself is selected at the level of a csolution.yml file. Processor Attributes processor: The processor: keyword specifies the usage of processor features for this project. processor: Content fpu: Select usage of FPU instructions: dp (double precision) | sp (single precision) | off (disabled). dsp: Select usage of SIMD instructions: on (enabled) | off (disabled). mve: Select usage of M-Profile vector extension: fp (floating point and integer instructions) | int (integer instructions) | off (disabled). trustzone: Select TrustZone mode: secure | secure-only | non-secure | off . branch-protection: Select Branch Protection mode: bti (branch target identification) | bti-signret (branch target identification and pointer authentication) | off (disabled). The default setting enables the available features of the device. For example fpu: dp is selected for devices that offer double precision floating point hardware. For trustzone: the possible settings are: trustzone: Description off TrustZone disabled, classic Cortex-M programmers model. Default for devices with configurable TrustZone feature. non-secure Non-secure mode. Default for devices with enabled TrustZone feature. secure Secure mode with veneers for non-secure calls. Related options to generate cmse library are enabled. secure-only Secure mode without veneers for non-secure calls. No cmse library generated (new in CMSIS-Toolbox 2.6.0). Example: project: processor: trustzone: secure fpu: off # do not use FPU instructions mve: off # do not use vector instructions. Context A context is an enviroment setup for a project that is composed of: project-name that is the base name of the *.cproject.yml file. .build-type that defines typically build specific settings such as for debug, release, or test. +target-type that defines typically target specific settings such as device, board, or usage of processor features. Note The context name is used througout the build process and is reflected in directory names. Even when there is not a fixed limit, keep identifiers short. Recommended is less than 32 characters for the context name. Blank characters (' ') in the context name are not permitted by CMake. The section Project setup for multiple targets and test builds explains the overall concept of target-types and build-types . These target-types and build-types are defined in the *.csolution.yml that defines the overall application for a system. The settings of the target-types: are processed first; then the settings of the build-types: that potentially overwrite the target-types: settings. target-types: The target-types: node may include toolchain options , target selection , and processor attributes : target-types: Content - type: Required The target-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. board: see Note Board specification. device: see Note Device specification. processor: Optional Processor specific settings. context-map: Optional Use different target-types: for specific projects. variables: Optional Variables that can be used to define project components. Note:: Either device: or board: is required. build-types: The build-types: node may include toolchain options : build-types: Content - type: Required The build-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. context-map: Optional Use different build-types: for specific projects. variables: Optional Variables that can be used to define project components. Example: target-types: - type: Board # target-type name, used in context with: +Board board: NUCLEO-L552ZE-Q # board specifies indirectly also the device - type: Production-HW # target-type name, used in context with: +Production-HW device: STM32L552RC # specifies device build-types: - type: Debug # build-type name, used in context with: .Debug optimize: none # specifies code optimization level debug: debug # generates debug information - type: Test # build-type name, used in context with: .Test optimize: size debug: on The board: , device: , and processor: settings are used to configure the code translation for the toolchain. These settings are processed in the following order: board: relates to a BSP software pack that defines board parameters, including the mounted device . If board: is not specified, a device: must be specified. device: defines the target device. If board: is specified, the device: setting can be used to overwrite the device or specify the processor core used. processor: overwrites default settings for code generation, such as endianess, TrustZone mode, or disable Floating Point code generation. Examples: target-types: - type: Production-HW board: NUCLEO-L552ZE-Q # hardware is similar to a board (to use related software layers) device: STM32L552RC # but uses a slightly different device processor: trustzone: off # TrustZone disabled for this project target-types: - type: Production-HW board: FRDM-K32L3A6 # NXP board with K32L3A6 device device: :cm0plus # use the Cortex-M0+ processor context-map: The context-map: node allows for a specific project-name the remapping of target-types: and/or build-types: to a different context: which enables: Integrating an existing *.cproject.yml file in a different *.csolution.yml file that uses different build-types: and/or target-types: for the overall application. Defines how different *.cproject.yml files of a *.csolution.yml are to the binary image of the final target (needs reflection in cbuild-idx.yml). The context-map: node lists a remapping of the context-name for a project-name and specific target-types: and build-types: . context-map: Content - <context-name> Required Specify an alternative context-name for a project. For the context-map: it is required to specify the <project-name> as part of the context-name . This project will use a different .build-type and/or +target-type as applied in the context-name . This remapping of the context applies for the specific type in the build-types: or target-types: list. Example 1: This application combines two projects for a multi-processor device, but the project HelloCM7 requires a different setting for the build-type name Release as this enables different settings within the *.cproject.yml file. target-types: - type: DualCore device: MyDualCoreDevice build-types: - type: Release # When applying build-type name 'release': context-map: - HelloCM7.flex_release # project HelloCM7 uses build-type name \"flex_release\" instead of \"release\" projects: - project: ./CM7/HelloCM7.cproject.yml - project: ./CM4/HelloCM4.cproject.yml Example 2: The following example uses three projects Demo , TFM and Boot . The project TFM should be always build using the context TFM.Release+LibMode . For the target-type name Board , the Boot project requires the +Flash target, but any build-type could be used. target-types: - type: Board # When applying target-type: 'Board': context-map: - TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode - Boot+Flash # for project Boot use target-type: Flash board: B-U585I-IOT02A - type: AVH # When applying target-type: 'AVH': context-map: - context: TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode device: ARM::SSE-300-MPS3 projects: - project: ./App/Demo.cproject.yml - project: ./Security/TFM.cproject.yml - project: ./Loader/Boot.cproject.yml Conditional Build It is possible to include or exclude items of a list node in the build process. for-compiler: includes items only for a compiler toolchain. for-context: includes items only for a context list. not-for-context: excludes items for a context list. Note for-context and not-for-context are mutually exclusive, only one occurrence can be specified for a list node . for-compiler: Depending on a compiler toolchain it is possible to include list nodes in the build process. Examples: for-compiler: AC6@6.16 # add item for Arm Compiler version 6.16 only for-compiler: GCC # for GCC Compiler (any version) for-context: A context list that adds a list-node for specific target-type and/or build-type names. not-for-context: A context list that removes a list-node for specific target-types: and/or build-types: . Context List It is also possible to provide a context list with: - [.build-type][+target-type] - [.build-type][+target-type] Examples: for-context: - .Test # add item for build-type: Test (any target-type) for-context: # add item - .Debug # for build-type: Debug and - .Release+Production-HW # build-type: Release / target-type: Production-HW not-for-context: +Virtual # remove item for target-type: Virtual (any build-type) not-for-context: .Release+Virtual # remove item for build-type: Release with target-type: Virtual Usage The keyword for-context: and not-for-context: can be used for the following list nodes : List Node Description - project: At projects: level it is possible to control inclusion of project. - layer: At layers: level it is possible to control inclusion of a software layer. The keyword for-context: , not-for-context: , and for-compiler: can be applied to the following list nodes : List Node Description - component: At components: level it is possible to control inclusion of a software component. - group: At groups: level it is possible to control inclusion of a file group. - setup: At setups: level it is define toolchain specific options that apply to the whole project. - file: At files: level it is possible to control inclusion of a file. The inclusion of a list node is processed with this hierarchy from top to bottom: project --> layer --> component / group --> file In other words, the restrictions specified by for-context: or not-for-context for a list node are applied to it child nodes. Child list nodes inherit the restrictions from their parent. Note With for-context: and not-for-context: the project-name of a context cannot be applied. The context name must therefore start with . to refer the build-type: or + to refer the target-type: . Regular Expressions With for-context: and not-for-context: a regular expression can be used to refer to multiple context names. When a context name starts with the character \\ the regular expression expansion is enabled. The character \\ itself is not part of the sequence. Example: The following project is only included when the build-type: of a context contains Test . build-types: - Debug-Test: # Debug build with Test functionality : - Test-Release: # Release build with Test functionality : - Debug: : - Release: : project: Test.cproject.yml - for-context: \\.*Test*` Multiple Projects The section Project setup for related projects describes the organization of multiple projects. The file *.csolution.yml describes the relationship of this projects and may also re-map target-types: and build-types: for this projects using context-map: . projects: The YAML structure of the section projects: is: projects: Content - project: Required Path to the project file. for-context: Optional Include project for a list of build and target types. not-for-context: Optional Exclude project for a list of build and target types. Examples: This example uses two projects that are build in parallel using the same build-type: and target-type: . Such a setup is typical for multi-processor systems. projects: - project: ./CM0/CM0.cproject.yml # include project for Cortex-M0 processor - project: ./CM4/CM4.cproject.yml # include project for Cortex-M4 processor This example uses multiple projects, but with additional controls. projects: - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # build only when 'target-type: CM0-Addon' is selected for-compiler: GCC # build only when 'compiler: GCC' is selected define: # add additional defines during build process - test: 12 - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # specify use case for-compiler: AC6 # build only when 'compiler: AC6' is selected define: # add additional defines during build process - test: 9 - project: ./Debug/Debug.cproject.yml # specify cproject.yml file not-for-context: .Release # generated for any 'build-type:' except 'Release' Source File Management Keyword Used in files Description groups: *.cproject.yml , *.clayer.yml Start of a list that adds source groups and files to a project or layer. layers: *.cproject.yml Start of a list that adds software layers to a project. components: *.cproject.yml , *.clayer.yml Start of a list that adds software components to a project or layer. groups: The groups: keyword specifies a list that adds source groups and files to a project or layer: groups: Content - group: Required Name of the group. for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. groups: Optional Start a nested list of groups. files: Optional Start a list of files. Example: See files: section. files: Add source files to a project. files: Content - file: Required Name of the file. for-context: Optional Include file for a list of build and target types. not-for-context: Optional Exclude file for a list of build and target types. for-compiler: Optional Include file for a list of compilers. category: Optional Explicit file category to overwrite filename extension assignment. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. Note It is also possible to specify a Linker Script . Files with the extension .sct , .scf , .ld , and .icf are recognized as Linker Script files. Example: Add source files to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. groups: - group: \"Main File Group\" not-for-context: # includes this group not for the following: - .Release+Virtual # build-type 'Release' and target-type 'Virtual' - .Test-DSP+Virtual # build-type 'Test-DSP' and target-type 'Virtual' - +Board # target-type 'Board' files: - file: file1a.c - file: file1b.c define: - a: 1 undefine: - b optimize: size - group: \"Other File Group\" files: - file: file2a.c for-context: +Virtual # include this file only for target-type 'Virtual' define: - test: 2 - file: file2a.c not-for-context: +Virtual # include this file not for target-type 'Virtual' - file: file2b.c - group: \"Nested Group\" groups: - group: Subgroup1 files: - file: file-sub1-1.c - file: file-sub1-2.c - group: Subgroup2 files: - file: file-sub2-1.c - file: file-sub2-2.c It is also possible to include a file group for a specific compiler using for-compiler: or a specific target-type and/or build-type using for-context: or not-for-context: . groups: - group: \"Main File Group\" for-compiler: AC6 # includes this group only for Arm Compiler 6 files: - file: file1a.c - file: file2a.c - group: \"Main File Group\" for-compiler: GCC # includes this group only for GCC Compiler files: - file: file1b.c - file: file2b.c Using category: allows to specify pre-include files that are project-wide or related only to the group: . A global pre-include file is added to the compiler command line for all modules of the whole project (globally). - group: \"Main File Group\" files: - file: SystemDefinitions.h category: preIncludeGlobal A local pre-include file is added to the compiler command line for all modules of a group (locally). - group: \"Group 2\" files: - file: MyDefinitions.h category: preIncludeLocal layers: Add a software layer to a project. Used in *.cproject.yml files. layers: Content - layer: Optional Path to the *.clayer.yml file that defines the layer. type: Optional Refers to an expected layer type. for-context: Optional Include layer for a list of build and target types. not-for-context: Optional Exclude layer for a list of build and target types. Example: layers: # Socket - layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml for-context: - +IP-Stack - layer: ./Socket/WiFi/Socket.clayer.yml for-context: - +WiFi - layer: ./Socket/VSocket/Socket.clayer.yml for-context: - +AVH # Board - layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml for-context: - +IP-Stack # - +WiFi - layer: ./Board/B-U585I-IOT02A/Board.clayer.yml for-context: - +WiFi - layer: ./Board/AVH_MPS3_Corstone-300/Board.clayer.yml for-context: - +AVH layer: - type: The layer: - type: is used in combination with the meta-data of the connections: to check the list of available *.clayer.yml files for matching layers. Instead of an explicit layer: node that specifies a *.clayer.yml file, the type: is used to search for matching layers with the csolution command list layers . Example: layers: - type: Socket # search for matching layers of type `Socket` - type: Board # search for matching layers of type `Board` When combined with variables: it is possible to define the required *.clayer.yml files at the level of the *.csolution.yml file. Refer to variables: for an example. components: Add software components to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. components: Content - component: Required Name of the software component. for-context: Optional Include component for a list of build and target types. not-for-context: Optional Exclude component for a list of build and target types. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. instances: Optional Add multiple instances of component configuration files (default: 1) Example: components: - component: ARM::CMSIS:RTOS2:FreeRTOS&Cortex-M - component: ARM::RTOS&FreeRTOS:Config&CMSIS RTOS2 - component: ARM::RTOS&FreeRTOS:Core&Cortex-M - component: ARM::RTOS&FreeRTOS:Event Groups - component: ARM::RTOS&FreeRTOS:Heap&Heap_5 - component: ARM::RTOS&FreeRTOS:Stream Buffer - component: ARM::RTOS&FreeRTOS:Timers - component: ARM::Security:mbed TLS define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" - component: AWS::FreeRTOS:backoffAlgorithm - component: AWS::FreeRTOS:coreMQTT - component: AWS::FreeRTOS:coreMQTT Agent - component: AWS::FreeRTOS:corePKCS11&Custom define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" Note The name format for a software component is described under Name Conventions - Component Name Conventions . instances: Allows to add multiple instances of a component and actually applies to configuration files. For detailed description refer to Open-CMSIS-Pack specification - Component Instances Example: components: - component: USB:Device instances: 2 If the user selects multiple instances of the same component, all files with attribute config in the *.PDSC file will be copied multiple times to the project. The name of the component (for example config_mylib.h) will get a postfix _n whereby n is the instance number starting with 0. Instance 0: config_usb_device_0.h Instance 1: config_usb_device_1.h The availability of instances in a project can be made public in the RTE_Components.h file. The existing way to extend the %Instance% with the instance number n . Pre/Post build steps The CMSIS-Toolbox supports pre-build and post-build steps that utilize external tools or scripts. Such external commands can be used for various tasks such as: pre-process source files. add checksums to a binary file. combine multiple ELF files into a single image. add a timestamp to an image ( always: ensures execution in every build). sign images for a bootloader. executes: Execute an external command for pre or post build steps used in *.csolution.yml and *.cproject.yml files. The input: and output: files are used for dependency checking and schedule the execution (as pre-build or post-build step) during the build process of an application (option --context is not used). Other CMake Build scripts may be integrated into the overall build process using the executes: node. Refer to Build Operation - CMake Integration for an example that utilizes a file converter for web site images. The structure of the executes: node is: executes: Content - execute: Required The identifier is used as CMake target name and must not contain spaces and special characters; recommended is less then 32 characters. run: Required Command string with name of the program or script (optionally with path) along with argument string. always: Optional When present, the build step always runs and bypasses check for outdated output: files. input: Optional A list of input files (may contain Access Sequences ). output: Optional A list of output files (may contain Access Sequences ). for-context: Optional Run command for a list of build and target types (only supported in *.cproject.yml ). not-for-context: Optional Exclude run command for a list of build and target types (only supported in *.cproject.yml ). The run: command string uses these sequences to access input files and output files: run: command file access Description $input$ List of all input files separated by semicolon (;) character. $input(<n>)$ Input file in the list with index <n> ; first item is <n>=0 . $output$ List of all output files separated by semicolon (;) character. $output(<n>)$ Output file in the list with index <n> ; first item is <n>=0 . The run: command string also accepts these access sequences : $Bname$, $Dname$, $Pname$, $BuildType$, $TargetType$, $Compiler$, $Solution$, $Project$. It does not accept access sequences that reference directories or files as this bypasses the project dependency check . Instead use the input: list to pass files or directories. Notes: The execute: node is processed by the CMake build system. The order of execution depends on $input$ and $output files and is evaluated by CMake. The execute: node is processed only for an application build when no --context option is specified. The option --context-set can be used. CMake uses Linux-style path names with / characters, it does not accept the Windows-style \\ characters in the run: node to specify the location of an executeable tool. CMake provides several builtin command-line tools (copy, checksum, etc.) that run on every Host OS. Consider using these command-line tools instead of Windows or Linux specific commands. Use CMake -E help to list the available commands. The base directory for execution is not controlled by the CMSIS-Toolbox and typically the tmp directory. The commands specified by run: should be in the path of the Host OS or the path/tool should be passed using an $input(<n>)$ argument. At the *.csolution.yml level for-context: and not-for-context: is not evaluated. Examples: The tool gen_image combines multiple input images. It is called with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). solution: # executed as part of a complete solution build : executes: - execute: GenImage # generate final download image run: gen_image $input$ -o $output$ --sign # command string input: - $elf(Application)$ # combine these project parts - $elf(TFM)$ - $elf(Bootloader)$ output: - $SolutionDir()$/$Solution$.out # output file name The Windows batch file KeyGen.bat converts a input file keyfile.txt to a C source file. combines multiple input images. It is called with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). project: # executed as part of a project build executes: - execute: Generate Encryption Keys run: $input(1)$ $input(0)$ -o $output$ always: # always generate the keyfile.c as it has a timestamp input: - $ProjectDir()$/keyfile.txt # contains the key in text format - $SolutionDir()$/KeyGen.bat output: - $ProjectDir()$/keyfile.c # output as C source file that is part of this project The builtin CMake command-line tool copy is used to copy the ELF output file. project: # executed as part of a project build executes: - execute: copy-elf run: ${CMAKE_COMMAND} -E copy $input$ $output$ input: - $elf()$ output: - $OutDir()$/Project.out for-context: .Release Refer to Build Operation - CMake Integration for examples that integrate CMake scripts. connections: The connections: node contains meta-data that describes the compatiblity of *.cproject.yml and *.clayer.yml project parts. The connections: node lists functionality (drivers, pins, and other software or hardware resources). The node consumes: lists required functionality; the node provides: is the implemented functionality of that project part. This enables reference applications that work across a range of different hardware targets where: The *.cproject.yml file of the reference application lists with the connections: node the required functionality with consumes: . The *.clayer.yml project part lists with the connections: node the implemented functionality with provides: . This works across multiple levels, which means that a *.clayer.yml file could also require other functionality using consumes: . The connections: node is used to identify compatible software layers. These software layers could be stored in CMSIS software packs using the following structure: A reference application described in a *.cproject.yml file could be provided in a git repository. This reference application uses software layers that are provided in CMSIS software packs. A CMSIS Board Support Pack (BSP) contains a configured board layer desribed in a *.clayer.yml file. This software layer is pre-configured for a range of use-cases and provides drivers for I2C and SPI interfaces along with pin definitions and provisions for an Ardunio shield. For a sensor, a CMSIS software pack contains the sensor middleware and software layer ( *.clayer.yml ) that describes the hardware of the Ardunio sensor shield. This shield can be applied to many different hardware boards that provide an Ardunio shield connector. This connections: node enables therefore software reuse in multiple ways: The board layer can be used by many different reference applications, as the provided: functionlity enables a wide range of use cases. The sensor hardware shield along with the middleware can be used across many different boards that provide an Ardunio shield connector along with board layer support. The structure of the connections: node is: connections: Description - connect: Required Lists specific functionality with a brief verbal description connect: The connect: node describes one or more functionalities that belong together. connect: Description set: Optional Specifies a config-id . select value that identifies a configuration option info: Optional Verbal desription displayed when this connect is selected provides: Optional List of functionality ( key / value pairs) that are provided consumes: Optional List of functionality ( key / value pairs) that are required The behaviour of the connect: node depends on the usage in csolution project files. In a cproject.yml file the connect: node is always active. In a clayer.yml file the connect: node is only active if one or more key listed under provides: is listed under consumes: in other active connect: nodes. It is also active by default if the connect: node has no provides: node. Example: In the example below the connect for: Sensor Communication Interface is only active when the SENSOR_I2C is in the consumes: list of other active connect nodes. Sensor Interrupt is only active when the SENSOR_INT is in the consumes: list of other active connect nodes. Core Functionality is always active as it has not provides: list. layer: type: Shield connections: - connect: Sensor Communication Interface provides: - SENSOR_I2C consumes: - ARDUINO_UNO_I2C - connect: Sensor Interrupt provides: - SENSOR_INT consumes: - ARDUINO_UNO_D2 - connect: Core Functionality consumes: - CMSIS-RTOS2 set: Some hardware boards have configuration settings (DIP switch or jumper) that configure interfaces. These settings have impact to the functionality (for example hardware interfaces). With set: config-id . select the possible configration options are considered when evaluating compatible *.cproject.yml and *.clayer.yml project parts. The csolution Project Manager iterates the connect: node with a set: config-id . select as described below: For each config-id only one connect: node with a select value is active at a time. Each possible select value is checked for a matching configuration. When project parts have a matching configuration, the set: value along with the info: is shown to the user. This allows the user to enable the correct hardware options. Refer to Example: Sensor Shield for a usage example. provides: A user-defined key / value pair list of functionality that is implemented or provided by a project: or layer: . The csolution Project Manager combines all the key / value pairs that listed under provides: and matches it with the key / value pairs that are listed under consumes: . For key / value pairs listed under provides: the following rules exist for a match with consumes: key / value pair: It is possible to omit the value . It matches with an identical key listed in consumes: A value is interpreted as number. Depending on the value prefix, this number must be: when consumes: value is a plain number, identical with this value. when consumes: value is prefixed with + , higher or equal then this value or the sum of all values in multiple consumes: nodes. consumes: A user-defined key / value pair list of functionality that is requried or consumed by a project: or layer: . For key / value pairs listed under consumed: the following rules exist: When no value is specified, it matches with any value of an identical key listed under provides: . A value is interpreted as number. This number must be identical in the provides: value pair. A value that is prefixed with + is interpreted as a number that is added together in case that the same key is listed multiple times under consumes: . The sum of this value must be lower or equal to the value upper limit of the provides: key . Example: Board This connections: node of a board layer describes the available interfaces. The WiFi interface requires a CMSIS-RTOS2 function. connections: # describes functionality of a board layer - connect: WiFi interface provides: - CMSIS-Driver WiFi: requires: - CMSIS-RTOS2: - connect: SPI and UART interface provides: - CMSIS-Driver SPI: - CMSIS-Driver UART: Example: Simple Project This shows a the connections: node of a complete application project that is composed of two software layers. MyProject.cproject.yml connections: - connect: all resources provides: - RTOS2: # implements RTOS2 API interface consumes: - IoT_Socket: # requires IoT_Socket interface - STDOUT: # requires STDOUT interface - Heap: +30000 # requires additional 30000 bytes memory heap : layers: - layer: MySocket.clayer.yml - layer: MyBoard.clayer.yml MySocket.clayer.yml connections: - connect: consumes: - RTOS2: # requires RTOS2 API interface - VSocket: # requires VSocket interface - Heap: +20000 # requires additional 20000 bytes memory heap provides: - IoT_Socket: # provides IoT_Socket interface MyBoard.clayer.yml connections: - connect: consumes: - RTOS2: provides: - VSocket: - STDOUT: - Heap: 65536 Example: Sensor Shield This sensor shield layer provides a set of interfaces that are configurable. connections: - connect: I2C Interface 'Std' set: comm.I2C-Std info: JP1=Off JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C: - connect: I2C Interface 'Alt' set: comm.I2C-Alt info: JP1=On JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C-Alt: - connect: SPI Interface 'Alt' set: comm.SPI info: JP2=On provides: - Sensor_SPI: consumes: - Ardunio_Uno_SPI: - connect: Sensor Interrupt INT0 set: SensorIRQ.0 info: JP3=Off provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D2: - connect: Sensor Interrupt INT1 set: SensorIRQ.1 info: JP3=On provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D3:","title":"CMSIS Solution Project File Format"},{"location":"YML-Input-Format/#cmsis-solution-project-file-format","text":"The following chapter explains the CMSIS Solution Project File Format (short form csolution project files ), the YAML files that describe the software of an embedded application.","title":"CMSIS Solution Project File Format"},{"location":"YML-Input-Format/#name-conventions","text":"","title":"Name Conventions"},{"location":"YML-Input-Format/#filename-extensions","text":"The csolution Project Manager recognizes the categories of files based on the filename extension in the YAML input files as shown in the table below. File Extension Category Description .c , .C sourceC C source file .cpp , .c++ , .C++ , .cxx , .cc , .CC sourceCpp C++ source file .h , .hpp header Header file .asm , .s , .S sourceAsm Assembly source file .ld , .scf , .sct , .icf linkerScript Linker Script file .a , .lib library Library file .o object Object file .txt , .md , .pdf , .htm , .html doc Documentation .scvd other Software Component View Description for CMSIS-View","title":"Filename Extensions"},{"location":"YML-Input-Format/#pack-name-conventions","text":"The csolution Project Manager uses the following syntax to specify the pack: names in the *.yml files. [vendor ::] pack-name [@version] # If specified, with exact version [vendor ::] pack-name [@>=version] # If specified, with version equal or higher [vendor ::] pack-name [@^version] # If specified, with version equal or higher but same major version [vendor ::] pack-name [@~version] # If specified, with version equal or higher but same major and minor version Element Description vendor Optional Vendor name of the software pack. pack-name Required Name of the software pack; wildcards (*, ?) can be used. @version Optional Software pack version number must exactly match, i.e. @1.2.3 @>=version Optional Automatically update to any version higher or equal. @^version Optional Automatically update minor/patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 2.0.0 . @~version Optional Automatically update patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 1.3.0 . Notes: When no version is specified, the csolution Project Manager only loads the latests installed version of a software pack. This also applies when wildcards are used in the pack-name . Use cpackget to download and install new pack versions. Examples: - pack: ARM::CMSIS@5.9.0 # 'CMSIS' Pack (with version 5.5.0) - pack: MDK-Middleware@>=7.13.0 # 'MDK-Middleware` latest installed version 7.13.0 or higher - pack: MDK-Middleware@^7.13.0 # 'MDK-Middleware' latest installed version 7.13.0 or higher but lower then 8.0.0 - pack: Keil::TFM # 'TFM' Software Pack from vendor Keil, latest installed version - pack: AWS # All latest versions of Software Packs from vendor 'AWS' - pack: Keil::STM* # All latest versions of Software Packs that start with 'STM' from vendor 'Keil' - pack: MDK-Middleware@>=8.0.0-0 # `MDK-Middleware` version 8.0.0 or higher including development versions","title":"pack: Name Conventions"},{"location":"YML-Input-Format/#component-name-conventions","text":"The csolution Project Manager uses the following syntax to specify the component: names in the *.yml files. [Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[>=]Cversion] Components are defined using the Open-CMSIS-Pack - <component> element . Several parts of a component are optional. For example it is possible to just define a component using Cclass and Cgroup name. All elements of a component name are summarized in the following table. Element Description Cvendor Optional Name of the component vendor as defined in <components> element or by the package vendor of the software pack. Cclass Required Component class name as defined in <components> element of the software pack. Cbundle Optional Bundle name of the component class as defined in <bundle> element of the software pack. Cgroup Required Component group name as defined in <components> element of the software pack. Csub Optional Component sub-group name as defined in <components> element of the software pack. Cvariant Optional Component sub-group name as defined in <components> element of the software pack. Cversion Optional Version number of the component, with @1.2.3 that must exactly match, or @>=1.2.3 that allows any version higher or equal. Partly defined components A component can be partly defined in csolution project files ( *.cproject.yml , *.clayer.yml , *.genlayer.yml ) by omitting Cvendor , Cvariant , and Cversion , even when this are part of the components element of the software pack. The component select algorithm resolves this to a fully defined component by: when a partly specified component resolves to several possible choices, the tool selects: (a) the default Cvariant of the component as defined in the PDSC file. (b) the component with the higher Cversion value. (c) and error message is issued when two identical components are defined by multiple vendors and Cvendor is not specified. the partly specified component is extended by: version information from the software pack. default variant definition from the software pack. The fully resolved component name is shown in the *.cbuild.yml output file. Multiple component definitions are rejected If a component is added more then once in the csolution project files and an error is issued. An attempt to select multiple variants (using Cvariant ) of a component results in an error . Examples: - component: CMSIS:CORE # CMSIS Core component (vendor selected by `csolution` ARM) - component: ARM::CMSIS:CORE # CMSIS Core component from vendor ARM (any version) - component: ARM::CMSIS:CORE@5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0) - component: ARM::CMSIS:CORE@>=5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0 or higher) - component: Device:Startup # Device Startup component from any vendor - component: CMSIS:RTOS2:Keil RTX5 # CMSIS RTOS2 Keil RTX5 component with default variant (any version) - component: ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3 # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3 - component: Keil::USB&MDK-Pro:CORE&Release@6.15.1 # USB CORE component from bundle MDK-Pro in variant 'Release' and version 6.15.1","title":"component: Name Conventions"},{"location":"YML-Input-Format/#device-name-conventions","text":"The device specifies multiple attributes about the target that ranges from the processor architecture to Flash algorithms used for device programming. The following syntax is used to specify a device: value in the *.yml files. [ [ Dvendor:: ] Dname] [:Pname] Element Description Dvendor Optional Name (without enum field) of the device vendor defined in <devices><family> element of the software pack. Dname Optional Device name (Dname attribute) or when used the variant name (Dvariant attribute) as defined in the \\<devices> element. Pname Optional Processor identifier (Pname attribute) as defined in the <devices> element. Note All elements of a device name are optional which allows to supply additional information, such as the :Pname at different stages of the project. However the Dname itself is a mandatory element and must be specified in context of the various project files. Dvendor:: must be used in combination with the Dname . Examples: device: NXP::LPC1768 # The LPC1788 device from NXP device: LPC1788 # The LPC1788 device (vendor is evaluated from DFP) device: LPC55S69JEV98 # Device name (exact name as defined in the DFP) device: LPC55S69JEV98:cm33_core0 # Device name (exact name as defined in the DFP) with Pname specified device: :cm33_core0 # Pname added to a previously defined device name (or a device derived from a board)","title":"device: Name Conventions"},{"location":"YML-Input-Format/#board-name-conventions","text":"Evaluation Boards define indirectly a device via the related BSP. The following syntax is used to specify a board: value in the *.yml files. [vendor::] board_name [:revision] Element Description vendor Optional Name of the board vendor defined in <boards><board> element of the board support pack (BSP). Bname Required Board name (name attribute) as defined in the \\<board> element of the BSP. revision Optional Board revision (revision attribute) as defined in the \\<board> element of the BSP. Note When a board: is specified, the device: specification can be omitted, however it is possible to overwrite the device setting in the BSP with an explicit device: setting. Examples: board: Keil::MCB54110 # The Keil MCB54110 board (with device NXP::LPC54114J256BD64) board: LPCXpresso55S28 # The LPCXpresso55S28 board board: STMicroelectronics::NUCLEO-L476RG:Rev.C # A board with revision specification","title":"board: Name Conventions"},{"location":"YML-Input-Format/#context-name-conventions","text":"A context: name combines project-name , built-type , and target-type and is used on various places in the CMSIS-Toolbox. The following syntax is used to specify a context: name. [project-name][.build-type][+target-type] Element Description project-name Optional Project name of a project (base name of the *.cproject.yml file). .build-type Optional The build-type name that is currently processed (specified with - type: name ). +target-type Optional The target-type name that is currently processed (specified with - type: name ). Note The .build-type and +target-type name allows letters (A-Z, a-z), digits (0-9), dash ('-'), and underscore ('_'); the maximum length is 32 characters. When project-name is omitted, the project-name is the base name of the *.cproject.yml file. When .build-type is omitted, it matches with any possible .build-type . When +target-type is omitted, it matches with any possible +target-type . By default, the specified - type: name of build-types: and target-types: nodes in the *.csolution.yml file are directly mapped to the context name. Using the context-map: node it is possible to assign a different .build-type and/or +target-type mapping for a specific project-name . Example: Show the different possible context settings of a *.csolution.yml file. AWS_MQTT_MutualAuth_SW_Framework>csolution list contexts -s Demo.csolution.yml Demo.Debug+AVH Demo.Debug+IP-Stack Demo.Debug+WiFi Demo.Release+AVH Demo.Release+IP-Stack Demo.Release+WiFi The context name is also used in for-context: and not-for-context: nodes that allow to include or exclude items depending on the context . In many cases the project-name can be omitted as the context name is within a specific *.cproject.yml file or applied to a specific *.cproject.yml file.","title":"context: Name Conventions"},{"location":"YML-Input-Format/#access-sequences","text":"The access sequences export values from the CMSIS Project Manager for the *.yml file nodes define: , define-asm: , add-path: , misc: , files: , and executes: . The access sequences can specify a different project and describe therefore project dependencies. Access Sequence Description Target Access to target and build related settings $Bname$ Bname of the selected board as specified in the board: node. $Dname$ Dname of the selected device as specified in the device: node. $Pname$ Pname of the selected device as specified in the device: node. $BuildType$ Build-type name of the currently processed project. $TargetType$ Target-type name of the currently processed project. $Compiler$ Compiler name of the compiler used in this project context as specified in the compiler: node. YML Input Access to YML Input Directories and Files $Solution$ Solution name (base name of the *.csolution.yml file). $SolutionDir()$ Path to the directory of the current processed csolution.yml file. $Project$ Project name of the current processed cproject.yml file. $ProjectDir(context)$ Path to the directory of a related cproject.yml file. Output Access to Output Directories and Files $OutDir(context)$ Path to the output directory of a related project that is defined in the *.csolution.yml file. $bin(context)$ Path and filename of the binary output file generated by the related context. $cmse-lib(context)$ Path and filename of the object file with secure gateways of a TrustZone application generated by the related context. $elf(context)$ Path and filename of the ELF/DWARF output file generated by the related context. $hex(context)$ Path and filename of the HEX output file generated by the related context. $lib(context)$ Path and filename of the library file of the related context. Pack Access to Pack Directories and Files $Bpack$ Path to the pack that defines the selected board (BSP). $Dpack$ Path to the pack that defines the selected device (DFP). $Pack(vendor::name)$ Path to a specific pack. Example: $Pack(NXP::K32L3A60_DFP)$ . For a context the project-name , .build-type , and +target-type are optional. An access sequence that specifies only project-name uses the context that is currently processed. It is important that the project is part of the context-set in the build process. Example: $ProjectDir()$ is the directory of the current processed cproject.yml file. Example: This example uses the following build-type , target-type , and projects definitions. solution: target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q # specifies board - type: Production-HW # target-type: Production-HW device: STM32L5X # specifies device build-types: - type: Debug # build-type: Debug optimize: none debug: on - type: Release # build-type: Release optimize: size projects: - project: ./bootloader/Bootloader.cproject.yml # relative path - project: /MyDevelopmentTree/security/TFM.cproject.yml # absolute path - project: ./application/MQTT_AWS.cproject.yml # relative path The project: /application/MQTT_AWS.cproject.yml may use access sequences to reference files or directories in other projects that belong to the same csolution project . For example, these references are possible in the file MQTT_AWS.cproject.yml . files: - file: $cmse-lib(TFM)$ # use symbol output file of TFM Project The example above uses the build-type and target-type of the processed context for the project TFM . With a context-set you may mix different build-types for an application. Note that it is important to build both projects in the same build process. cbuild iot-product.csolution.yml --context-set --context TFM.Release+Board --context MQTT_AWS.Debug+Board The example below uses from the TFM project always build-type: Debug and the target-type: Production-HW . files: - file: `$cmse-lib(TFM.Release+Production-HW)$` # use symbol output file of TFM Project The example below uses the build-type: Debug and the target-type of the current processed context is used. executes: - execute: GenImage run: gen_image %input% -o %output% input: - $elf(TFM.Debug)$ - $elf(Bootloader.Release)$ output: - $OutDir(TFM.Debug)$ The example below creates a define that uses the device name. groups: - group: \"Main File Group\" define: - $Dname$ # Generate a #define 'device-name' for this file group","title":"Access Sequences"},{"location":"YML-Input-Format/#variables","text":"The variables: node defines are key/value pairs that can be used to refer to *.clayer.yml files. The key is the name of the variable and can be used in the following nodes: layers: , define: , define-asm: , add-path: , add-path-asm: , misc: , files: , and executes: Using variables that are defined in the *.csolution.yml file, a *.cproject.yml file requires no modifications when new target-types: are introduced. The required layers: could be instead specified in the *.csolution.yml file using a new node variables: . Example: Example.csolution.yml solution: target-types: - type: NXP Board board: IMXRT1050-EVKB variables: - Socket-Layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml - Board-Layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml - type: ST Board board: B-U585I-IOT02A variables: - Socket-Layer: ./Socket/WiFi/Socket.clayer.yml - Board-Layer: ./Board/B-U585I-IOT02A/Board.clayer.yml Example.cproject.yml layers: - layer: $Socket-Layer$ type: Socket - layer: $Board-Layer$ # no `*.clayer.yml` specified. Compatible layers are listed type: Board # layer of type `Board` is expected","title":"Variables"},{"location":"YML-Input-Format/#order-of-list-nodes","text":"The key / value pairs in a list node can be in any order. The two following list nodes are logically identical. This might be confusing for yml files that are generated by an IDE. build-types: - type: Release # build-type name optimize: size # optimize for size debug: off # generate no debug information for the release build build-types: - debug: off # generate no debug information for the release build optimize: size # optimize for size type: Release # build-type name","title":"Order of List Nodes"},{"location":"YML-Input-Format/#project-file-structure","text":"The table below explains the top-level elements in each of the different *.yml input files that define the overall application. Keyword Description default: Start of cdefault.yml file that is used to setup the compiler along with some compiler-specific controls. solution: Start of *.csolution.yml file that collects related projects along with build-types: and target-types: . project: Start of *.cproject.yml file that defines files, components, and layers which can be independently translated to a binary image or library. layer: Start of *.clayer.yml file that contains pre-configured software components along with source files.","title":"Project File Structure"},{"location":"YML-Input-Format/#cdefault","text":"When cdefault: is specified in the *.csolution.yml file, the csolution Project Manager uses a file with the name cdefault.yml to setup the compiler with specific default controls. The search order for this file is: A cdefault.yml file in the same directory as the <solution-name>.csolution.yml file. A cdefault.yml file in the directory specified by the environment variable CMSIS_COMPILER_ROOT . A cdefault.yml file in the directory <cmsis-toolbox-installation-dir>/etc . The default: node is the start of a cdefault.yml file and contains the following. default: Content misc: Optional Literal tool-specific controls. Refer to Build Overview - cdefault.yml for an example. Note The compiler: selection in cdefault.yml has been deprecated in CMSIS-Toolbox 2.6.0.","title":"cdefault:"},{"location":"YML-Input-Format/#solution","text":"The solution: node is the start of a *.csolution.yml file that collects related projects as described in the section \"Project setup for related projects\" . solution: Content created-by: Optional Identifies the tool that created this solution. created-for: Optional Specifies the tool for building this solution, i.e. CMSIS-Toolbox@2.5.0 description: Optional Brief description text of this solution. select-compiler: Optional Lists the possible compiler selection that this project is tested with. cdefault: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. compiler: Optional Overall toolchain selection for this solution. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. output-dirs: Optional Control the output directories for the build output. generators: Optional Control the directory structure for generator output. packs: Optional Defines local packs and/or scope of packs that are used. target-types: Required List of target-types that define the target system (device or board). build-types: Optional List of build-types (i.e. Release, Debug, Test). projects: Required List of projects that belong to the solution. executes: Optional Additional pre or post build steps using external tools. Example: solution: created-for: cmsis-toolbox@2.0 # minimum CMSIS-Toolbox version required for project build cdefault: # use default setup of toolchain specific controls. compiler: GCC # overwrite compiler definition in 'cdefaults.yml' packs: - pack: ST # add ST packs in 'cdefaults.yml' build-types: # additional build types - type: Test # build-type: Test optimize: none debug: on packs: # with explicit pack specification - pack: ST::TestSW path: ./MyDev/TestSW target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device projects: - project: ./blinky/Bootloader.cproject.yml - project: /security/TFM.cproject.yml - project: /application/MQTT_AWS.cproject.yml","title":"solution:"},{"location":"YML-Input-Format/#project","text":"The project: node is the start of a *.cproject.yml file and can contain the following: project: Content description: Optional Brief description text of this project. output: Optional Configure the generated output files. generators: Optional Control the directory structure for generator output. rte: Optional Control the directory structure for RTE (run-time environment) files. packs: Optional Defines packs that are required for this project. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. linker: Optional Instructions for the linker. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Specify processor core. processor: Optional Processor specific settings. setups: Optional Configurations specific to a compiler, target-type, and/or built-type. groups: Required List of source file groups along with source files. components: Optional List of software components used. layers: Optional List of software layers that belong to the project. connections: Optional List of consumed and provided resources. executes: Optional Additional pre or post build steps using external tools. Example: project: misc: - compiler: AC6 # specify misc controls for Arm Compiler 6 C: [-fshort-enums, -fshort-wchar] # set options for C files add-path: - $OutDir(Secure)$ # add the path to the secure project's output directory components: - component: Startup # Add startup component - component: CMSIS CORE - component: Keil RTX5 Library_NS groups: - group: Non-secure Code # Create group files: - file: main_ns.c # Add files to group - file: $Source(Secure)$interface.h - file: $Output(Secure)$_CMSE_Lib.o","title":"project:"},{"location":"YML-Input-Format/#layer","text":"The layer: node is the start of a *.clayer.yml file and defines a Software Layer . It can contain the following nodes: layer: Content type: Optional Layer type for combining layers; used to identify compatible layers . description: Optional Brief description text of the layer. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. generators: Optional Control the directory structure for generator output. packs: Optional Defines packs that are required for this layer. for-device: Optional Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Optional Board information, used for consistency check (board selection is in *.csolution.yml ). connections: Optional List of consumed and provided resources. processor: Optional Processor specific settings. linker: Optional Instructions for the linker. groups: Optional List of source file groups along with source files. components: Optional List of software components used. Example: layer: type: Board description: Setup with Ethernet and WiFi interface processor: trustzone: secure # set processor to secure components: - component: Startup - component: CMSIS CORE groups: - group: Secure Code files: - file: main_s.c - group: CMSE files: - file: interface.c - file: interface.h - file: tz_context.c","title":"layer:"},{"location":"YML-Input-Format/#directory-control","text":"The following nodes control the directory structure for the application.","title":"Directory Control"},{"location":"YML-Input-Format/#output-dirs","text":"Allows to control the directory structure for build output files and temporary files. Note: This control is only possible at csolution.yml level. CMake manages the temporary directory of all projects therefore tmpdir: does not support access sequences. output-dirs: Content outdir: Optional Specifies the directory for the build output files (ELF, binary, MAP files). tmpdir: Optional Specifies the directory for the interim temporary files. intdir: Optional Legacy node, applied instead of tmpdir: when using cbuild with option --cbuildgen . The default setting for the output-dirs: are: tmpdir: tmp # All projects use the same temporary directory outdir: $SolutionDir()$/out/$TargetType$/$BuildType$ With the tool option --output an prefix top-level directory can be added. The effective outdir: with the command below is: MyOut/out/$TargetType$/$BuildType$ . cbuild <name>.csolution.yml --output MyOut Example: output-dirs: tmpdir: ./tmp2 # relative path to csolution.yml file outdir: ./out/$Project$/$TargetType$ # $BuildType$ no longer part of the outdir","title":"output-dirs:"},{"location":"YML-Input-Format/#generators","text":"Allows to control the directory structure for generator output files. When no explicit generators: is specified, the csolution Project Manager uses as path: The workingDir defined in the generators element of the PDSC file. When no workingDir is defined the default directory $ProjectDir()$/generated/<generator-id> is used; <generator-id> is defined by the id in the generators element of the PDSC file. The generators: node can be added at various levels of the *.yml input files. The following order is used: Use generators: specification of the *.clayer.yml input file, if not exist: Use generators: specification of the *.cproject.yml input file, if not exist: Use generators: specification of the *.csolution.yml input file. Notes: Only relative paths are permitted to support portablity of projects. The location of the *.yml file that contains the generators: node is the reference for relative paths. generators: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/generated . options: Optional Specific generator options; allows explicit directory configuration for a generator. Note The base directory is extended for each generator with /<generator-id> ; <generator-id> is defined by the id in the generators element of the PDSC file.","title":"generators:"},{"location":"YML-Input-Format/#generators-options","text":"options: Content - generator: Optional Identifier of the generator tool, specified with id in the generators element of the PDSC file. path: Optional Specifies the directory for generated files. Relative paths used location of *.cproject.yml or *.clayer.yml file as base directory. name: Optional Specifies the base name of the generator import file (added in CMSIS-Toolbox 2.4.0); typically used for a board layer. map: Optional Mapping of the csolution project to a generator specific run-time context name (added in CMSIS-Toolbox 2.4.0). Example: generators: base-dir: $SolutionDir()$/MyGenerators # Path for all generators extended by '/<generator-id>' options: - generator: CubeMX # for the generator id `CubeMX` use this path path: ./CubeFiles # relative path to generated files and the generator import file name: MyConf # results in generator import file ./CubeFiles/MyConf.cgen.yml map: Boot # Map this project part to the CubeMX run-time context Boot","title":"generators: - options:"},{"location":"YML-Input-Format/#rte","text":"Allows to control the directory structure for RTE (run-time environment) files. Notes: This control is only possible at *.cproject.yml level. Only relative paths are permitted to support portablity of projects. The location of the *.cproject.yml file is the reference for relative paths. rte: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/RTE . rte: base-dir: $TargetType$/RTE # Path extended with target-type, results in `$ProjectDir()$/$TargetType$/RTE`","title":"rte:"},{"location":"YML-Input-Format/#toolchain-options","text":"Toolchain options may be used at various places such as: solution: level to specify options for a collection of related projects. project: level to specify options for a project.","title":"Toolchain Options"},{"location":"YML-Input-Format/#select-compiler","text":"Lists the compilers that this csolution project is tested with. This information is used by the cbuild setup command to determine possible compiler choices. The actual compiler to be used is selected with the compiler: node. Notes: select-compiler: is only supported in the *.csolution.yml project file. This control is new in CMSIS-Toolbox 2.5.0 select-compiler: Content - compiler: Required Specifies a supported compiler. Example: solution: created-for: cmsis-toolbox@2.5 # minimum CMSIS-Toolbox version required for project build select-compiler: # list tested compilers that can be selected - compiler: GCC # GCC is supported - compiler: AC6@6.22 # AC6 is supported, version number is an hint on what was tested","title":"select-compiler:"},{"location":"YML-Input-Format/#compiler","text":"Selects the compiler toolchain used for code generation. It can be applied in *.csolution.yml files. Optionally the compiler can have a version number specification. Compiler Name Supported Compiler AC6 Arm Compiler version 6 GCC GCC Compiler IAR IAR Compiler CLANG CLANG Compiler based on LLVM technlogy Example: compiler: GCC # Select GCC Compiler compiler: AC6@6.18.0 # Select Arm Compiler version 6.18.0","title":"compiler:"},{"location":"YML-Input-Format/#linker","text":"The linker: node specifies an explicit Linker Script and/or memory regions header file. It can be applied in *.cproject.yml and *.clayer.yml files. Refer to Linker Script Management for detailed information. linker: Content - regions: Optional Path and file name of <regions_file>.h , used to generate a Linker Script. script: Optional Explicit file name of the Linker Script, overrules files provided with file: or components. auto: Optional Request automatic Linker Script generation . define: Optional Define symbol settings for the linker script file preprocessor. for-compiler: Optional Include Linker Script for the specified toolchain. for-context: Optional Include Linker Script for a list of build and target type names. not-for-context: Optional Exclude Linker Script for a list of build and target type names. Notes: The linker: node must have at least regions: , script: , auto: , or define: . If no script: file is specified, compiler specific Linker Script template files are used. A Linker Script file is preprocessed when regions: or a define: is or the file extension is *.src . If both auto: and script: is specified a warning is issued and automatic Linker Script generation is performed and the specified script: is ignored. Examples: linker: - script: MyLinker.scf.src # linker script file regions: MyRegions.h # pre-processed using header file linker: - regions: MyRegions.h # Default linker script is used and pre-processed using header file linker: - script: MyLinker.scf.src # linker script file, not pre-processed for-compiler: AC6 # for Arm Compiler 6 - script: MyLinker.ld # linker script file, not pre-processed for-compiler: CLANG # for CLANG LLVM based compiler linker: - script: MyLinker.scf.src # linker script file for-compiler: AC6 # for Arm Compiler 6 regions: MyRegions.h # pre-processed using header file - script: MyLinker.ld.src # linker script file for-compiler: CLANG # for CLANG LLVM based compiler regions: MyRegions.h # pre-processed using header file define: # with define setting - Setup: 1 # define with value","title":"linker:"},{"location":"YML-Input-Format/#output","text":"Configure the generated output files. output: Content base-name: Optional Specify a common base name for all output files. type: Optional A list of output types for code generation (see list below). type: Description - lib Library or archive. Note: GCC uses the prefix lib in the base name for archive files. - elf Executable in ELF format. The file extension is toolchain specific. - hex Intel HEX file in HEX-386 format. - bin Binary image. The default setting for output: is: output: base-name: $Project$ # used the base name of the `cproject.yml` file. type: elf # Generate executeable file. Example: output: # configure output files base-name: MyProject # used for all output files, including linker map file. type: - elf # Generate executeable file. - hex # generate a HEX file - bin # generate a BIN file Generate a library : output: # configure output files type: lib # Generate library file.","title":"output:"},{"location":"YML-Input-Format/#translation-control","text":"The following translation control options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project groups: level to specify options for a specify source file group files: level to specify options for a specify source file Note The keys define: , define-asm: , add-path: , add-path-asm: , del-path: , and misc: are additive. All other keys can only be defined once at the level of solution: , project: , setup: , layer: , build-types: . or target-types: . However, it is possible to overwrite these keys at the level of group: , file: , or component: , for example it is possible to translate a file group with a different optimize level.","title":"Translation Control"},{"location":"YML-Input-Format/#language-c","text":"Set the language standard for C source file compilation. Value Select C Language Standard c90 compile C source files as defined in C90 standard (ISO/IEC 9899:1990). gnu90 same as c90 but with additional GNU extensions. c99 (default) compile C source files as defined in C99 standard (ISO/IEC 9899:1999). gnu99 same as c99 but with additional GNU extensions. c11 compile C source files as defined in C11 standard (ISO/IEC 9899:2011). gnu11 same as c11 but with additional GNU extensions. c17 compile C source files as defined in C17 standard (ISO/IEC 9899:2017). Experimental compiler feature new in CMSIS-Toolbox 2.6.0. c23 compile C source files as defined in C23 standard (ISO/IEC 9899:2023). Experimental compiler feature new in CMSIS-Toolbox 2.6.0.","title":"language-C:"},{"location":"YML-Input-Format/#language-cpp","text":"Set the language standard for C++ source file compilation. Value Select C++ Language Standard c++98 compile C++ source files as defined in C++98 standard (ISO/IEC 14882:1998). gnu++98 same as c++98 but with additional GNU extensions. c++03 compile C++ source files as defined in C++03 standard (ISO/IEC 14882:2003). gnu++03 same as c++03 but with additional GNU extensions. c++11 compile C++ source files as defined in C++11 standard (ISO/IEC 14882:2011). gnu++11 same as c++11 but with additional GNU extensions. c++14 (default) compile C++ source files as defined in C++14 standard (ISO/IEC 14882:2014). gnu++14 same as c++14 but with additional GNU extensions. c++17 compile C++ source files as defined in C++17 standard (ISO/IEC 14882:2014). gnu++17 same as c++17 but with additional GNU extensions. c++20 compile C++ source files as defined in C++20 standard (ISO/IEC 14882:2020). gnu++20 same as c++20 but with additional GNU extensions.","title":"language-CPP:"},{"location":"YML-Input-Format/#optimize","text":"Generic optimize levels for code generation. Value Code Generation balanced Balanced optimization size Optimized for code size speed Optimized for execution speed debug Optimize for debug experience none No optimization Note When optimize: is not specified, the default optimize setting of the compiler is used. Example: groups: - group: \"Main File Group\" optimize: none # optimize this file group for debug illusion files: - file: file1a.c - file: file1b.c","title":"optimize:"},{"location":"YML-Input-Format/#debug","text":"Control the generation of debug information. Value Code Generation on Generate debug information (default) off Generate no debug information Example: build-types: - type: Release optimize: size # optimize for size debug: off # generate no debug information for the release build","title":"debug:"},{"location":"YML-Input-Format/#warnings","text":"Control warning level for compiler diagnostics. Value Control diagnostic messages (warnings) on Generate warning messages all Enable all compiler warning messages (compiler option -Wall) off No warning messages generated","title":"warnings:"},{"location":"YML-Input-Format/#define","text":"Contains a list of symbol #define statements that are passed via the command line to the development tools for C, C++ source files, or the linker script file preprocessor. define: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Note: This control only applies to C and C++ source files (or to the linker script preprocessor). For assembler source files use the define-asm: node. Example: define: # Start a list of define statements - TestValue: 12 # add symbol 'TestValue' with value 12 - TestMode # add symbol 'TestMode'","title":"define:"},{"location":"YML-Input-Format/#define-asm","text":"Contains a list of symbol #define statements that are passed via the command line to the development tools for Assembler source files. define-asm: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Example: define-asm: # Start a list of define statements for Assembler source code - AsmValue: 12 # add symbol 'AsmValue' with value 12","title":"define-asm:"},{"location":"YML-Input-Format/#undefine","text":"Remove symbol #define statements from the command line of the development tools. undefine: Content - <symbol-name> Remove #define symbol Examples: groups: - group: \"Main File Group\" undefine: - TestValue # remove define symbol `TestValue` for this file group files: - file: file1a.c undefine: - TestMode # remove define symbol `TestMode` for this file - file: file1b.c","title":"undefine:"},{"location":"YML-Input-Format/#add-path","text":"Add include paths to the command line of the development tools for C and C++ source files. add-path: Content - <path-name> Named path to be added Note: This control only applies to C and C++ source files. For assembler source files use the add-path-asm: node. Example: project: misc: - for-compiler: AC6 C: [-fshort-enums, -fshort-wchar] - for-compiler: GCC C: [-fshort-enums, -fshort-wchar] add-path: - $OutDir(Secure)$ # add path to secure project's output directory","title":"add-path:"},{"location":"YML-Input-Format/#add-path-asm","text":"Add include paths to the command line of the development tools for assembly source files. add-path-asm: Content - <path-name> Named path to be added Note: This control only applies to assembler source files. For C and C++ source files use the add-path: node. Example: project: add-path-asm: - .\\MyAsmIncludes # add path to assembler include filessecure project's output directory","title":"add-path-asm:"},{"location":"YML-Input-Format/#del-path","text":"Remove include paths (that are defined at the cproject level) from the command line of the development tools. del-paths: Content - <path-name> Named path to be removed; * for all Examle: target-types: - type: CM3 device: ARMCM3 del-paths: - /path/solution/to-be-removed","title":"del-path:"},{"location":"YML-Input-Format/#misc","text":"Add miscellaneous literal tool-specific controls that are directly passed to the individual tools depending on the file type. misc: Content - for-compiler: Optional Name of the toolchain that the literal control string applies to. C-CPP: Optional Applies to *.c and *.cpp files (added before C and CPP: ). C: Optional Applies to *.c files only. CPP: Optional Applies to *.cpp files only. ASM: Optional Applies to assembler source files only. Link: Optional Applies to the linker (added before Link-C: or Link-CPP: ). Link-C: Optional Applies to the linker; added when no C++ files are part of the project. Link-CPP: Optional Applies to the linker; added when C++ files are part of the project. Library: Optional Set libraries to the correct position in the linker command line (for GCC). Example: build-types: - type: Debug misc: - for-compiler: AC6 C-CPP: - -O1 - -g - for-compiler: GCC C-CPP: - -Og - type: Release compiler: AC6 misc: - C: - -O3 - type: GCC-LibDebug compiler: GCC misc: - Library: - -lm - -lc - -lgcc - -lnosys","title":"misc:"},{"location":"YML-Input-Format/#project-setups","text":"The setups: node can be used to create setups that are specific to a compiler, target-type, and/or built-type.","title":"Project Setups"},{"location":"YML-Input-Format/#setups","text":"The setups: node collects a list of setup: notes. For each context, only one setup will be selected. The result is a setup: that collects various toolchain options and that is valid for all files and components in the project. It is however possible to change that setup: settings on a group: or file: level. setups: Content - setup: Required Description of the setup for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. output: Optional Configure the generated output files. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. linker: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. processor: Optional Processor configuration. project: setups: - setup: Arm Compiler 6 project setup for-compiler: AC6 linker: - script: my-project.sct define: - test: 12 - setup: GCC project setup for-compiler: GCC linker: - script: my-project.inc define: - test: 11","title":"setups:"},{"location":"YML-Input-Format/#pack-selection","text":"The packs: node can be specified in the *.csolution.yml file allows you to: Reduce the scope of software packs that are available for projects. Add specific software packs optional with a version specification. Provide a path to a local installation of a software pack that is for example project specific or under development. The Pack Name Conventions are used to specify the name of the software packs. The pack: definition may be specific to a context that specifies target-types: and/or build-types: or provide a local path to a development repository of a software pack. Notes: By default, the csolution Project Manager only loads the latest version of the installed software packs. It is however possible to request specific versions using the - pack: node. An attempt to add two different versions of the same software pack results in an error.","title":"Pack Selection"},{"location":"YML-Input-Format/#packs","text":"The packs: node is the start of a pack selection. packs: Content - pack: Explicit pack specification (additive)","title":"packs:"},{"location":"YML-Input-Format/#pack","text":"The pack: list allows to add specific software packs , optional with a version specification. pack: Content path: Explicit path name that stores the software pack. This can be a relative path to your project workspace. for-context: Include pack for a list of build and target types. not-for-context: Exclude pack for a list of build and target types. Note When an explicit path: to the pack is specified, an explicit pack version cannot be specified as the path directly specifies the pack to include. Example: packs: # start section that specifics software packs - pack: AWS # use packs from AWS - pack: NXP::*K32L* # use packs from NXP relating to K32L series (would match K32L3A60_DFP + FRDM-K32L3A6_BSP) - pack: ARM # use packs from Arm - pack: Keil::Arm_Compiler # add latest version of Keil::Arm_Compiler pack - pack: Keil::MDK-Middleware@7.13.0 # add Keil::MDK-Middleware pack at version 7.13.0 - pack: ARM::CMSIS-FreeRTOS@~10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 10.5.0 - pack: ARM::CMSIS-FreeRTOS@^10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 11.0.0 - pack: NXP::K32L3A60_DFP # add pack for NXP device path: ./local/NXP/K32L3A60_DFP # with path to the pack (local copy, repo, etc.) - pack: AWS::coreHTTP # add pack path: ./development/AWS/coreHTTP # with path to development source directory for-context: +DevTest # pack is only used for target-type \"DevTest\"","title":"pack:"},{"location":"YML-Input-Format/#target-selection","text":"","title":"Target Selection"},{"location":"YML-Input-Format/#board","text":"Specifies a unique board name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings.","title":"board:"},{"location":"YML-Input-Format/#device","text":"Specifies a unique device name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. A device: is derived from the board: setting, but an explicit device: setting overrules the board: device. If device: specifies a device with a multi-core processor, and no explicit pname for the processor core selection is specified, the default pname of the device is used. At the level of a cproject.yml file, only the pname can be specified as the device itself is selected at the level of a csolution.yml file.","title":"device:"},{"location":"YML-Input-Format/#processor-attributes","text":"","title":"Processor Attributes"},{"location":"YML-Input-Format/#processor","text":"The processor: keyword specifies the usage of processor features for this project. processor: Content fpu: Select usage of FPU instructions: dp (double precision) | sp (single precision) | off (disabled). dsp: Select usage of SIMD instructions: on (enabled) | off (disabled). mve: Select usage of M-Profile vector extension: fp (floating point and integer instructions) | int (integer instructions) | off (disabled). trustzone: Select TrustZone mode: secure | secure-only | non-secure | off . branch-protection: Select Branch Protection mode: bti (branch target identification) | bti-signret (branch target identification and pointer authentication) | off (disabled). The default setting enables the available features of the device. For example fpu: dp is selected for devices that offer double precision floating point hardware. For trustzone: the possible settings are: trustzone: Description off TrustZone disabled, classic Cortex-M programmers model. Default for devices with configurable TrustZone feature. non-secure Non-secure mode. Default for devices with enabled TrustZone feature. secure Secure mode with veneers for non-secure calls. Related options to generate cmse library are enabled. secure-only Secure mode without veneers for non-secure calls. No cmse library generated (new in CMSIS-Toolbox 2.6.0). Example: project: processor: trustzone: secure fpu: off # do not use FPU instructions mve: off # do not use vector instructions.","title":"processor:"},{"location":"YML-Input-Format/#context","text":"A context is an enviroment setup for a project that is composed of: project-name that is the base name of the *.cproject.yml file. .build-type that defines typically build specific settings such as for debug, release, or test. +target-type that defines typically target specific settings such as device, board, or usage of processor features. Note The context name is used througout the build process and is reflected in directory names. Even when there is not a fixed limit, keep identifiers short. Recommended is less than 32 characters for the context name. Blank characters (' ') in the context name are not permitted by CMake. The section Project setup for multiple targets and test builds explains the overall concept of target-types and build-types . These target-types and build-types are defined in the *.csolution.yml that defines the overall application for a system. The settings of the target-types: are processed first; then the settings of the build-types: that potentially overwrite the target-types: settings.","title":"Context"},{"location":"YML-Input-Format/#target-types","text":"The target-types: node may include toolchain options , target selection , and processor attributes : target-types: Content - type: Required The target-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. board: see Note Board specification. device: see Note Device specification. processor: Optional Processor specific settings. context-map: Optional Use different target-types: for specific projects. variables: Optional Variables that can be used to define project components. Note:: Either device: or board: is required.","title":"target-types:"},{"location":"YML-Input-Format/#build-types","text":"The build-types: node may include toolchain options : build-types: Content - type: Required The build-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. context-map: Optional Use different build-types: for specific projects. variables: Optional Variables that can be used to define project components. Example: target-types: - type: Board # target-type name, used in context with: +Board board: NUCLEO-L552ZE-Q # board specifies indirectly also the device - type: Production-HW # target-type name, used in context with: +Production-HW device: STM32L552RC # specifies device build-types: - type: Debug # build-type name, used in context with: .Debug optimize: none # specifies code optimization level debug: debug # generates debug information - type: Test # build-type name, used in context with: .Test optimize: size debug: on The board: , device: , and processor: settings are used to configure the code translation for the toolchain. These settings are processed in the following order: board: relates to a BSP software pack that defines board parameters, including the mounted device . If board: is not specified, a device: must be specified. device: defines the target device. If board: is specified, the device: setting can be used to overwrite the device or specify the processor core used. processor: overwrites default settings for code generation, such as endianess, TrustZone mode, or disable Floating Point code generation. Examples: target-types: - type: Production-HW board: NUCLEO-L552ZE-Q # hardware is similar to a board (to use related software layers) device: STM32L552RC # but uses a slightly different device processor: trustzone: off # TrustZone disabled for this project target-types: - type: Production-HW board: FRDM-K32L3A6 # NXP board with K32L3A6 device device: :cm0plus # use the Cortex-M0+ processor","title":"build-types:"},{"location":"YML-Input-Format/#context-map","text":"The context-map: node allows for a specific project-name the remapping of target-types: and/or build-types: to a different context: which enables: Integrating an existing *.cproject.yml file in a different *.csolution.yml file that uses different build-types: and/or target-types: for the overall application. Defines how different *.cproject.yml files of a *.csolution.yml are to the binary image of the final target (needs reflection in cbuild-idx.yml). The context-map: node lists a remapping of the context-name for a project-name and specific target-types: and build-types: . context-map: Content - <context-name> Required Specify an alternative context-name for a project. For the context-map: it is required to specify the <project-name> as part of the context-name . This project will use a different .build-type and/or +target-type as applied in the context-name . This remapping of the context applies for the specific type in the build-types: or target-types: list. Example 1: This application combines two projects for a multi-processor device, but the project HelloCM7 requires a different setting for the build-type name Release as this enables different settings within the *.cproject.yml file. target-types: - type: DualCore device: MyDualCoreDevice build-types: - type: Release # When applying build-type name 'release': context-map: - HelloCM7.flex_release # project HelloCM7 uses build-type name \"flex_release\" instead of \"release\" projects: - project: ./CM7/HelloCM7.cproject.yml - project: ./CM4/HelloCM4.cproject.yml Example 2: The following example uses three projects Demo , TFM and Boot . The project TFM should be always build using the context TFM.Release+LibMode . For the target-type name Board , the Boot project requires the +Flash target, but any build-type could be used. target-types: - type: Board # When applying target-type: 'Board': context-map: - TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode - Boot+Flash # for project Boot use target-type: Flash board: B-U585I-IOT02A - type: AVH # When applying target-type: 'AVH': context-map: - context: TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode device: ARM::SSE-300-MPS3 projects: - project: ./App/Demo.cproject.yml - project: ./Security/TFM.cproject.yml - project: ./Loader/Boot.cproject.yml","title":"context-map:"},{"location":"YML-Input-Format/#conditional-build","text":"It is possible to include or exclude items of a list node in the build process. for-compiler: includes items only for a compiler toolchain. for-context: includes items only for a context list. not-for-context: excludes items for a context list. Note for-context and not-for-context are mutually exclusive, only one occurrence can be specified for a list node .","title":"Conditional Build"},{"location":"YML-Input-Format/#for-compiler","text":"Depending on a compiler toolchain it is possible to include list nodes in the build process. Examples: for-compiler: AC6@6.16 # add item for Arm Compiler version 6.16 only for-compiler: GCC # for GCC Compiler (any version)","title":"for-compiler:"},{"location":"YML-Input-Format/#for-context","text":"A context list that adds a list-node for specific target-type and/or build-type names.","title":"for-context:"},{"location":"YML-Input-Format/#not-for-context","text":"A context list that removes a list-node for specific target-types: and/or build-types: .","title":"not-for-context:"},{"location":"YML-Input-Format/#context-list","text":"It is also possible to provide a context list with: - [.build-type][+target-type] - [.build-type][+target-type] Examples: for-context: - .Test # add item for build-type: Test (any target-type) for-context: # add item - .Debug # for build-type: Debug and - .Release+Production-HW # build-type: Release / target-type: Production-HW not-for-context: +Virtual # remove item for target-type: Virtual (any build-type) not-for-context: .Release+Virtual # remove item for build-type: Release with target-type: Virtual","title":"Context List"},{"location":"YML-Input-Format/#usage","text":"The keyword for-context: and not-for-context: can be used for the following list nodes : List Node Description - project: At projects: level it is possible to control inclusion of project. - layer: At layers: level it is possible to control inclusion of a software layer. The keyword for-context: , not-for-context: , and for-compiler: can be applied to the following list nodes : List Node Description - component: At components: level it is possible to control inclusion of a software component. - group: At groups: level it is possible to control inclusion of a file group. - setup: At setups: level it is define toolchain specific options that apply to the whole project. - file: At files: level it is possible to control inclusion of a file. The inclusion of a list node is processed with this hierarchy from top to bottom: project --> layer --> component / group --> file In other words, the restrictions specified by for-context: or not-for-context for a list node are applied to it child nodes. Child list nodes inherit the restrictions from their parent. Note With for-context: and not-for-context: the project-name of a context cannot be applied. The context name must therefore start with . to refer the build-type: or + to refer the target-type: .","title":"Usage"},{"location":"YML-Input-Format/#regular-expressions","text":"With for-context: and not-for-context: a regular expression can be used to refer to multiple context names. When a context name starts with the character \\ the regular expression expansion is enabled. The character \\ itself is not part of the sequence. Example: The following project is only included when the build-type: of a context contains Test . build-types: - Debug-Test: # Debug build with Test functionality : - Test-Release: # Release build with Test functionality : - Debug: : - Release: : project: Test.cproject.yml - for-context: \\.*Test*`","title":"Regular Expressions"},{"location":"YML-Input-Format/#multiple-projects","text":"The section Project setup for related projects describes the organization of multiple projects. The file *.csolution.yml describes the relationship of this projects and may also re-map target-types: and build-types: for this projects using context-map: .","title":"Multiple Projects"},{"location":"YML-Input-Format/#projects","text":"The YAML structure of the section projects: is: projects: Content - project: Required Path to the project file. for-context: Optional Include project for a list of build and target types. not-for-context: Optional Exclude project for a list of build and target types. Examples: This example uses two projects that are build in parallel using the same build-type: and target-type: . Such a setup is typical for multi-processor systems. projects: - project: ./CM0/CM0.cproject.yml # include project for Cortex-M0 processor - project: ./CM4/CM4.cproject.yml # include project for Cortex-M4 processor This example uses multiple projects, but with additional controls. projects: - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # build only when 'target-type: CM0-Addon' is selected for-compiler: GCC # build only when 'compiler: GCC' is selected define: # add additional defines during build process - test: 12 - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # specify use case for-compiler: AC6 # build only when 'compiler: AC6' is selected define: # add additional defines during build process - test: 9 - project: ./Debug/Debug.cproject.yml # specify cproject.yml file not-for-context: .Release # generated for any 'build-type:' except 'Release'","title":"projects:"},{"location":"YML-Input-Format/#source-file-management","text":"Keyword Used in files Description groups: *.cproject.yml , *.clayer.yml Start of a list that adds source groups and files to a project or layer. layers: *.cproject.yml Start of a list that adds software layers to a project. components: *.cproject.yml , *.clayer.yml Start of a list that adds software components to a project or layer.","title":"Source File Management"},{"location":"YML-Input-Format/#groups","text":"The groups: keyword specifies a list that adds source groups and files to a project or layer: groups: Content - group: Required Name of the group. for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. groups: Optional Start a nested list of groups. files: Optional Start a list of files. Example: See files: section.","title":"groups:"},{"location":"YML-Input-Format/#files","text":"Add source files to a project. files: Content - file: Required Name of the file. for-context: Optional Include file for a list of build and target types. not-for-context: Optional Exclude file for a list of build and target types. for-compiler: Optional Include file for a list of compilers. category: Optional Explicit file category to overwrite filename extension assignment. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. Note It is also possible to specify a Linker Script . Files with the extension .sct , .scf , .ld , and .icf are recognized as Linker Script files. Example: Add source files to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. groups: - group: \"Main File Group\" not-for-context: # includes this group not for the following: - .Release+Virtual # build-type 'Release' and target-type 'Virtual' - .Test-DSP+Virtual # build-type 'Test-DSP' and target-type 'Virtual' - +Board # target-type 'Board' files: - file: file1a.c - file: file1b.c define: - a: 1 undefine: - b optimize: size - group: \"Other File Group\" files: - file: file2a.c for-context: +Virtual # include this file only for target-type 'Virtual' define: - test: 2 - file: file2a.c not-for-context: +Virtual # include this file not for target-type 'Virtual' - file: file2b.c - group: \"Nested Group\" groups: - group: Subgroup1 files: - file: file-sub1-1.c - file: file-sub1-2.c - group: Subgroup2 files: - file: file-sub2-1.c - file: file-sub2-2.c It is also possible to include a file group for a specific compiler using for-compiler: or a specific target-type and/or build-type using for-context: or not-for-context: . groups: - group: \"Main File Group\" for-compiler: AC6 # includes this group only for Arm Compiler 6 files: - file: file1a.c - file: file2a.c - group: \"Main File Group\" for-compiler: GCC # includes this group only for GCC Compiler files: - file: file1b.c - file: file2b.c Using category: allows to specify pre-include files that are project-wide or related only to the group: . A global pre-include file is added to the compiler command line for all modules of the whole project (globally). - group: \"Main File Group\" files: - file: SystemDefinitions.h category: preIncludeGlobal A local pre-include file is added to the compiler command line for all modules of a group (locally). - group: \"Group 2\" files: - file: MyDefinitions.h category: preIncludeLocal","title":"files:"},{"location":"YML-Input-Format/#layers","text":"Add a software layer to a project. Used in *.cproject.yml files. layers: Content - layer: Optional Path to the *.clayer.yml file that defines the layer. type: Optional Refers to an expected layer type. for-context: Optional Include layer for a list of build and target types. not-for-context: Optional Exclude layer for a list of build and target types. Example: layers: # Socket - layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml for-context: - +IP-Stack - layer: ./Socket/WiFi/Socket.clayer.yml for-context: - +WiFi - layer: ./Socket/VSocket/Socket.clayer.yml for-context: - +AVH # Board - layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml for-context: - +IP-Stack # - +WiFi - layer: ./Board/B-U585I-IOT02A/Board.clayer.yml for-context: - +WiFi - layer: ./Board/AVH_MPS3_Corstone-300/Board.clayer.yml for-context: - +AVH","title":"layers:"},{"location":"YML-Input-Format/#layer-type","text":"The layer: - type: is used in combination with the meta-data of the connections: to check the list of available *.clayer.yml files for matching layers. Instead of an explicit layer: node that specifies a *.clayer.yml file, the type: is used to search for matching layers with the csolution command list layers . Example: layers: - type: Socket # search for matching layers of type `Socket` - type: Board # search for matching layers of type `Board` When combined with variables: it is possible to define the required *.clayer.yml files at the level of the *.csolution.yml file. Refer to variables: for an example.","title":"layer: - type:"},{"location":"YML-Input-Format/#components","text":"Add software components to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. components: Content - component: Required Name of the software component. for-context: Optional Include component for a list of build and target types. not-for-context: Optional Exclude component for a list of build and target types. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. instances: Optional Add multiple instances of component configuration files (default: 1) Example: components: - component: ARM::CMSIS:RTOS2:FreeRTOS&Cortex-M - component: ARM::RTOS&FreeRTOS:Config&CMSIS RTOS2 - component: ARM::RTOS&FreeRTOS:Core&Cortex-M - component: ARM::RTOS&FreeRTOS:Event Groups - component: ARM::RTOS&FreeRTOS:Heap&Heap_5 - component: ARM::RTOS&FreeRTOS:Stream Buffer - component: ARM::RTOS&FreeRTOS:Timers - component: ARM::Security:mbed TLS define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" - component: AWS::FreeRTOS:backoffAlgorithm - component: AWS::FreeRTOS:coreMQTT - component: AWS::FreeRTOS:coreMQTT Agent - component: AWS::FreeRTOS:corePKCS11&Custom define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" Note The name format for a software component is described under Name Conventions - Component Name Conventions .","title":"components:"},{"location":"YML-Input-Format/#instances","text":"Allows to add multiple instances of a component and actually applies to configuration files. For detailed description refer to Open-CMSIS-Pack specification - Component Instances Example: components: - component: USB:Device instances: 2 If the user selects multiple instances of the same component, all files with attribute config in the *.PDSC file will be copied multiple times to the project. The name of the component (for example config_mylib.h) will get a postfix _n whereby n is the instance number starting with 0. Instance 0: config_usb_device_0.h Instance 1: config_usb_device_1.h The availability of instances in a project can be made public in the RTE_Components.h file. The existing way to extend the %Instance% with the instance number n .","title":"instances:"},{"location":"YML-Input-Format/#prepost-build-steps","text":"The CMSIS-Toolbox supports pre-build and post-build steps that utilize external tools or scripts. Such external commands can be used for various tasks such as: pre-process source files. add checksums to a binary file. combine multiple ELF files into a single image. add a timestamp to an image ( always: ensures execution in every build). sign images for a bootloader.","title":"Pre/Post build steps"},{"location":"YML-Input-Format/#executes","text":"Execute an external command for pre or post build steps used in *.csolution.yml and *.cproject.yml files. The input: and output: files are used for dependency checking and schedule the execution (as pre-build or post-build step) during the build process of an application (option --context is not used). Other CMake Build scripts may be integrated into the overall build process using the executes: node. Refer to Build Operation - CMake Integration for an example that utilizes a file converter for web site images. The structure of the executes: node is: executes: Content - execute: Required The identifier is used as CMake target name and must not contain spaces and special characters; recommended is less then 32 characters. run: Required Command string with name of the program or script (optionally with path) along with argument string. always: Optional When present, the build step always runs and bypasses check for outdated output: files. input: Optional A list of input files (may contain Access Sequences ). output: Optional A list of output files (may contain Access Sequences ). for-context: Optional Run command for a list of build and target types (only supported in *.cproject.yml ). not-for-context: Optional Exclude run command for a list of build and target types (only supported in *.cproject.yml ). The run: command string uses these sequences to access input files and output files: run: command file access Description $input$ List of all input files separated by semicolon (;) character. $input(<n>)$ Input file in the list with index <n> ; first item is <n>=0 . $output$ List of all output files separated by semicolon (;) character. $output(<n>)$ Output file in the list with index <n> ; first item is <n>=0 . The run: command string also accepts these access sequences : $Bname$, $Dname$, $Pname$, $BuildType$, $TargetType$, $Compiler$, $Solution$, $Project$. It does not accept access sequences that reference directories or files as this bypasses the project dependency check . Instead use the input: list to pass files or directories. Notes: The execute: node is processed by the CMake build system. The order of execution depends on $input$ and $output files and is evaluated by CMake. The execute: node is processed only for an application build when no --context option is specified. The option --context-set can be used. CMake uses Linux-style path names with / characters, it does not accept the Windows-style \\ characters in the run: node to specify the location of an executeable tool. CMake provides several builtin command-line tools (copy, checksum, etc.) that run on every Host OS. Consider using these command-line tools instead of Windows or Linux specific commands. Use CMake -E help to list the available commands. The base directory for execution is not controlled by the CMSIS-Toolbox and typically the tmp directory. The commands specified by run: should be in the path of the Host OS or the path/tool should be passed using an $input(<n>)$ argument. At the *.csolution.yml level for-context: and not-for-context: is not evaluated. Examples: The tool gen_image combines multiple input images. It is called with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). solution: # executed as part of a complete solution build : executes: - execute: GenImage # generate final download image run: gen_image $input$ -o $output$ --sign # command string input: - $elf(Application)$ # combine these project parts - $elf(TFM)$ - $elf(Bootloader)$ output: - $SolutionDir()$/$Solution$.out # output file name The Windows batch file KeyGen.bat converts a input file keyfile.txt to a C source file. combines multiple input images. It is called with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). project: # executed as part of a project build executes: - execute: Generate Encryption Keys run: $input(1)$ $input(0)$ -o $output$ always: # always generate the keyfile.c as it has a timestamp input: - $ProjectDir()$/keyfile.txt # contains the key in text format - $SolutionDir()$/KeyGen.bat output: - $ProjectDir()$/keyfile.c # output as C source file that is part of this project The builtin CMake command-line tool copy is used to copy the ELF output file. project: # executed as part of a project build executes: - execute: copy-elf run: ${CMAKE_COMMAND} -E copy $input$ $output$ input: - $elf()$ output: - $OutDir()$/Project.out for-context: .Release Refer to Build Operation - CMake Integration for examples that integrate CMake scripts.","title":"executes:"},{"location":"YML-Input-Format/#connections","text":"The connections: node contains meta-data that describes the compatiblity of *.cproject.yml and *.clayer.yml project parts. The connections: node lists functionality (drivers, pins, and other software or hardware resources). The node consumes: lists required functionality; the node provides: is the implemented functionality of that project part. This enables reference applications that work across a range of different hardware targets where: The *.cproject.yml file of the reference application lists with the connections: node the required functionality with consumes: . The *.clayer.yml project part lists with the connections: node the implemented functionality with provides: . This works across multiple levels, which means that a *.clayer.yml file could also require other functionality using consumes: . The connections: node is used to identify compatible software layers. These software layers could be stored in CMSIS software packs using the following structure: A reference application described in a *.cproject.yml file could be provided in a git repository. This reference application uses software layers that are provided in CMSIS software packs. A CMSIS Board Support Pack (BSP) contains a configured board layer desribed in a *.clayer.yml file. This software layer is pre-configured for a range of use-cases and provides drivers for I2C and SPI interfaces along with pin definitions and provisions for an Ardunio shield. For a sensor, a CMSIS software pack contains the sensor middleware and software layer ( *.clayer.yml ) that describes the hardware of the Ardunio sensor shield. This shield can be applied to many different hardware boards that provide an Ardunio shield connector. This connections: node enables therefore software reuse in multiple ways: The board layer can be used by many different reference applications, as the provided: functionlity enables a wide range of use cases. The sensor hardware shield along with the middleware can be used across many different boards that provide an Ardunio shield connector along with board layer support. The structure of the connections: node is: connections: Description - connect: Required Lists specific functionality with a brief verbal description","title":"connections:"},{"location":"YML-Input-Format/#connect","text":"The connect: node describes one or more functionalities that belong together. connect: Description set: Optional Specifies a config-id . select value that identifies a configuration option info: Optional Verbal desription displayed when this connect is selected provides: Optional List of functionality ( key / value pairs) that are provided consumes: Optional List of functionality ( key / value pairs) that are required The behaviour of the connect: node depends on the usage in csolution project files. In a cproject.yml file the connect: node is always active. In a clayer.yml file the connect: node is only active if one or more key listed under provides: is listed under consumes: in other active connect: nodes. It is also active by default if the connect: node has no provides: node. Example: In the example below the connect for: Sensor Communication Interface is only active when the SENSOR_I2C is in the consumes: list of other active connect nodes. Sensor Interrupt is only active when the SENSOR_INT is in the consumes: list of other active connect nodes. Core Functionality is always active as it has not provides: list. layer: type: Shield connections: - connect: Sensor Communication Interface provides: - SENSOR_I2C consumes: - ARDUINO_UNO_I2C - connect: Sensor Interrupt provides: - SENSOR_INT consumes: - ARDUINO_UNO_D2 - connect: Core Functionality consumes: - CMSIS-RTOS2","title":"connect:"},{"location":"YML-Input-Format/#set","text":"Some hardware boards have configuration settings (DIP switch or jumper) that configure interfaces. These settings have impact to the functionality (for example hardware interfaces). With set: config-id . select the possible configration options are considered when evaluating compatible *.cproject.yml and *.clayer.yml project parts. The csolution Project Manager iterates the connect: node with a set: config-id . select as described below: For each config-id only one connect: node with a select value is active at a time. Each possible select value is checked for a matching configuration. When project parts have a matching configuration, the set: value along with the info: is shown to the user. This allows the user to enable the correct hardware options. Refer to Example: Sensor Shield for a usage example.","title":"set:"},{"location":"YML-Input-Format/#provides","text":"A user-defined key / value pair list of functionality that is implemented or provided by a project: or layer: . The csolution Project Manager combines all the key / value pairs that listed under provides: and matches it with the key / value pairs that are listed under consumes: . For key / value pairs listed under provides: the following rules exist for a match with consumes: key / value pair: It is possible to omit the value . It matches with an identical key listed in consumes: A value is interpreted as number. Depending on the value prefix, this number must be: when consumes: value is a plain number, identical with this value. when consumes: value is prefixed with + , higher or equal then this value or the sum of all values in multiple consumes: nodes.","title":"provides:"},{"location":"YML-Input-Format/#consumes","text":"A user-defined key / value pair list of functionality that is requried or consumed by a project: or layer: . For key / value pairs listed under consumed: the following rules exist: When no value is specified, it matches with any value of an identical key listed under provides: . A value is interpreted as number. This number must be identical in the provides: value pair. A value that is prefixed with + is interpreted as a number that is added together in case that the same key is listed multiple times under consumes: . The sum of this value must be lower or equal to the value upper limit of the provides: key .","title":"consumes:"},{"location":"YML-Input-Format/#example-board","text":"This connections: node of a board layer describes the available interfaces. The WiFi interface requires a CMSIS-RTOS2 function. connections: # describes functionality of a board layer - connect: WiFi interface provides: - CMSIS-Driver WiFi: requires: - CMSIS-RTOS2: - connect: SPI and UART interface provides: - CMSIS-Driver SPI: - CMSIS-Driver UART:","title":"Example: Board"},{"location":"YML-Input-Format/#example-simple-project","text":"This shows a the connections: node of a complete application project that is composed of two software layers. MyProject.cproject.yml connections: - connect: all resources provides: - RTOS2: # implements RTOS2 API interface consumes: - IoT_Socket: # requires IoT_Socket interface - STDOUT: # requires STDOUT interface - Heap: +30000 # requires additional 30000 bytes memory heap : layers: - layer: MySocket.clayer.yml - layer: MyBoard.clayer.yml MySocket.clayer.yml connections: - connect: consumes: - RTOS2: # requires RTOS2 API interface - VSocket: # requires VSocket interface - Heap: +20000 # requires additional 20000 bytes memory heap provides: - IoT_Socket: # provides IoT_Socket interface MyBoard.clayer.yml connections: - connect: consumes: - RTOS2: provides: - VSocket: - STDOUT: - Heap: 65536","title":"Example: Simple Project"},{"location":"YML-Input-Format/#example-sensor-shield","text":"This sensor shield layer provides a set of interfaces that are configurable. connections: - connect: I2C Interface 'Std' set: comm.I2C-Std info: JP1=Off JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C: - connect: I2C Interface 'Alt' set: comm.I2C-Alt info: JP1=On JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C-Alt: - connect: SPI Interface 'Alt' set: comm.SPI info: JP2=On provides: - Sensor_SPI: consumes: - Ardunio_Uno_SPI: - connect: Sensor Interrupt INT0 set: SensorIRQ.0 info: JP3=Off provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D2: - connect: Sensor Interrupt INT1 set: SensorIRQ.1 info: JP3=On provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D3:","title":"Example: Sensor Shield"},{"location":"build-operation/","text":"Build Operation This chapter explains the overall build process that of the CMSIS-Toolbox and how to add a new compiler toolchain. Build Process Overview This section contains details of the build process. Refer to Overall Workflow for a high-level description of the build process. Note The tool options --verbose and --debug enable detailed output about the build process for analysis. Refer to the chapter Build Tools for more information on the command line syntax. cbuild Build Invocation The cbuild utility controls the overall build process. It has two operating modes: build mode generates the application and is default command (no explicit command required). setup mode generates the setup information for an IDE to populate dialogs, IntelliSense, and project outline views. Details of the build mode Without a specific cbuild command, the application is built. The typical invocation is: cbuild <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] It generates the application program that is described with the <name>.csolution.yml project. When option --packs is used, it downloads missing software packs using cpackget . It calls csolution to process the the <name>.csolution.yml project. With option --update-rte new configuration files from software packs are updated and the RTE_Components.h file is recreated. With option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. With option --frozen-packs the file *.cbuild-pack.yml is used as input to issue an error when a pack version changes. The output are build information files with all relevant project information for the build process. The option --toolchain can be used to explicitly select a compiler. Note By default, the cbuild invocation does not update or change configuration files in the RTE Directory . Use the option --update-rte if this is required. Details of the setup mode The cbuild setup command prepares the data for an IDE environment. This command is called at start of an IDE or whenever a csolution project file is modified. The typical invocation is: cbuild setup <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] Typical IDE environments use a --context-set that specifies the context configuration of the application. For an application described by a <name>.csolution.yml file, these steps are executed: Check YML file syntax against schema for all files specified by <name>.csolution.yml . Check correctness of all files specified by <name>.csolution.yml . Evaluate the potential software layers for Reference Applications using variables: to refer to layers (if the value is undefined). All projects are considered in this step. Evaluate the selectable compiler toolchains when the csolution project does not contain a compiler: selection or the --toolchain option is not applied. The available toolchains are based on the compiler registration and the select-compiler: node in the file <name>.csolution.yml or cdefault.yml . Create the file compile_commands.json in the output directory for the context defined in *.cbuild-set.yml . Note The file compile_commands.json is generated by CMake with the option --target <context>-database and contains all source files of the context along with compiler options. It is used by the IntelliSense system of an IDE. The operation is further controlled by options: The option --packs downloads missing software packs. The option --context-set restricts the operation to the context-set selected by the file <name>.cbuild-set.yml . If this file is missing a file <name>.cbuild-set.yml with selection of the first target-type , the first build-type , and first project that is specified in the file <name>.csolution.yml is created. The option --update-rte updates the configuration files of the application. With the option --frozen-packs the file *.cbuild-pack.yml is used as input. An error is issued when a pack version changes. The option --toolchain can be used to explicitly select a compiler. csolution Project Manager csolution processes the csolution project files (in YAML format) and the *.pdsc metadata files of software packs and performs the following operations: In the Project Area : Generate build information files *.cbuild-idx.yml and *.cbuild.yml with all relevant project information for the build process. In the RTE Directory : Generate for each context the RTE_components.h file and pre-include files from the software pack ( *.pdsc ) metadata. Copy the configuration files from selected software componentsand provide PLM information. In the base directory of the solution : Generate the file *.cbuild-pack.yml that records all used software packs . With the option --frozen-packs this file is used as input. With the option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. When --context names are specified this file is updated with this selection. The picture below outlines the operation. cbuild2cmake Generate CMakeLists Files cbuild2cmake reads the build information files *.cbuild-idx.yml and *.cbuild.yml to get all relevant project information for the build process. It generates the following output files for CMake build system: Output Directory/File Description ./<tmp-dir>/CMakeList.txt Describes the overall application build process with the current context configuration. ./<tmp-dir>/<context> Each context has a separate sub-directory with the following files: ./<tmp-dir>/<context>/CMakeList.txt Describes the build process for this context. ./<tmp-dir>/<context>/toolchain.cmake Describes the toolchain used for this context. ./<tmp-dir>/<context>/groups.cmake Contains all definitions and source files that related to file groups . ./<tmp-dir>/<context>/components.cmake Contains all definitions and source files that related to components . CMake Invocation The CMake build system is invoked with the following commands: CMake configuration command defines build generator, source, and build directory with: cmake -G Ninja -S <tmpdir> -B <tmpdir> -Wnodev CMake build command to build the application program for each context with: cmake --build <tmpdir> -j <n> --target <context> CMake build command to generate the IntelliSense compile_commands.json (used by the command cbuild setup ) for each context with: cmake --build <tmpdir> -j <n> --target <context>-database Adding a Toolchain to CMSIS-Toolbox The following section explains how to add a compiler toolchain to the CMSIS-Toolbox. Steps The section below describes the steps to add a new compiler toolchain to the CMSIS-Toolbox. Define a compiler_name for the new compiler toolchain, i.e. CLang . Add this compiler_name to the \"CompilerType\": in the schema file ./tools/projmgr/schemas/common.schema.json . Create a new CMake file in ./tools/buildmgr/cbuildgen/config with the naming convention compiler_name.<version>.cmake . Map with the file compiler_name.<version>.cmake . the CMake input variables to the CMake toolchain variables. Use an existing *.cmake file, i.e. GCC.<version>.cmake as reference. CMake Variables The CMakeLists.txt file sets the following CMake input variables that should be processed by compiler_name.<version>.cmake . CMake Variable Possible Values Description BYTE_ORDER Little-endian, Big-endian Endian processor configuration CPU DCoreEnum Processor core selection FPU DfpuEnum Floating point unit support DSP DdspEnum DSP instruction set support TZ DtzEnum TrustZone support SECURE DsecureEnum Software model selection MVE DmveEnum MVE instruction set support BRANCHPROT BRANCHPROT values [Branch protection OPTIMIZE Optimize values Generic optimize levels for code generation WARNINGS Warnings values Control warning level for compiler diagnostic DEBUG Debug values Control the generation of debug information DEFINES Define symbols List of symbol #define statements BRANCHPROT Values The following table lists the possible values for the CMake variable BRANCHPROT . Values Description NO_BRANCHPROT Branch protection not used BTI Using BTI (Branch Target ID) BTI_SIGNRET Using BTI + Sign Return The compiler_name.<version>.cmake sets the following CMake variables to specify the toolchain and select toolchain options. CMake Variable Description ASM_CPU , CC_CPU , CXX_CPU Device selection set according to the combination of device attributes ( CPU , FPU , DSP , MVE , etc.) AS_LEG_CPU , AS_ARM_CPU , AS_GNU_CPU Similar to the previous item but for assembly dialect variants (if applicable) ASM_FLAGS , CC_FLAGS , CXX_FLAGS , LD_FLAGS Flags applicable to all modules of the given language CC_SECURE , LD_SECURE Flags applicable only for secure projects _PI Pre-include option _ISYS system include option LIB_PREFIX Generated library name prefix LIB_SUFFIX Generated library name suffix EXE_SUFFIX Generated executable name suffix ELF2HEX Flags for ELF to HEX conversion ELF2BIN Flags for ELF to BIN conversion CMAKE_C_COMPILER_ID CMake compiler identifier CMAKE_C_COMPILER_VERSION CMake compiler version CMake Integration The executes: node in the csolution project files allows to integrate other CMake projects or scripts. Example The following CMakeLists.txt file integrates the FCARM file converter that is part of the MDK-Middleware. The FCARM file converter reformats all web files into a single C-file which is then included and compiled into the project. # CMakeLists.txt for calling FCARM # Find input files in the input base directory and in its subfolders using recursive scanning # Format arguments and generate a steering command file, overcoming any command line length limitation # Call FCARM using the steering command file, generating the source file in the expected output # # Configuration Step: ${CMAKE_COMMAND} -G <generator> -S <source directory> -B <build directory> -DINPUT_DIRECTORY=<input base directory> -DOUTPUT=<output source file> # Build Step: ${CMAKE_COMMAND} --build <build directory> # # <generator>: underlying generator build system, e.g. Ninja # <source directory>: directory where this CMakeLists.txt resides # <build directory>: directory for temp files # <input base directory>: directory where input data is located # <output source file>: path and filename of source file to be generated cmake_minimum_required(VERSION 3.22) include(ExternalProject) project(\"FCARM\" NONE) file(GLOB_RECURSE INPUT ${INPUT_DIRECTORY}/*) foreach(ITEM ${INPUT}) cmake_path(RELATIVE_PATH ITEM BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE FILE) list(APPEND FILES ${FILE}) endforeach() string(REPLACE \";\" \",\\n\" FILES \"${FILES}\") cmake_path(RELATIVE_PATH OUTPUT BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE RELATIVE_OUTPUT) cmake_path(GET INPUT_DIRECTORY FILENAME INPUT_DIRECTORY_NAME) cmake_path(GET INPUT_DIRECTORY PARENT_PATH WORKING_DIRECTORY) set(COMMAND_FILE \"${CMAKE_CURRENT_BINARY_DIR}/Auto_FcArm_Cmd.inp\") file(WRITE ${COMMAND_FILE} \"${FILES}\\nTO ${RELATIVE_OUTPUT} RTE NOPRINT ROOT(${INPUT_DIRECTORY_NAME})\\n\") add_custom_target(FCARM ALL DEPENDS ${OUTPUT}) add_custom_command(OUTPUT ${OUTPUT} DEPENDS ${INPUT} COMMAND fcarm @${COMMAND_FILE} WORKING_DIRECTORY ${WORKING_DIRECTORY} ) Integration in a csolution project . In this case it is part of the *.csolution.yml , but it may be also part of *.cproject.yml file that uses the source file Web.c as input. The CMake build system checks for project dependencies and schedules the overall build process. solution: : executes: - execute: Run-FCARM run: ${CMAKE_COMMAND} -G Ninja -S ${INPUT_0} -B ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -DINPUT_DIRECTORY=${INPUT_1} -DOUTPUT=${OUTPUT} && ${CMAKE_COMMAND} --build ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -- --quiet always: input: - fcarm-cmake # CMake script directory - Web # Input directory with \"web files\" for FCARM output: - project/Web.c # Output file for FCARM Generator Integration The diagram below shows how a generator is integrated into the CMSIS build process. The data flow is exemplified on STM32CubeMX (Generator ID for this example is CubeMX ). The information about the project is delivered to the generator using the Generator Information files ( <csolution-name>.cbuild-gen-idx.yml and <context>.cbuild-gen.yml ). This information provides CubeMX with the project context, such as selected board or device, and CPU mode such as TrustZone disabled/enabled. The utility cbridge gets as parameter the <csolution-name>.cbuild-gen-idx.yml and calls the generator. For the CubeMX generator example these files are created: *.ioc CubeMX project file with current project settings *.c/.h source files, i.e. for interfacing with drivers <project-name>.cgen.yml (created by cbridge ) provides the data for project import into the csolution build process. Note CubeMX itself does not have the required interfaces to the csolution project format. The utility cbridge converts the build information files into command-line options for CubeMX. cbridge also generates the <project-name>.cgen.yml based on the information generated by CubeMX. Generator Start via component A <component> element with a generator attribute in a *.PDSC file is used to start the generator. Typically this component is provided in a Device Family Pack (DFP) or a Board Support Pack (BSP). Example component for CubeMX in DFP: <component generator=\"CubeMX\" Cclass=\"Device\" Cgroup=\"CubeMX\" Cversion=\"0.9.0\"> <description>Configure device or board with STM32CubeMX</description> </component> Note No <generator> element in the *.PDSC file is required when the Global Generator Registry File is used. The generator=\"id\" attribute of the <component> element in the *.PDSC file is the reference to the - id: list node in the global.generator.yml file. Global Generator Registry File For generators that have no <generator> element in the *.PDSC file, the global.generator.yml in the CMSIS-Toolbox ./etc directory contains is used. The generator: node in this YAML file registers the supported generators with the following keys: generator: Content - id: Required <generator-id> referred in the *.PDSC file download-url: Optional URL for downloading the generator run: Required Name and location of the utility that starts the generator path: Required Output directory of the generator. Contains the file *.cgen.yml . generator: - id: CubeMX download-url: https://www.st.com/en/development-tools/stm32cubemx.html#st-get-software run: ../bin/cbridge path: $SolutionDir()$/STM32CubeMX/$TargetType$ Note The only argument to the run: command is the path to the Generator Information Index File . There are no configurable parameters for this utility. The invocation is: cbrige <csolution-name>.cbuild-gen-idx.yml","title":"Build Operation"},{"location":"build-operation/#build-operation","text":"This chapter explains the overall build process that of the CMSIS-Toolbox and how to add a new compiler toolchain.","title":"Build Operation"},{"location":"build-operation/#build-process-overview","text":"This section contains details of the build process. Refer to Overall Workflow for a high-level description of the build process. Note The tool options --verbose and --debug enable detailed output about the build process for analysis. Refer to the chapter Build Tools for more information on the command line syntax.","title":"Build Process Overview"},{"location":"build-operation/#cbuild-build-invocation","text":"The cbuild utility controls the overall build process. It has two operating modes: build mode generates the application and is default command (no explicit command required). setup mode generates the setup information for an IDE to populate dialogs, IntelliSense, and project outline views.","title":"cbuild Build Invocation"},{"location":"build-operation/#details-of-the-build-mode","text":"Without a specific cbuild command, the application is built. The typical invocation is: cbuild <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] It generates the application program that is described with the <name>.csolution.yml project. When option --packs is used, it downloads missing software packs using cpackget . It calls csolution to process the the <name>.csolution.yml project. With option --update-rte new configuration files from software packs are updated and the RTE_Components.h file is recreated. With option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. With option --frozen-packs the file *.cbuild-pack.yml is used as input to issue an error when a pack version changes. The output are build information files with all relevant project information for the build process. The option --toolchain can be used to explicitly select a compiler. Note By default, the cbuild invocation does not update or change configuration files in the RTE Directory . Use the option --update-rte if this is required.","title":"Details of the build mode"},{"location":"build-operation/#details-of-the-setup-mode","text":"The cbuild setup command prepares the data for an IDE environment. This command is called at start of an IDE or whenever a csolution project file is modified. The typical invocation is: cbuild setup <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] Typical IDE environments use a --context-set that specifies the context configuration of the application. For an application described by a <name>.csolution.yml file, these steps are executed: Check YML file syntax against schema for all files specified by <name>.csolution.yml . Check correctness of all files specified by <name>.csolution.yml . Evaluate the potential software layers for Reference Applications using variables: to refer to layers (if the value is undefined). All projects are considered in this step. Evaluate the selectable compiler toolchains when the csolution project does not contain a compiler: selection or the --toolchain option is not applied. The available toolchains are based on the compiler registration and the select-compiler: node in the file <name>.csolution.yml or cdefault.yml . Create the file compile_commands.json in the output directory for the context defined in *.cbuild-set.yml . Note The file compile_commands.json is generated by CMake with the option --target <context>-database and contains all source files of the context along with compiler options. It is used by the IntelliSense system of an IDE. The operation is further controlled by options: The option --packs downloads missing software packs. The option --context-set restricts the operation to the context-set selected by the file <name>.cbuild-set.yml . If this file is missing a file <name>.cbuild-set.yml with selection of the first target-type , the first build-type , and first project that is specified in the file <name>.csolution.yml is created. The option --update-rte updates the configuration files of the application. With the option --frozen-packs the file *.cbuild-pack.yml is used as input. An error is issued when a pack version changes. The option --toolchain can be used to explicitly select a compiler.","title":"Details of the setup mode"},{"location":"build-operation/#csolution-project-manager","text":"csolution processes the csolution project files (in YAML format) and the *.pdsc metadata files of software packs and performs the following operations: In the Project Area : Generate build information files *.cbuild-idx.yml and *.cbuild.yml with all relevant project information for the build process. In the RTE Directory : Generate for each context the RTE_components.h file and pre-include files from the software pack ( *.pdsc ) metadata. Copy the configuration files from selected software componentsand provide PLM information. In the base directory of the solution : Generate the file *.cbuild-pack.yml that records all used software packs . With the option --frozen-packs this file is used as input. With the option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. When --context names are specified this file is updated with this selection. The picture below outlines the operation.","title":"csolution Project Manager"},{"location":"build-operation/#cbuild2cmake-generate-cmakelists-files","text":"cbuild2cmake reads the build information files *.cbuild-idx.yml and *.cbuild.yml to get all relevant project information for the build process. It generates the following output files for CMake build system: Output Directory/File Description ./<tmp-dir>/CMakeList.txt Describes the overall application build process with the current context configuration. ./<tmp-dir>/<context> Each context has a separate sub-directory with the following files: ./<tmp-dir>/<context>/CMakeList.txt Describes the build process for this context. ./<tmp-dir>/<context>/toolchain.cmake Describes the toolchain used for this context. ./<tmp-dir>/<context>/groups.cmake Contains all definitions and source files that related to file groups . ./<tmp-dir>/<context>/components.cmake Contains all definitions and source files that related to components .","title":"cbuild2cmake Generate CMakeLists Files"},{"location":"build-operation/#cmake-invocation","text":"The CMake build system is invoked with the following commands: CMake configuration command defines build generator, source, and build directory with: cmake -G Ninja -S <tmpdir> -B <tmpdir> -Wnodev CMake build command to build the application program for each context with: cmake --build <tmpdir> -j <n> --target <context> CMake build command to generate the IntelliSense compile_commands.json (used by the command cbuild setup ) for each context with: cmake --build <tmpdir> -j <n> --target <context>-database","title":"CMake Invocation"},{"location":"build-operation/#adding-a-toolchain-to-cmsis-toolbox","text":"The following section explains how to add a compiler toolchain to the CMSIS-Toolbox.","title":"Adding a Toolchain to CMSIS-Toolbox"},{"location":"build-operation/#steps","text":"The section below describes the steps to add a new compiler toolchain to the CMSIS-Toolbox. Define a compiler_name for the new compiler toolchain, i.e. CLang . Add this compiler_name to the \"CompilerType\": in the schema file ./tools/projmgr/schemas/common.schema.json . Create a new CMake file in ./tools/buildmgr/cbuildgen/config with the naming convention compiler_name.<version>.cmake . Map with the file compiler_name.<version>.cmake . the CMake input variables to the CMake toolchain variables. Use an existing *.cmake file, i.e. GCC.<version>.cmake as reference.","title":"Steps"},{"location":"build-operation/#cmake-variables","text":"The CMakeLists.txt file sets the following CMake input variables that should be processed by compiler_name.<version>.cmake . CMake Variable Possible Values Description BYTE_ORDER Little-endian, Big-endian Endian processor configuration CPU DCoreEnum Processor core selection FPU DfpuEnum Floating point unit support DSP DdspEnum DSP instruction set support TZ DtzEnum TrustZone support SECURE DsecureEnum Software model selection MVE DmveEnum MVE instruction set support BRANCHPROT BRANCHPROT values [Branch protection OPTIMIZE Optimize values Generic optimize levels for code generation WARNINGS Warnings values Control warning level for compiler diagnostic DEBUG Debug values Control the generation of debug information DEFINES Define symbols List of symbol #define statements","title":"CMake Variables"},{"location":"build-operation/#branchprot-values","text":"The following table lists the possible values for the CMake variable BRANCHPROT . Values Description NO_BRANCHPROT Branch protection not used BTI Using BTI (Branch Target ID) BTI_SIGNRET Using BTI + Sign Return The compiler_name.<version>.cmake sets the following CMake variables to specify the toolchain and select toolchain options. CMake Variable Description ASM_CPU , CC_CPU , CXX_CPU Device selection set according to the combination of device attributes ( CPU , FPU , DSP , MVE , etc.) AS_LEG_CPU , AS_ARM_CPU , AS_GNU_CPU Similar to the previous item but for assembly dialect variants (if applicable) ASM_FLAGS , CC_FLAGS , CXX_FLAGS , LD_FLAGS Flags applicable to all modules of the given language CC_SECURE , LD_SECURE Flags applicable only for secure projects _PI Pre-include option _ISYS system include option LIB_PREFIX Generated library name prefix LIB_SUFFIX Generated library name suffix EXE_SUFFIX Generated executable name suffix ELF2HEX Flags for ELF to HEX conversion ELF2BIN Flags for ELF to BIN conversion CMAKE_C_COMPILER_ID CMake compiler identifier CMAKE_C_COMPILER_VERSION CMake compiler version","title":"BRANCHPROT Values"},{"location":"build-operation/#cmake-integration","text":"The executes: node in the csolution project files allows to integrate other CMake projects or scripts.","title":"CMake Integration"},{"location":"build-operation/#example","text":"The following CMakeLists.txt file integrates the FCARM file converter that is part of the MDK-Middleware. The FCARM file converter reformats all web files into a single C-file which is then included and compiled into the project. # CMakeLists.txt for calling FCARM # Find input files in the input base directory and in its subfolders using recursive scanning # Format arguments and generate a steering command file, overcoming any command line length limitation # Call FCARM using the steering command file, generating the source file in the expected output # # Configuration Step: ${CMAKE_COMMAND} -G <generator> -S <source directory> -B <build directory> -DINPUT_DIRECTORY=<input base directory> -DOUTPUT=<output source file> # Build Step: ${CMAKE_COMMAND} --build <build directory> # # <generator>: underlying generator build system, e.g. Ninja # <source directory>: directory where this CMakeLists.txt resides # <build directory>: directory for temp files # <input base directory>: directory where input data is located # <output source file>: path and filename of source file to be generated cmake_minimum_required(VERSION 3.22) include(ExternalProject) project(\"FCARM\" NONE) file(GLOB_RECURSE INPUT ${INPUT_DIRECTORY}/*) foreach(ITEM ${INPUT}) cmake_path(RELATIVE_PATH ITEM BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE FILE) list(APPEND FILES ${FILE}) endforeach() string(REPLACE \";\" \",\\n\" FILES \"${FILES}\") cmake_path(RELATIVE_PATH OUTPUT BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE RELATIVE_OUTPUT) cmake_path(GET INPUT_DIRECTORY FILENAME INPUT_DIRECTORY_NAME) cmake_path(GET INPUT_DIRECTORY PARENT_PATH WORKING_DIRECTORY) set(COMMAND_FILE \"${CMAKE_CURRENT_BINARY_DIR}/Auto_FcArm_Cmd.inp\") file(WRITE ${COMMAND_FILE} \"${FILES}\\nTO ${RELATIVE_OUTPUT} RTE NOPRINT ROOT(${INPUT_DIRECTORY_NAME})\\n\") add_custom_target(FCARM ALL DEPENDS ${OUTPUT}) add_custom_command(OUTPUT ${OUTPUT} DEPENDS ${INPUT} COMMAND fcarm @${COMMAND_FILE} WORKING_DIRECTORY ${WORKING_DIRECTORY} ) Integration in a csolution project . In this case it is part of the *.csolution.yml , but it may be also part of *.cproject.yml file that uses the source file Web.c as input. The CMake build system checks for project dependencies and schedules the overall build process. solution: : executes: - execute: Run-FCARM run: ${CMAKE_COMMAND} -G Ninja -S ${INPUT_0} -B ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -DINPUT_DIRECTORY=${INPUT_1} -DOUTPUT=${OUTPUT} && ${CMAKE_COMMAND} --build ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -- --quiet always: input: - fcarm-cmake # CMake script directory - Web # Input directory with \"web files\" for FCARM output: - project/Web.c # Output file for FCARM","title":"Example"},{"location":"build-operation/#generator-integration","text":"The diagram below shows how a generator is integrated into the CMSIS build process. The data flow is exemplified on STM32CubeMX (Generator ID for this example is CubeMX ). The information about the project is delivered to the generator using the Generator Information files ( <csolution-name>.cbuild-gen-idx.yml and <context>.cbuild-gen.yml ). This information provides CubeMX with the project context, such as selected board or device, and CPU mode such as TrustZone disabled/enabled. The utility cbridge gets as parameter the <csolution-name>.cbuild-gen-idx.yml and calls the generator. For the CubeMX generator example these files are created: *.ioc CubeMX project file with current project settings *.c/.h source files, i.e. for interfacing with drivers <project-name>.cgen.yml (created by cbridge ) provides the data for project import into the csolution build process. Note CubeMX itself does not have the required interfaces to the csolution project format. The utility cbridge converts the build information files into command-line options for CubeMX. cbridge also generates the <project-name>.cgen.yml based on the information generated by CubeMX.","title":"Generator Integration"},{"location":"build-operation/#generator-start-via-component","text":"A <component> element with a generator attribute in a *.PDSC file is used to start the generator. Typically this component is provided in a Device Family Pack (DFP) or a Board Support Pack (BSP). Example component for CubeMX in DFP: <component generator=\"CubeMX\" Cclass=\"Device\" Cgroup=\"CubeMX\" Cversion=\"0.9.0\"> <description>Configure device or board with STM32CubeMX</description> </component> Note No <generator> element in the *.PDSC file is required when the Global Generator Registry File is used. The generator=\"id\" attribute of the <component> element in the *.PDSC file is the reference to the - id: list node in the global.generator.yml file.","title":"Generator Start via component"},{"location":"build-operation/#global-generator-registry-file","text":"For generators that have no <generator> element in the *.PDSC file, the global.generator.yml in the CMSIS-Toolbox ./etc directory contains is used. The generator: node in this YAML file registers the supported generators with the following keys: generator: Content - id: Required <generator-id> referred in the *.PDSC file download-url: Optional URL for downloading the generator run: Required Name and location of the utility that starts the generator path: Required Output directory of the generator. Contains the file *.cgen.yml . generator: - id: CubeMX download-url: https://www.st.com/en/development-tools/stm32cubemx.html#st-get-software run: ../bin/cbridge path: $SolutionDir()$/STM32CubeMX/$TargetType$ Note The only argument to the run: command is the path to the Generator Information Index File . There are no configurable parameters for this utility. The invocation is: cbrige <csolution-name>.cbuild-gen-idx.yml","title":"Global Generator Registry File"},{"location":"build-overview/","text":"Build Overview This chapter describes the overall concept of the CMSIS-Toolbox build process. It outlines the content of csolution project files that describes the software application, and contains references to examples and project templates. Project Examples helps to get started with the tools. Project Structure describes the overall structure of projects. Linker Script Management defines the available memory and controls the linker operation. Generator Support explains how to use configuration tools such as STM32CubeMX or MCUXpresso Config. Overview of Operation The following tools support the creation of build information for embedded applications: Tool Description cpackget Pack Manager: install and manage software packs in the host development environment. cbuild Build Invocation: orchestrate the build steps utilizing CMSIS tools and a CMake compilation process. csolution Project Manager: create build information for embedded applications that consist of one or more related projects. The tools process csolution project files (in YAML format) and software packs (in Open-CMSIS-Pack format) to generate independent projects which may be a part of a more complex application. Notes This documentation uses the filename extension *.yml , but the extension *.yaml is also supported. The term CMSIS solution refers to an application project that is specified with csolution project files . Software packs describe software components in Open-CMSIS-Pack format that can contain middleware, drivers, board support, or device support. Software packs also provide documentation, examples, and reusable software layers. The overall features are: Access the content of software packs in Open-CMSIS-Pack format to: Setup the tool chain based on a Device or Board that is defined in software packs. Add software components that are provided in the various software packs to the application. Organize applications (with a *.csolution.yml file) into projects that are independently managed (using *.cproject.yml files). Organize software layers (with a *.clayer.yml file) with pre-configured software components that enable code reuse across similar applications. Manage multiple hardware targets to allow application deployment to different hardware (test board, production hardware, etc.). Manage multiple build types to support software verification (debug build, test build, release build, etc.) Support multiple compiler toolchains (GCC, Arm Compiler 6, IAR, LLVM) for project deployment. The diagram below outlines the operation of the csolution command convert that processes one or more context configurations of the application (called csolution project ). Refer to Project Examples for more information. Input Files Description Generic Software Packs Provide re-usable software components that are typically configurable towards a user application. DFP Software Packs Device related information (including memory sizes) for the tool configuration. BSP Software Packs Board specific configuration (i.e. additional memory resources). cdefault.yml When enabled with cdefault: , setup of toolchain specific controls and pre-defined toolchains. *.csolution.yml Complete scope of the application with build order of sub-projects. Defines target and build types. *.cproject.yml Content of an independent build (linker or archiver run) - directly relates to a *.cprj file. *.clayer.yml Set of source files along with pre-configured components for reuse in different applications. Input/Output Files Description *.cbuild-pack.yml Exact list of the packs that are used by the application; enables reproducible builds as it locks the pack versions. *.cbuild-set.yml Specifies the context set of projects, target-types, and build-types that are used to generate the application image. Output Files Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.yml Build description of a single *.cproject.yml input file for each context. Project Build Files *.cprj Project build information in legacy format. Run-Time Environment (RTE) Contains the user configured files of a project along with RTE_Components.h inventory file. Linker Script Files Header file that describes the memory resources. To build an application project, the csolution command convert executes the following steps: Read Input Files: Read *.YML input files and check files against schema (disable schema check with option: --no-check-schema ) Parse *.YML input nodes. Load software packs for selected contexts (control packs with option: --load [latest|all|required] ). Process each project context (select a specific context with option: --context ): Apply pack: , device: , board: , and compiler: to filter the content of software packs. From groups: add the list of user source files. From components: add the list of component source files. From *.GPDSC files add the list of generated source files. Generate output files: Update configuration files in RTE directory (disable with option: --no-update-rte ). Print results of software component dependency validation. Create cbuild-idx.yml , cbuild.yml and *.CPRJ files. Source Code of Software Packs Software packs and the related components: allow you to share and reuse code. The content of a software pack is therefore read-only (with the exception of configuration files that are copied to the RTE directory ) as these source code files should not be modified by a user. The benefit is a clean project directory that only contains the user code as well as configuration files for components: . This keeps a repository small and makes it easy to upgrade to a new pack version . Note During development of a software pack you may install a repository that contains the source of the software pack. You may copy the content of a software pack to your project workspace and provide a path to the pack . Project Examples GitHub repositories The following repositories provide several working examples: Repository Description csolution-examples Contains several getting started examples that show single-core, multi-core, and TrustZone setup as well as how to use a generator (CubeMX). vscode-get-started Contains the setup for a VS Code development environment including an example project. github.com/Arm-Examples Contains many examples that include CMSIS-Toolbox setup. The section below explains the overall concepts considered by the csolution Project Manager based on examples. Template Projects The following *.csolution.yml templates may be used to create embedded applications. Template Description Simple A csolution.yml template with a single *.cproject.yml . Multicore A csolution.yml template with multiple *.cproject.yml files, each targeting one processor of a multicore device. TrustZone A csolution.yml template with a non-secure *.cproject.yml and an optional secure *.cproject.yml file. UnitTest A csolution.yml template that shares one HAL *.clayer.yml with multiple *.cproject.yml files for unit testing. To use these templates, copy the content of the folder to your own application folder. Then adapt the names accordingly and add missing information. Refer to CMSIS-Toolbox Templates for more details. Minimal Project Setup A minimal application requires two files: Sample.csolution.yml that defines a target type with board or device . It includes a project and selects a compiler . Sample.cproject.yml that defines the files and software components that are translated into an image or library archive. Note When no packs: are specified in csolution project files , the tools use the latest version of the installed packs. Simple Project: Sample.csolution.yml solution: cdefault: # use default setup for toolchains compiler: AC6 # select the compiler to use packs: # explicit pack selection may be omitted - pack: NXP::K32L3A60_DFP@16.0.0 # specify DFP - pack: NXP::FRDM-K32L3A6_BSP@16.0.0 target-types: - type: FRDM-K32L3A6 board: FRDM-K32L3A6 build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Sample.cproject.yml Simple Project: Sample.cproject.yml project: packs: - pack: ARM::CMSIS # specify additional packs groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup Context A context is defined in the *.csolution.yml file by projects: , target-types: , and build-types: . It identifies a configuration with project-name , build-type , and target-type and is used on various places in the CMSIS-Toolbox. The following context refers to the example above and selects the project: Sample.cproject.yml , with build-type: Debug and target-type: FRDM-K32L3A6 : Sample.Debug+FRDM-K32L3A6 The context allows to refer to each possible build combination that by default uses a different output directory . A context may be partly specified in many places. The context-set defines a combination of projects and is useful when an application is composed of multiple related projects . Toolchain Agnostic Project Generic Translation Control settings enable projects that work across the range of supported compilers (AC6, GCC, IAR, CLANG). The Translation Control settings are mapped to specify compiler controls by the build tools. cdefault.yml The cdefault.yml file contains a common set of compiler specific settings that select reasonable defaults with misc: controls for each compiler. The cdefault: node in the *.csolution.yml file enables the usage of this file. The directory <cmsis-toolbox-installation-dir>/etc contains a cdefault.yml file that is used when no local copy of the cdefault.yml file is provided. Note It is recommended to provide a local copy of the cdefault.yml file in the same directory that stores the *.csolution.yml file. Example: default: misc: - for-compiler: AC6 C-CPP: - -Wno-macro-redefined - -Wno-pragma-pack - -Wno-parentheses-equality - -Wno-license-management C: - -std=gnu11 ASM: - -masm=auto Link: - --entry=Reset_Handler - --map - --info summarysizes - --summary_stderr - --diag_suppress=L6314W - for-compiler: GCC C-CPP: - -masm-syntax-unified - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - --specs=nano.specs - --specs=nosys.specs - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - -Wl,--no-warn-rwx-segments # suppress incorrect linker warning - for-compiler: CLANG C-CPP: - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - -lcrt0 - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - for-compiler: IAR C-CPP: - --dlib_config DLib_Config_Full.h Link: - --map=$elf()$.map Compiler Selection Toolchain agnostic projects do not contain a compiler: selection in the *.csolution.yml project file. Instead the select-compiler: node may list the compilers that this csolution project is tested with. There are two ways to select a toolchain: An explicit compiler: selection in the *.csolution.yml project file: solution: cdefault: # use the cdefault.yml file with toolchain specific controls compiler: AC6 # select Arm Compiler : The command line option --toolchain of the cbuild or csolution tool overwrites any compiler: definition in the csolution project files. cbuild Hello.csolution.yml --toolchain GCC Reproducible builds Reproducible builds are supported by the *.cbuild-pack.yml file that is created and read by the csolution project manager. This file: Records the exact list of the pack versions used during creation of an application. Ensures that pack versions do not change during development even when new packs are installed on the host computer, for example to develop other applications. Note The *.cbuild-pack.yml file should be committed to a repository to ensure reproducible builds. The cbuild option --frozen-packs checks that the *.cbuild-pack.yml file exists and reports an error if any pack is changed or not available. To update a pack to a new version, delete the file *.cbuild-pack.yml or remove the information about a specific pack in this file. Repository Contents To support reproducible builds the following files should be committed to a repository of a version control system. All user source code files. All csolution project files ( cdefault.yml , *.csolution.yml , *.cproject.yml , etc.). All files in the RTE directory Ensure that there are no files with the extension .update@ as this indicates that configuration files are not up-to-date due to updated software packs. The file *.cbuild-pack.yml to allow reproducible builds . Optionally, the file *.cbuild-set.yml which defines the context set of the application that should be generated. Note If the file *.cbuild-set.yml file is missing, the setup command creates a *.cbuild-set file with selection of the first target-type and the first build-type . Software Layers Software layers collect source files and software components along with configuration files for re-use in different projects as shown in the picture below. Simple Example: This example uses a layer to include an RTOS kernel. Using a layer has several benefits, for example that the configuration can be shared across many projects. The file MyProject.cproject.yml includes the file RTOS.clayer.yml using the layers: node: project: groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup layers: - layer: ../Layer/RTOS.clayer.yml The RTOS.clayer.yml file defines the kernel along with configuration settings. layer: description: RTX RTOS with configuration settings packs: - pack: ARM:CMSIS-RTX components: - component: CMSIS:RTOS2:Keil RTX5&Source Re-target Example: The project AVH-MLOps-Main is a test project that shows retargeting to different processors using a layer. IoT Example: The project AWS_MQTT_MutualAuth_SW_Framework provides an IoT cloud application that is composed of various layers: Demo.cproject.yml : Implements the IoT Reference example. Socket.clayer.yml : A software layer that provides the socket interface for Internet connectivity. Board.clayer.yml : A software layer that provides the hardware interfaces to the device hardware. Example: Configuration Settings A software layer is a set of source files and pre-configured software components or source code that can be shared across multiple projects. To achieve this, the configuration files of a layer are stored within the directory structure of the software layer. This separate RTE Directory Structure allows that projects can share a layer with common configuration settings. Note When using a generator, such as CubeMX or MCUxpresso, the output should be redirected as described under Configure Generator Output . Software Layers in Packs Software layers for reference applications may be published in software packs. Refer to Pack Creation \u00bb Layers for more information. Project Setup for Multiple Targets and Builds Complex examples require frequently slightly different targets and/or modifications during build, i.e. for testing. The picture below shows a setup during software development that supports: Unit/Integration Testing on simulation models (called Virtual Hardware) where Virtual Drivers implement the interface to simulated I/O. Unit/Integration Testing for the same software setup on a physical board where Hardware Drivers implement the interface to physical I/O. System Testing where the software is combined with more software components that compose the final application. As the software may share a large set of common files, provisions are required to manage such projects. The common is to add: target-types (required) that select a target system. In the example this would be: Virtual : for simulation models. Board : for a physical evaluation board. Production-HW : for system integration test and product delivery on the final hardware. build-types (optional) add the flexibility to configure each target build towards a specific test. For example: Debug : for a full debug build of the software used in an interactive debug session. Test : for a specific timing test using a test interface with maximum code optimization. Release : for the final code deployment to the system. Flexible Builds for Multi-Target Projects Multi-target projects may be created using target-types that select different physical or virtual hardware systems. File: MultiTarget.csolution.yml solution: cdefault: compiler: AC6 : # pack definition not shown target-types: - type: Board board: NUCLEO-L552ZE-Q variables: - HAL-Layer: ./NUCLEO-L552ZE-Q/Board.clayer.yml - type: Production-HW device: STM32L552XY # specifies device variables: - HAL-Layer: ./HW/Production.clayer.yml - type: Virtual board: VHT-Corstone-300 # Virtual Hardware platform (appears as board) variables: - HAL-Layer: ./Corstone-300/AVH.clayer.yml build-types: - type: Debug optimize: none debug: on - type: Test optimize: size debug: on - type: Release optimize: size debug: off projects: - project: ./MyProject.cproject.yml File: MyProject.cproject.yml project: groups: - group: My group1 files: - file: file1a.c - file: file1b.c - file: file1c.c - group: My group2 files: - file: file2a.c - group: Test-Interface for-context: .Test files: - file: fileTa.c layers: - layer: $HAL-Layer$ # include target-type specific HAL layer components: - component: Device:Startup - component: CMSIS:RTOS2:FreeRTOS - component: ARM::CMSIS:DSP&Source # not added for build type: Test not-for-context: .Test Project Setup for Related Projects A solution is the software view of the complete system. It combines projects that can be generated independently and therefore manages related projects. It may be also deployed to different targets during development as described in the previous section under Project Setup for Multiple Targets and Builds . The picture below shows a system that is composed of: Project A that implements a time-critical control algorithm running on a independent processor #2. Project B that is a cloud connected IoT application with Machine Learning (ML) functionality. Project C that is the separate data model of the ML algorithm allowing independent updates. Project D that implements the device security (for example with TF-M that runs with TrustZone in secure mode). In addition, such systems may have a boot-loader that can also be implemented as another independent project. At the level of the *.csolution.yml file, the target-types: and build-types: are managed, so that a common set is available across all *.cproject.yml files the system. target-types: typically describe a different hardware target system. build-types: typically describe a build variant of the same hardware target system. Both types are used for peripherals and the same hardware configuration, but may compile a different variant (i.e. with test I/O enabled) of an application. Related Projects: iot-product.csolution.yml solution: : # setup not shown target-types: - type: Board board: NUCLEO-L552ZE-Q # uses device defined by the board - type: Production-HW device: STM32U5X # specifies device build-types: - type: Debug optimize: none debug: on - type: Release optimize: balanced debug: on - type: Test optimize: size debug: on projects: - project: ./security/TFM.cproject.yml # Only generated for build type: Release for-context: .Release - project: ./application/MQTT_AWS.cproject.yml - project: ./bootloader/Bootloader.cproject.yml # Not generated for target type: Board not-for-context: +Board Working with context-set Frequently, it is required to build applications with different context types. The following command line example generates the iot-product.csolution.yml with build type Debug for the project MQTT_AWS.cproject.yml , while the other projects use the build type Release . When using the option -S or --context-set , this selection is saved to the file iot-product.cbuild-set.yml located in the same directory as the *.csolution.yml file. Refer to File Structure of *.cbuild-set.yml for details. cbuild iot-product.csolution.yml -c TFM.Release+Board -c MQTT_AWS.Debug+Board -c Bootloader.Release+Board -S The saved context-set ( iot-product.cbuild-set.yml ) is used when the option -S or --context-set is used without option --context or -c . cbuild iot-product.csolution.yml -S Rules for context-set The same target-type must be selected for all projects. Only one build-type can be selected for a project. Projects that are not required can be excluded. External Tools and Build Order The executes: node integrates CMake scripts, projects, and external tools. The input: and output: list typically refers to files and therefore defines the build order of projects: When input: contains files that are the output of a cproject.yml this project part is build first. When output: contains files that are the input of a cproject.yml the execute: node is build first. Example: The KeyGenerator tool builds the file keys.c which is added as source file: in other projects. Using cbuild My.csolution.yml [--context-set] starts the build process of the application and runs the KeyGenerator before building projects that use the source file keys.c as input. Note Using cbuild with the option --context does not run execute: nodes as it triggers project builds only. The option --context-set must be used. solution: : executes: - execute: GenKeys # is a CMake target name run: KeyGenerator -k $input(0)$ -p $input(1)$ -o $output$ input: - $SolutionDir()$/keyfile.txt # input(0) contains key in text format - $SolutionDir()$/passcode.txt # input(1) contains pass code in text format output: - $SolutionDir()$/keys.c # output keys source file (input to other projects) Project Dependency An access sequence that refers to the output of another project also impacts the build order. Example: The access sequence $cmse-lib(Project_S)$ includes the secure entry library of Project_S . Hence, Project_S is built before the non-secure project part of the application. project: # Non-secure project : groups: - group: CMSE Library files: - file: $cmse-lib(Project_S)$ # Secure part of an application Project Structure This section describes how the csolution based project files should be organized to allow the scenarios described above. This section gives also guidelines for a directory structure. Refer to Directory Control for information about configuring these directories. Working Areas The table below explains the different working area sections of an application project. Working Area Access Description Project Area RW Contains user source code files managed by the user along with the project files (see next item). Project files RW Created by a user or an IDE to describe the application project. Component source code RO Content of software packs; the location is specified by the environment variable CMSIS_PACK_ROOT or the node pack: path in project files. Component Configuration\u200b RW User editable config files of software components that are copied to the RTE directory. Generator artifacts\u200b RO (see note) Managed by domain specific configuration tools such as STM32CubeMX or MCUXpresso. Build artifacts RW Created during the build process for example by a compiler. Note Some generators allow user modification to the generated files. For example, STM32CubeMX allows to modify source code between /* USER CODE BEGIN */ and /* USER CODE END */ and preserves this modification even when the STM32CubeMX regenerates the files. Project Area There are no strict rules on how to organize the project area that stores the user source code. However, the following guidelines apply: Each solution should have a distinct base directory. This directory contains the file *.csolution.yml which refers to the independent projects defined with *.cproject.yml files. Each project should have a distinct base directory. This directory contains the file *.cproject.yml that defines the content of the project. The source code of the project might be grouped in sub-directories that are typically stored in this base directory. The configuration\u200b files of the software components are typically stored in a sub-directory with the name ./RTE . A *.cproject.yml may refer one or more software layers with *.clayer.yml files. Each software layer should have a distinct base directory with a similar structure as a project. This base directory contains the file *.clayer.yml that defines the content of the software layer. It also contains the user source code (optionally organized in sub-directories) and the configuration\u200b files of software components that belong to this layer, typically stored in a sub-directory with the name ./RTE . RTE Directory Structure The table below summarizes the overall directory structure and further details the ./RTE directory. The ./RTE directory contains the configuration information for software components and is managed by the csolution Project Manager . It contains: Configuration files of the software components. These files have attr=\"config\" in the PDSC-file of the software packs. Refer to PLM of Configuration Files for more information. The file RTE_components.h and pre-include files that are generated based on the PDSC-file information of the software packs. Note The ./RTE directory structure is maintained by tools. You should not modify the structure of this directory. However, the complete directory should be committed to a repository of a version control system. Directory Structure Content <csolution> Base directory that contains one or more *.csolution.yml files. <project> Each project has its own directory; this base directory contains the *.cproject.yml file. <project>/RTE/<Cclass> Configurable files for each component Cclass have a common directory. <project>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory. <project>/RTE/<context-dir> Directory for RTE_components.h and pre-include files that are generated by the csolution Project Manager . <layer> Each layer has its own base directory; this directory contains the *.clayer.yml file. <layer>/RTE/<Cclass> Configurable files for each component Cclass have a common directory below the layer base directory. <layer>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory below the layer base directory. The <context-dir> has the following format: _<build-type>_<target-type> . Note cbuild does no longer generate the <context-dir> by default. It is therefore required to align the naming of <context-dir> with other tools (MDK, CMSIS-Pack-Eclipse, etc.) that support the CMSIS-Pack system. Output Directory Structure By default, the following output directories are used. Use cbuild to generate the content of these output directories. Output Content ./out/<project>/<target>/<build> Contains the final binary and symbol files of a project context. Software Components Software components are re-usable library or source files that require no modification in the user application. Optionally, configurable source and header files are provided that allow to set parameters for the software component. Configurable source and header files are copied to the project using the directory structure explained above. Libraries, source, and header files that are not configurable (and need no modification) are stored in the directory of the software component (typically part of CMSIS_Pack_ROOT) and get included directly from this location into the project. An include path to the header files of the software component is added to the C/C++ Compiler control string. Note The csolution command convert provides the option --no-update-rte that disables generation of files in the ./RTE directory and therefore the management of configuration files and the RTE_Components.h file. The csolution command update-rte only updates the configuration files in the RTE directory and provides with the option --verbose additional version details. PLM of Configuration Files Configurable source and header files have a version information that is required during Project Lifetime Management (PLM) of a project. The version number is important when the underlying software pack changes and provides a newer configuration file version. Depending on the PLM status of the application, csolution performs the following operation for configuration files: Add a software component for the first time: the related config file is copied twice into the related RTE project directory. The first copy can be modified by the user with the parameters for the user application. The second copy is an unmodified backup file with the format <configfile>.<ext>.base@version . Example: A configuration file ConfigFile.h at version 1.2.0 is copied: ./RTE/component_class/ConfigFile.h // user editable configuration file ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison `csolution` shows a user notification to indicate that files are added: ./RTE/component_class/ConfigFile.h - info: component 'name' added configuration file version '1.2.0' Note The unmodified files with @version information should be committed to the repository of the version control system as these files are used to upgrade configuration information using merge utilities. Upgrade (or downgrade) a software component: if the version of the unmodified backup file is identical, no operation is performed. If the version differs, the new configuration file is copied with the format <configfile>.<ext>.update@version . Example: after updating the configuration file ConfigFile.h to version 1.3.0 , the directory contains these files: ./RTE/component_class/ConfigFile.h // user editable configuration file (based on current version) ./RTE/component_class/ConfigFile.h.update@1.3.0 // new configuration file; used to start a 3-way merge ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison `csolution` displays a user notification to indicate that configuration files have changed: ./RTE/component_class/ConfigFile.h - warning: component 'name' upgrade for configuration file version '1.3.0' added, but file inactive User action to complete upgrade : The user has now several options (outside of csolution ) to merge the configuration file information. A potential way could be to use a 3-way merge utility. After merging the configuration file, the original base@version file should be deleted and the unmodified new version should become the new base@version . The previous configuration file may be stored as backup as shown below. ./RTE/component_class/ConfigFile.h // new configuration file with merge configuration ./RTE/component_class/ConfigFile.h.bak // previous configuration file stored as backup ./RTE/component_class/ConfigFile.h.base@1.3.0 // current unmodified configuration file with version // information; used as a base for version comparison Multiple Instances of Configuration files The system is also capable of handling multiple instances of configuration files as explained in the CMSIS-Pack specification under Component Instances . In this case, the instance %placeholder% is expanded as shown below. ./RTE/component_class/ConfigFile_0.h ./RTE/component_class/ConfigFile_0.h.base@1.2.0 ./RTE/component_class/ConfigFile_1.h ./RTE/component_class/ConfigFile_1.h.base@1.2.0 RTE_Components.h The file ./RTE/RTE_Components.h is created by the CMSIS Project Manager when the option --update-rte is used. This option is default for the csolution convert command. For each selected software component, it contains #define statements required by the component. These statements are defined in the *.PDSC file for that component. The following example shows a sample content of a RTE_Components.h file: /* Auto generated Run-Time-Environment Component Configuration File *** Do not modify ! *** */ #ifndef RTE_COMPONENTS_H #define RTE_COMPONENTS_H /* Define the Device Header File: */ #define CMSIS_device_header \"stm32f10x.h\" #define RTE_Network_Interface_ETH_0 /* Network Interface ETH 0 */ #define RTE_Network_Socket_BSD /* Network Socket BSD */ #define RTE_Network_Socket_TCP /* Network Socket TCP */ #define RTE_Network_Socket_UDP /* Network Socket UDP */ #endif /* RTE_COMPONENTS_H */ The typical usage of the RTE_Components.h file is in other header files to control the inclusion of files that are related to other components of the same software pack. #include \"RTE_Components.h\" #include CMSIS_device_header #ifdef RTE_Network_Interface_ETH_0 // if component Network Interface ETH 0 is included #include \"Net_Config_ETH_0.h\" // add the related configuration file for this component #endif CMSIS_device_header The preprocessor symbol CMSIS_device_header represents the device header file provided by the CMSIS-Core. It defines the registers and interrupt mapping of the device that is used. Refer to Reference Applications > Header File Structure for more information. _RTE_ Preprocessor Symbol The preprocessor symbol _RTE_ is added to the compiler invocation when a CMSIS build system manages the file RTE_Components.h . This symbol can be used as follows: #ifdef _RTE_ // Is a CMSIS build system used? #include \"RTE_Components.h\" // Include Run-Time-Environment symbols #else // Otherwise use different ways to supply required symbols #define CMSIS_device_header \"stm32f10x.h\" #endif Linker Script Management A Linker Script contains a series of Linker directives that specify the available memory and how it should be used in a project. The Linker directives reflect exactly the available memory resources and memory map for the project context. This section describes the Linker Script management of the csolution Project Manager : The linker: node specifies an explicit Linker Script and/or memory regions header file. This overrules Linker Scripts that are part of software components or specified using the file: notation. The linker: auto: enables the automatic Linker Script generation . If no linker: node is used, a Linker Script file can be provided as part of software components. The extensions .sct , .scf , .ld , and .icf are recognized as Linker Script files. If no Linker Script is found, the automatic Linker Script generation is used. Linker Script Preprocessing A standard C preprocessor is used for the Linker Script file when: the linker script file extension is *.src . the linker: node contains a regions: header file or a define: . Otherwise, no preprocessor is used and the Linker Script file is directly passed to the linker. Automatic Linker Script generation The automatic Linker Script generation uses a Linker Script template and generates a <regions>.h file based on information of the software packs using the: <device> - <memory> element in the DFP <board> - <memory> element in the BSP Both files, the Linker Script template and the <regions>.h are located in the RTE directory path \\RTE\\Device\\<device> . The <regions>.h file name is extended with: Bname when the project context uses a board: specification, i.e. regions_IMXRT1050-EVKB.h Dname when the project context only uses a device: specification, i.e. regions_stm32u585xx.h . Both files, the Linker Script template and the <regions>.h can be modified by the user as it might be required to adjust the memory regions or give additional attributes (such as noinit ). Note Refer to Create Applications - Configure Linker Scripts for more information. Linker Script Templates The following compiler specific Linker Script template files are copied to the \\RTE\\Device\\<device> directory when no Linker Script exists. The files are located in the directory <cmsis-toolbox-installation-dir>/etc of the CMSIS-Toolbox. Linker Script Template Linker control file for ... ac6_linker_script.sct.src Arm Compiler gcc_linker_script.ld.src GCC Compiler iar_linker_script.icf.src IAR Compiler clang_linker_script.ld.src CLANG Compiler (LLVM) Generator Support Generators , such as STM32CubeMX or MCUXpresso Config Tools, simplify the configuration for devices and boards. The CMSIS-Toolbox implements a generic interface for generators . Generators may be used to: Configure device and/or board settings, for example clock configuration or pinout. Add and configure software drivers, for example for UART, SPI, or I/O ports. Configure parameters of an algorithm, for example DSP filter design or motor control parameters. The steps for creating a *.csolution.yml application with a Generator are: Create the *.csolution.yml container that refers the projects and selects device: or board: (by using target-types: ) Create *.cproject.yml files that are referred by the *.csolution.yml container. Add components: to the *.cproject.yml file. For components that have a <generator-id> , run the related generator. The Generator can add files, components, and settings to a project using the Generator import file ( *.cgen.yml ) . The format of this file is similar to a software layer . Use a Generator An example that uses STM32CubeMX is provided in github.com/Open-CMSIS-Pack/csolution-examples . The ./CubeMX example is used below. To list the Generator configuration of a *.csolution.yml use: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # Name of the Generator base-dir: STM32CubeMX/MyBoard # Generator output directory for contexts listed below cgen-file: STM32CubeMX/MyBoard/CubeMX.cgen.yml # Generator import file for contexts listed below context: CubeMX.Debug+MyBoard context: CubeMX.Release+MyBoard To run the generator (in this case CubeMX) use: csolution CubeMX.csolution.yml run --generator CubeMX Configure Generator Output The Generator output directory and the name of the Generator import file ( *.cgen.yml ) can be configured using the node generators: as shown below. generators: options: - generator: CubeMX path: ../STM32CubeMX name: MyConfig A Generator output configuration is useful for: Using a board layer that is shareable across multiple projects. Using different configurations across a *.csolution.yml project. Detailed Usage Instructions Configure STM32 Devices with CubeMX explains how to use STM32CubeMX to manage device and board configuration.","title":"Build Overview"},{"location":"build-overview/#build-overview","text":"This chapter describes the overall concept of the CMSIS-Toolbox build process. It outlines the content of csolution project files that describes the software application, and contains references to examples and project templates. Project Examples helps to get started with the tools. Project Structure describes the overall structure of projects. Linker Script Management defines the available memory and controls the linker operation. Generator Support explains how to use configuration tools such as STM32CubeMX or MCUXpresso Config.","title":"Build Overview"},{"location":"build-overview/#overview-of-operation","text":"The following tools support the creation of build information for embedded applications: Tool Description cpackget Pack Manager: install and manage software packs in the host development environment. cbuild Build Invocation: orchestrate the build steps utilizing CMSIS tools and a CMake compilation process. csolution Project Manager: create build information for embedded applications that consist of one or more related projects. The tools process csolution project files (in YAML format) and software packs (in Open-CMSIS-Pack format) to generate independent projects which may be a part of a more complex application. Notes This documentation uses the filename extension *.yml , but the extension *.yaml is also supported. The term CMSIS solution refers to an application project that is specified with csolution project files . Software packs describe software components in Open-CMSIS-Pack format that can contain middleware, drivers, board support, or device support. Software packs also provide documentation, examples, and reusable software layers. The overall features are: Access the content of software packs in Open-CMSIS-Pack format to: Setup the tool chain based on a Device or Board that is defined in software packs. Add software components that are provided in the various software packs to the application. Organize applications (with a *.csolution.yml file) into projects that are independently managed (using *.cproject.yml files). Organize software layers (with a *.clayer.yml file) with pre-configured software components that enable code reuse across similar applications. Manage multiple hardware targets to allow application deployment to different hardware (test board, production hardware, etc.). Manage multiple build types to support software verification (debug build, test build, release build, etc.) Support multiple compiler toolchains (GCC, Arm Compiler 6, IAR, LLVM) for project deployment. The diagram below outlines the operation of the csolution command convert that processes one or more context configurations of the application (called csolution project ). Refer to Project Examples for more information. Input Files Description Generic Software Packs Provide re-usable software components that are typically configurable towards a user application. DFP Software Packs Device related information (including memory sizes) for the tool configuration. BSP Software Packs Board specific configuration (i.e. additional memory resources). cdefault.yml When enabled with cdefault: , setup of toolchain specific controls and pre-defined toolchains. *.csolution.yml Complete scope of the application with build order of sub-projects. Defines target and build types. *.cproject.yml Content of an independent build (linker or archiver run) - directly relates to a *.cprj file. *.clayer.yml Set of source files along with pre-configured components for reuse in different applications. Input/Output Files Description *.cbuild-pack.yml Exact list of the packs that are used by the application; enables reproducible builds as it locks the pack versions. *.cbuild-set.yml Specifies the context set of projects, target-types, and build-types that are used to generate the application image. Output Files Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.yml Build description of a single *.cproject.yml input file for each context. Project Build Files *.cprj Project build information in legacy format. Run-Time Environment (RTE) Contains the user configured files of a project along with RTE_Components.h inventory file. Linker Script Files Header file that describes the memory resources. To build an application project, the csolution command convert executes the following steps: Read Input Files: Read *.YML input files and check files against schema (disable schema check with option: --no-check-schema ) Parse *.YML input nodes. Load software packs for selected contexts (control packs with option: --load [latest|all|required] ). Process each project context (select a specific context with option: --context ): Apply pack: , device: , board: , and compiler: to filter the content of software packs. From groups: add the list of user source files. From components: add the list of component source files. From *.GPDSC files add the list of generated source files. Generate output files: Update configuration files in RTE directory (disable with option: --no-update-rte ). Print results of software component dependency validation. Create cbuild-idx.yml , cbuild.yml and *.CPRJ files.","title":"Overview of Operation"},{"location":"build-overview/#source-code-of-software-packs","text":"Software packs and the related components: allow you to share and reuse code. The content of a software pack is therefore read-only (with the exception of configuration files that are copied to the RTE directory ) as these source code files should not be modified by a user. The benefit is a clean project directory that only contains the user code as well as configuration files for components: . This keeps a repository small and makes it easy to upgrade to a new pack version . Note During development of a software pack you may install a repository that contains the source of the software pack. You may copy the content of a software pack to your project workspace and provide a path to the pack .","title":"Source Code of Software Packs"},{"location":"build-overview/#project-examples","text":"","title":"Project Examples"},{"location":"build-overview/#github-repositories","text":"The following repositories provide several working examples: Repository Description csolution-examples Contains several getting started examples that show single-core, multi-core, and TrustZone setup as well as how to use a generator (CubeMX). vscode-get-started Contains the setup for a VS Code development environment including an example project. github.com/Arm-Examples Contains many examples that include CMSIS-Toolbox setup. The section below explains the overall concepts considered by the csolution Project Manager based on examples.","title":"GitHub repositories"},{"location":"build-overview/#template-projects","text":"The following *.csolution.yml templates may be used to create embedded applications. Template Description Simple A csolution.yml template with a single *.cproject.yml . Multicore A csolution.yml template with multiple *.cproject.yml files, each targeting one processor of a multicore device. TrustZone A csolution.yml template with a non-secure *.cproject.yml and an optional secure *.cproject.yml file. UnitTest A csolution.yml template that shares one HAL *.clayer.yml with multiple *.cproject.yml files for unit testing. To use these templates, copy the content of the folder to your own application folder. Then adapt the names accordingly and add missing information. Refer to CMSIS-Toolbox Templates for more details.","title":"Template Projects"},{"location":"build-overview/#minimal-project-setup","text":"A minimal application requires two files: Sample.csolution.yml that defines a target type with board or device . It includes a project and selects a compiler . Sample.cproject.yml that defines the files and software components that are translated into an image or library archive. Note When no packs: are specified in csolution project files , the tools use the latest version of the installed packs. Simple Project: Sample.csolution.yml solution: cdefault: # use default setup for toolchains compiler: AC6 # select the compiler to use packs: # explicit pack selection may be omitted - pack: NXP::K32L3A60_DFP@16.0.0 # specify DFP - pack: NXP::FRDM-K32L3A6_BSP@16.0.0 target-types: - type: FRDM-K32L3A6 board: FRDM-K32L3A6 build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Sample.cproject.yml Simple Project: Sample.cproject.yml project: packs: - pack: ARM::CMSIS # specify additional packs groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup","title":"Minimal Project Setup"},{"location":"build-overview/#context","text":"A context is defined in the *.csolution.yml file by projects: , target-types: , and build-types: . It identifies a configuration with project-name , build-type , and target-type and is used on various places in the CMSIS-Toolbox. The following context refers to the example above and selects the project: Sample.cproject.yml , with build-type: Debug and target-type: FRDM-K32L3A6 : Sample.Debug+FRDM-K32L3A6 The context allows to refer to each possible build combination that by default uses a different output directory . A context may be partly specified in many places. The context-set defines a combination of projects and is useful when an application is composed of multiple related projects .","title":"Context"},{"location":"build-overview/#toolchain-agnostic-project","text":"Generic Translation Control settings enable projects that work across the range of supported compilers (AC6, GCC, IAR, CLANG). The Translation Control settings are mapped to specify compiler controls by the build tools.","title":"Toolchain Agnostic Project"},{"location":"build-overview/#cdefaultyml","text":"The cdefault.yml file contains a common set of compiler specific settings that select reasonable defaults with misc: controls for each compiler. The cdefault: node in the *.csolution.yml file enables the usage of this file. The directory <cmsis-toolbox-installation-dir>/etc contains a cdefault.yml file that is used when no local copy of the cdefault.yml file is provided. Note It is recommended to provide a local copy of the cdefault.yml file in the same directory that stores the *.csolution.yml file. Example: default: misc: - for-compiler: AC6 C-CPP: - -Wno-macro-redefined - -Wno-pragma-pack - -Wno-parentheses-equality - -Wno-license-management C: - -std=gnu11 ASM: - -masm=auto Link: - --entry=Reset_Handler - --map - --info summarysizes - --summary_stderr - --diag_suppress=L6314W - for-compiler: GCC C-CPP: - -masm-syntax-unified - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - --specs=nano.specs - --specs=nosys.specs - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - -Wl,--no-warn-rwx-segments # suppress incorrect linker warning - for-compiler: CLANG C-CPP: - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - -lcrt0 - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - for-compiler: IAR C-CPP: - --dlib_config DLib_Config_Full.h Link: - --map=$elf()$.map","title":"cdefault.yml"},{"location":"build-overview/#compiler-selection","text":"Toolchain agnostic projects do not contain a compiler: selection in the *.csolution.yml project file. Instead the select-compiler: node may list the compilers that this csolution project is tested with. There are two ways to select a toolchain: An explicit compiler: selection in the *.csolution.yml project file: solution: cdefault: # use the cdefault.yml file with toolchain specific controls compiler: AC6 # select Arm Compiler : The command line option --toolchain of the cbuild or csolution tool overwrites any compiler: definition in the csolution project files. cbuild Hello.csolution.yml --toolchain GCC","title":"Compiler Selection"},{"location":"build-overview/#reproducible-builds","text":"Reproducible builds are supported by the *.cbuild-pack.yml file that is created and read by the csolution project manager. This file: Records the exact list of the pack versions used during creation of an application. Ensures that pack versions do not change during development even when new packs are installed on the host computer, for example to develop other applications. Note The *.cbuild-pack.yml file should be committed to a repository to ensure reproducible builds. The cbuild option --frozen-packs checks that the *.cbuild-pack.yml file exists and reports an error if any pack is changed or not available. To update a pack to a new version, delete the file *.cbuild-pack.yml or remove the information about a specific pack in this file.","title":"Reproducible builds"},{"location":"build-overview/#repository-contents","text":"To support reproducible builds the following files should be committed to a repository of a version control system. All user source code files. All csolution project files ( cdefault.yml , *.csolution.yml , *.cproject.yml , etc.). All files in the RTE directory Ensure that there are no files with the extension .update@ as this indicates that configuration files are not up-to-date due to updated software packs. The file *.cbuild-pack.yml to allow reproducible builds . Optionally, the file *.cbuild-set.yml which defines the context set of the application that should be generated. Note If the file *.cbuild-set.yml file is missing, the setup command creates a *.cbuild-set file with selection of the first target-type and the first build-type .","title":"Repository Contents"},{"location":"build-overview/#software-layers","text":"Software layers collect source files and software components along with configuration files for re-use in different projects as shown in the picture below. Simple Example: This example uses a layer to include an RTOS kernel. Using a layer has several benefits, for example that the configuration can be shared across many projects. The file MyProject.cproject.yml includes the file RTOS.clayer.yml using the layers: node: project: groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup layers: - layer: ../Layer/RTOS.clayer.yml The RTOS.clayer.yml file defines the kernel along with configuration settings. layer: description: RTX RTOS with configuration settings packs: - pack: ARM:CMSIS-RTX components: - component: CMSIS:RTOS2:Keil RTX5&Source Re-target Example: The project AVH-MLOps-Main is a test project that shows retargeting to different processors using a layer. IoT Example: The project AWS_MQTT_MutualAuth_SW_Framework provides an IoT cloud application that is composed of various layers: Demo.cproject.yml : Implements the IoT Reference example. Socket.clayer.yml : A software layer that provides the socket interface for Internet connectivity. Board.clayer.yml : A software layer that provides the hardware interfaces to the device hardware. Example:","title":"Software Layers"},{"location":"build-overview/#configuration-settings","text":"A software layer is a set of source files and pre-configured software components or source code that can be shared across multiple projects. To achieve this, the configuration files of a layer are stored within the directory structure of the software layer. This separate RTE Directory Structure allows that projects can share a layer with common configuration settings. Note When using a generator, such as CubeMX or MCUxpresso, the output should be redirected as described under Configure Generator Output .","title":"Configuration Settings"},{"location":"build-overview/#software-layers-in-packs","text":"Software layers for reference applications may be published in software packs. Refer to Pack Creation \u00bb Layers for more information.","title":"Software Layers in Packs"},{"location":"build-overview/#project-setup-for-multiple-targets-and-builds","text":"Complex examples require frequently slightly different targets and/or modifications during build, i.e. for testing. The picture below shows a setup during software development that supports: Unit/Integration Testing on simulation models (called Virtual Hardware) where Virtual Drivers implement the interface to simulated I/O. Unit/Integration Testing for the same software setup on a physical board where Hardware Drivers implement the interface to physical I/O. System Testing where the software is combined with more software components that compose the final application. As the software may share a large set of common files, provisions are required to manage such projects. The common is to add: target-types (required) that select a target system. In the example this would be: Virtual : for simulation models. Board : for a physical evaluation board. Production-HW : for system integration test and product delivery on the final hardware. build-types (optional) add the flexibility to configure each target build towards a specific test. For example: Debug : for a full debug build of the software used in an interactive debug session. Test : for a specific timing test using a test interface with maximum code optimization. Release : for the final code deployment to the system. Flexible Builds for Multi-Target Projects Multi-target projects may be created using target-types that select different physical or virtual hardware systems. File: MultiTarget.csolution.yml solution: cdefault: compiler: AC6 : # pack definition not shown target-types: - type: Board board: NUCLEO-L552ZE-Q variables: - HAL-Layer: ./NUCLEO-L552ZE-Q/Board.clayer.yml - type: Production-HW device: STM32L552XY # specifies device variables: - HAL-Layer: ./HW/Production.clayer.yml - type: Virtual board: VHT-Corstone-300 # Virtual Hardware platform (appears as board) variables: - HAL-Layer: ./Corstone-300/AVH.clayer.yml build-types: - type: Debug optimize: none debug: on - type: Test optimize: size debug: on - type: Release optimize: size debug: off projects: - project: ./MyProject.cproject.yml File: MyProject.cproject.yml project: groups: - group: My group1 files: - file: file1a.c - file: file1b.c - file: file1c.c - group: My group2 files: - file: file2a.c - group: Test-Interface for-context: .Test files: - file: fileTa.c layers: - layer: $HAL-Layer$ # include target-type specific HAL layer components: - component: Device:Startup - component: CMSIS:RTOS2:FreeRTOS - component: ARM::CMSIS:DSP&Source # not added for build type: Test not-for-context: .Test","title":"Project Setup for Multiple Targets and Builds"},{"location":"build-overview/#project-setup-for-related-projects","text":"A solution is the software view of the complete system. It combines projects that can be generated independently and therefore manages related projects. It may be also deployed to different targets during development as described in the previous section under Project Setup for Multiple Targets and Builds . The picture below shows a system that is composed of: Project A that implements a time-critical control algorithm running on a independent processor #2. Project B that is a cloud connected IoT application with Machine Learning (ML) functionality. Project C that is the separate data model of the ML algorithm allowing independent updates. Project D that implements the device security (for example with TF-M that runs with TrustZone in secure mode). In addition, such systems may have a boot-loader that can also be implemented as another independent project. At the level of the *.csolution.yml file, the target-types: and build-types: are managed, so that a common set is available across all *.cproject.yml files the system. target-types: typically describe a different hardware target system. build-types: typically describe a build variant of the same hardware target system. Both types are used for peripherals and the same hardware configuration, but may compile a different variant (i.e. with test I/O enabled) of an application. Related Projects: iot-product.csolution.yml solution: : # setup not shown target-types: - type: Board board: NUCLEO-L552ZE-Q # uses device defined by the board - type: Production-HW device: STM32U5X # specifies device build-types: - type: Debug optimize: none debug: on - type: Release optimize: balanced debug: on - type: Test optimize: size debug: on projects: - project: ./security/TFM.cproject.yml # Only generated for build type: Release for-context: .Release - project: ./application/MQTT_AWS.cproject.yml - project: ./bootloader/Bootloader.cproject.yml # Not generated for target type: Board not-for-context: +Board","title":"Project Setup for Related Projects"},{"location":"build-overview/#working-with-context-set","text":"Frequently, it is required to build applications with different context types. The following command line example generates the iot-product.csolution.yml with build type Debug for the project MQTT_AWS.cproject.yml , while the other projects use the build type Release . When using the option -S or --context-set , this selection is saved to the file iot-product.cbuild-set.yml located in the same directory as the *.csolution.yml file. Refer to File Structure of *.cbuild-set.yml for details. cbuild iot-product.csolution.yml -c TFM.Release+Board -c MQTT_AWS.Debug+Board -c Bootloader.Release+Board -S The saved context-set ( iot-product.cbuild-set.yml ) is used when the option -S or --context-set is used without option --context or -c . cbuild iot-product.csolution.yml -S Rules for context-set The same target-type must be selected for all projects. Only one build-type can be selected for a project. Projects that are not required can be excluded.","title":"Working with context-set"},{"location":"build-overview/#external-tools-and-build-order","text":"The executes: node integrates CMake scripts, projects, and external tools. The input: and output: list typically refers to files and therefore defines the build order of projects: When input: contains files that are the output of a cproject.yml this project part is build first. When output: contains files that are the input of a cproject.yml the execute: node is build first. Example: The KeyGenerator tool builds the file keys.c which is added as source file: in other projects. Using cbuild My.csolution.yml [--context-set] starts the build process of the application and runs the KeyGenerator before building projects that use the source file keys.c as input. Note Using cbuild with the option --context does not run execute: nodes as it triggers project builds only. The option --context-set must be used. solution: : executes: - execute: GenKeys # is a CMake target name run: KeyGenerator -k $input(0)$ -p $input(1)$ -o $output$ input: - $SolutionDir()$/keyfile.txt # input(0) contains key in text format - $SolutionDir()$/passcode.txt # input(1) contains pass code in text format output: - $SolutionDir()$/keys.c # output keys source file (input to other projects)","title":"External Tools and Build Order"},{"location":"build-overview/#project-dependency","text":"An access sequence that refers to the output of another project also impacts the build order. Example: The access sequence $cmse-lib(Project_S)$ includes the secure entry library of Project_S . Hence, Project_S is built before the non-secure project part of the application. project: # Non-secure project : groups: - group: CMSE Library files: - file: $cmse-lib(Project_S)$ # Secure part of an application","title":"Project Dependency"},{"location":"build-overview/#project-structure","text":"This section describes how the csolution based project files should be organized to allow the scenarios described above. This section gives also guidelines for a directory structure. Refer to Directory Control for information about configuring these directories.","title":"Project Structure"},{"location":"build-overview/#working-areas","text":"The table below explains the different working area sections of an application project. Working Area Access Description Project Area RW Contains user source code files managed by the user along with the project files (see next item). Project files RW Created by a user or an IDE to describe the application project. Component source code RO Content of software packs; the location is specified by the environment variable CMSIS_PACK_ROOT or the node pack: path in project files. Component Configuration\u200b RW User editable config files of software components that are copied to the RTE directory. Generator artifacts\u200b RO (see note) Managed by domain specific configuration tools such as STM32CubeMX or MCUXpresso. Build artifacts RW Created during the build process for example by a compiler. Note Some generators allow user modification to the generated files. For example, STM32CubeMX allows to modify source code between /* USER CODE BEGIN */ and /* USER CODE END */ and preserves this modification even when the STM32CubeMX regenerates the files.","title":"Working Areas"},{"location":"build-overview/#project-area","text":"There are no strict rules on how to organize the project area that stores the user source code. However, the following guidelines apply: Each solution should have a distinct base directory. This directory contains the file *.csolution.yml which refers to the independent projects defined with *.cproject.yml files. Each project should have a distinct base directory. This directory contains the file *.cproject.yml that defines the content of the project. The source code of the project might be grouped in sub-directories that are typically stored in this base directory. The configuration\u200b files of the software components are typically stored in a sub-directory with the name ./RTE . A *.cproject.yml may refer one or more software layers with *.clayer.yml files. Each software layer should have a distinct base directory with a similar structure as a project. This base directory contains the file *.clayer.yml that defines the content of the software layer. It also contains the user source code (optionally organized in sub-directories) and the configuration\u200b files of software components that belong to this layer, typically stored in a sub-directory with the name ./RTE .","title":"Project Area"},{"location":"build-overview/#rte-directory-structure","text":"The table below summarizes the overall directory structure and further details the ./RTE directory. The ./RTE directory contains the configuration information for software components and is managed by the csolution Project Manager . It contains: Configuration files of the software components. These files have attr=\"config\" in the PDSC-file of the software packs. Refer to PLM of Configuration Files for more information. The file RTE_components.h and pre-include files that are generated based on the PDSC-file information of the software packs. Note The ./RTE directory structure is maintained by tools. You should not modify the structure of this directory. However, the complete directory should be committed to a repository of a version control system. Directory Structure Content <csolution> Base directory that contains one or more *.csolution.yml files. <project> Each project has its own directory; this base directory contains the *.cproject.yml file. <project>/RTE/<Cclass> Configurable files for each component Cclass have a common directory. <project>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory. <project>/RTE/<context-dir> Directory for RTE_components.h and pre-include files that are generated by the csolution Project Manager . <layer> Each layer has its own base directory; this directory contains the *.clayer.yml file. <layer>/RTE/<Cclass> Configurable files for each component Cclass have a common directory below the layer base directory. <layer>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory below the layer base directory. The <context-dir> has the following format: _<build-type>_<target-type> . Note cbuild does no longer generate the <context-dir> by default. It is therefore required to align the naming of <context-dir> with other tools (MDK, CMSIS-Pack-Eclipse, etc.) that support the CMSIS-Pack system.","title":"RTE Directory Structure"},{"location":"build-overview/#output-directory-structure","text":"By default, the following output directories are used. Use cbuild to generate the content of these output directories. Output Content ./out/<project>/<target>/<build> Contains the final binary and symbol files of a project context.","title":"Output Directory Structure"},{"location":"build-overview/#software-components","text":"Software components are re-usable library or source files that require no modification in the user application. Optionally, configurable source and header files are provided that allow to set parameters for the software component. Configurable source and header files are copied to the project using the directory structure explained above. Libraries, source, and header files that are not configurable (and need no modification) are stored in the directory of the software component (typically part of CMSIS_Pack_ROOT) and get included directly from this location into the project. An include path to the header files of the software component is added to the C/C++ Compiler control string. Note The csolution command convert provides the option --no-update-rte that disables generation of files in the ./RTE directory and therefore the management of configuration files and the RTE_Components.h file. The csolution command update-rte only updates the configuration files in the RTE directory and provides with the option --verbose additional version details.","title":"Software Components"},{"location":"build-overview/#plm-of-configuration-files","text":"Configurable source and header files have a version information that is required during Project Lifetime Management (PLM) of a project. The version number is important when the underlying software pack changes and provides a newer configuration file version. Depending on the PLM status of the application, csolution performs the following operation for configuration files: Add a software component for the first time: the related config file is copied twice into the related RTE project directory. The first copy can be modified by the user with the parameters for the user application. The second copy is an unmodified backup file with the format <configfile>.<ext>.base@version . Example: A configuration file ConfigFile.h at version 1.2.0 is copied: ./RTE/component_class/ConfigFile.h // user editable configuration file ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison `csolution` shows a user notification to indicate that files are added: ./RTE/component_class/ConfigFile.h - info: component 'name' added configuration file version '1.2.0' Note The unmodified files with @version information should be committed to the repository of the version control system as these files are used to upgrade configuration information using merge utilities. Upgrade (or downgrade) a software component: if the version of the unmodified backup file is identical, no operation is performed. If the version differs, the new configuration file is copied with the format <configfile>.<ext>.update@version . Example: after updating the configuration file ConfigFile.h to version 1.3.0 , the directory contains these files: ./RTE/component_class/ConfigFile.h // user editable configuration file (based on current version) ./RTE/component_class/ConfigFile.h.update@1.3.0 // new configuration file; used to start a 3-way merge ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison `csolution` displays a user notification to indicate that configuration files have changed: ./RTE/component_class/ConfigFile.h - warning: component 'name' upgrade for configuration file version '1.3.0' added, but file inactive User action to complete upgrade : The user has now several options (outside of csolution ) to merge the configuration file information. A potential way could be to use a 3-way merge utility. After merging the configuration file, the original base@version file should be deleted and the unmodified new version should become the new base@version . The previous configuration file may be stored as backup as shown below. ./RTE/component_class/ConfigFile.h // new configuration file with merge configuration ./RTE/component_class/ConfigFile.h.bak // previous configuration file stored as backup ./RTE/component_class/ConfigFile.h.base@1.3.0 // current unmodified configuration file with version // information; used as a base for version comparison","title":"PLM of Configuration Files"},{"location":"build-overview/#multiple-instances-of-configuration-files","text":"The system is also capable of handling multiple instances of configuration files as explained in the CMSIS-Pack specification under Component Instances . In this case, the instance %placeholder% is expanded as shown below. ./RTE/component_class/ConfigFile_0.h ./RTE/component_class/ConfigFile_0.h.base@1.2.0 ./RTE/component_class/ConfigFile_1.h ./RTE/component_class/ConfigFile_1.h.base@1.2.0","title":"Multiple Instances of Configuration files"},{"location":"build-overview/#rte_componentsh","text":"The file ./RTE/RTE_Components.h is created by the CMSIS Project Manager when the option --update-rte is used. This option is default for the csolution convert command. For each selected software component, it contains #define statements required by the component. These statements are defined in the *.PDSC file for that component. The following example shows a sample content of a RTE_Components.h file: /* Auto generated Run-Time-Environment Component Configuration File *** Do not modify ! *** */ #ifndef RTE_COMPONENTS_H #define RTE_COMPONENTS_H /* Define the Device Header File: */ #define CMSIS_device_header \"stm32f10x.h\" #define RTE_Network_Interface_ETH_0 /* Network Interface ETH 0 */ #define RTE_Network_Socket_BSD /* Network Socket BSD */ #define RTE_Network_Socket_TCP /* Network Socket TCP */ #define RTE_Network_Socket_UDP /* Network Socket UDP */ #endif /* RTE_COMPONENTS_H */ The typical usage of the RTE_Components.h file is in other header files to control the inclusion of files that are related to other components of the same software pack. #include \"RTE_Components.h\" #include CMSIS_device_header #ifdef RTE_Network_Interface_ETH_0 // if component Network Interface ETH 0 is included #include \"Net_Config_ETH_0.h\" // add the related configuration file for this component #endif","title":"RTE_Components.h"},{"location":"build-overview/#cmsis_device_header","text":"The preprocessor symbol CMSIS_device_header represents the device header file provided by the CMSIS-Core. It defines the registers and interrupt mapping of the device that is used. Refer to Reference Applications > Header File Structure for more information.","title":"CMSIS_device_header"},{"location":"build-overview/#_rte_-preprocessor-symbol","text":"The preprocessor symbol _RTE_ is added to the compiler invocation when a CMSIS build system manages the file RTE_Components.h . This symbol can be used as follows: #ifdef _RTE_ // Is a CMSIS build system used? #include \"RTE_Components.h\" // Include Run-Time-Environment symbols #else // Otherwise use different ways to supply required symbols #define CMSIS_device_header \"stm32f10x.h\" #endif","title":"_RTE_ Preprocessor Symbol"},{"location":"build-overview/#linker-script-management","text":"A Linker Script contains a series of Linker directives that specify the available memory and how it should be used in a project. The Linker directives reflect exactly the available memory resources and memory map for the project context. This section describes the Linker Script management of the csolution Project Manager : The linker: node specifies an explicit Linker Script and/or memory regions header file. This overrules Linker Scripts that are part of software components or specified using the file: notation. The linker: auto: enables the automatic Linker Script generation . If no linker: node is used, a Linker Script file can be provided as part of software components. The extensions .sct , .scf , .ld , and .icf are recognized as Linker Script files. If no Linker Script is found, the automatic Linker Script generation is used.","title":"Linker Script Management"},{"location":"build-overview/#linker-script-preprocessing","text":"A standard C preprocessor is used for the Linker Script file when: the linker script file extension is *.src . the linker: node contains a regions: header file or a define: . Otherwise, no preprocessor is used and the Linker Script file is directly passed to the linker.","title":"Linker Script Preprocessing"},{"location":"build-overview/#automatic-linker-script-generation","text":"The automatic Linker Script generation uses a Linker Script template and generates a <regions>.h file based on information of the software packs using the: <device> - <memory> element in the DFP <board> - <memory> element in the BSP Both files, the Linker Script template and the <regions>.h are located in the RTE directory path \\RTE\\Device\\<device> . The <regions>.h file name is extended with: Bname when the project context uses a board: specification, i.e. regions_IMXRT1050-EVKB.h Dname when the project context only uses a device: specification, i.e. regions_stm32u585xx.h . Both files, the Linker Script template and the <regions>.h can be modified by the user as it might be required to adjust the memory regions or give additional attributes (such as noinit ). Note Refer to Create Applications - Configure Linker Scripts for more information.","title":"Automatic Linker Script generation"},{"location":"build-overview/#linker-script-templates","text":"The following compiler specific Linker Script template files are copied to the \\RTE\\Device\\<device> directory when no Linker Script exists. The files are located in the directory <cmsis-toolbox-installation-dir>/etc of the CMSIS-Toolbox. Linker Script Template Linker control file for ... ac6_linker_script.sct.src Arm Compiler gcc_linker_script.ld.src GCC Compiler iar_linker_script.icf.src IAR Compiler clang_linker_script.ld.src CLANG Compiler (LLVM)","title":"Linker Script Templates"},{"location":"build-overview/#generator-support","text":"Generators , such as STM32CubeMX or MCUXpresso Config Tools, simplify the configuration for devices and boards. The CMSIS-Toolbox implements a generic interface for generators . Generators may be used to: Configure device and/or board settings, for example clock configuration or pinout. Add and configure software drivers, for example for UART, SPI, or I/O ports. Configure parameters of an algorithm, for example DSP filter design or motor control parameters. The steps for creating a *.csolution.yml application with a Generator are: Create the *.csolution.yml container that refers the projects and selects device: or board: (by using target-types: ) Create *.cproject.yml files that are referred by the *.csolution.yml container. Add components: to the *.cproject.yml file. For components that have a <generator-id> , run the related generator. The Generator can add files, components, and settings to a project using the Generator import file ( *.cgen.yml ) . The format of this file is similar to a software layer .","title":"Generator Support"},{"location":"build-overview/#use-a-generator","text":"An example that uses STM32CubeMX is provided in github.com/Open-CMSIS-Pack/csolution-examples . The ./CubeMX example is used below. To list the Generator configuration of a *.csolution.yml use: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # Name of the Generator base-dir: STM32CubeMX/MyBoard # Generator output directory for contexts listed below cgen-file: STM32CubeMX/MyBoard/CubeMX.cgen.yml # Generator import file for contexts listed below context: CubeMX.Debug+MyBoard context: CubeMX.Release+MyBoard To run the generator (in this case CubeMX) use: csolution CubeMX.csolution.yml run --generator CubeMX","title":"Use a Generator"},{"location":"build-overview/#configure-generator-output","text":"The Generator output directory and the name of the Generator import file ( *.cgen.yml ) can be configured using the node generators: as shown below. generators: options: - generator: CubeMX path: ../STM32CubeMX name: MyConfig A Generator output configuration is useful for: Using a board layer that is shareable across multiple projects. Using different configurations across a *.csolution.yml project.","title":"Configure Generator Output"},{"location":"build-overview/#detailed-usage-instructions","text":"Configure STM32 Devices with CubeMX explains how to use STM32CubeMX to manage device and board configuration.","title":"Detailed Usage Instructions"},{"location":"build-tools/","text":"Build Tools This chapter describes the tools cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). It includes command line syntax details and examples. Requirements Install the CMSIS-Toolbox as described in chapter Installation . The CMSIS-Pack repository must be present in the host development environment. There are several ways to configure the CMSIS-Pack repository: Use the cpackget Package Installer command init to initialize the CMSIS-Pack root directory , update the pack index file . Then add software packs . Share an existing CMSIS-Pack repository (i.e. from an IDE) via the environment variable CMSIS_PACK_ROOT . cbuild Invocation Orchestrate the overall build steps utilizing the various tools of the CMSIS-Toolbox and a CMake-based compilation process. cbuild: Build Invocation 2.6.0 (C) 2024 Arm Ltd. and Contributors Usage: cbuild [command] <name>.csolution.yml [options] Commands: help Help about any command list List information about environment, toolchains, and contexts setup Generate project data for IDE environment Options: --cbuildgen Generate legacy *.cprj files and use cbuildgen backend -C, --clean Remove intermediate and output directories -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -S, --context-set Select the context names from cbuild-set.yml for generating the target application -d, --debug Enable debug messages --frozen-packs Pack list and versions from cbuild-pack.yml are fixed and raises errors if it changes -g, --generator arg Select build system generator (default \"Ninja\") -h, --help Print usage -j, --jobs int Number of job slots for parallel execution (default 8) -l, --load arg Set policy for packs loading [latest | all | required] (default \"required\") --log arg Save output messages in a log file -O, --output arg Add prefix to 'outdir' and 'tmpdir' -p, --packs Download missing software packs with cpackget -q, --quiet Suppress output messages except build invocations -r, --rebuild Remove intermediate and output directories and rebuild -s, --schema Validate project input file(s) against schema -t, --target arg Optional CMake target name --toolchain arg Input toolchain to be used --update-rte Update the RTE directory and files -v, --verbose Enable verbose messages from toolchain builds -V, --version Print version Use \"cbuild [command] --help\" for more information about a command. Note By default, the cbuild invocation does not update the RTE Directory . If required, use the option --update-rte . csolution Invocation Create build information for embedded applications that consist of one or more related projects. csolution: Project Manager 2.6.0 (C) 2024 Arm Ltd. and Contributors Usage: csolution <command> [<name>.csolution.yml] [options] Commands: convert Convert user input *.yml files to *.cprj files list boards Print list of available board names list configs Print list of configuration files list contexts Print list of contexts in a <name>.csolution.yml list components Print list of available components list dependencies Print list of unresolved project dependencies list devices Print list of available device names list environment Print list of environment configurations list generators Print list of code generators of a given context list layers Print list of available, referenced and compatible layers list packs Print list of used packs from the pack repository list toolchains Print list of supported toolchains run Run code generator update-rte Create/update configuration files and validate solution Options: -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -d, --debug Enable debug messages -D, --dry-run Enable dry-run -e, --export arg Set suffix for exporting <context><suffix>.cprj retaining only specified versions -f, --filter arg Filter words -g, --generator arg Code generator identifier -l, --load arg Set policy for packs loading [latest | all | required] -L, --clayer-path arg Set search path for external clayers -m, --missing List only required packs that are missing in the pack repository -n, --no-check-schema Skip schema check -N, --no-update-rte Skip creation of RTE directory and files -o,-O --output arg Add prefix to 'outdir' and 'tmpdir' -q, --quiet Run silently, printing only error messages -R, --relative-paths Print paths relative to project or ${CMSIS_PACK_ROOT} -S, --context-set Select the context names from cbuild-set.yml for generating the target application -t, --toolchain arg Selection of the toolchain used in the project optionally with version -v, --verbose Enable verbose messages -V, --version Print version Use 'csolution <command> -h' for more information about a command. cpackget Invocation Manage the installation of software packs on the host computer. Usage: cpackget [command] [flags] Available Commands: add Add Open-CMSIS-Pack packages checksum-create Generates a .checksum file containing the digests of a pack checksum-verify Verifies the integrity of a pack using its .checksum file completion Generate the autocompletion script for the specified shell connection Check online connection to default or given URL help Help about any command init Initializes a pack root folder list List installed packs rm Remove Open-CMSIS-Pack packages signature-create Digitally signs a pack with a X.509 certificate or PGP key signature-verify Verifies a signed pack update Update Open-CMSIS-Pack packages to latest update-index Update the public index Flags: -C, --concurrent-downloads uint Number of concurrent batch downloads. Set to 0 to disable concurrency (default 20) -h, --help help for cpackget -R, --pack-root string Specifies pack root folder. Defaults to CMSIS_PACK_ROOT environment variable -q, --quiet Run cpackget silently, printing only error messages -T, --timeout uint Set maximum duration (in seconds) of a download. Disabled by default -v, --verbose Sets verboseness level: None (Errors + Info + Warnings), -v (all + Debugging). -V, --version Prints the version number of cpackget and exit Use \"cpackget [command] --help\" for more information about a command. Command Examples List Environment Print the settings of the host development environment to verify the correctness of the tool installation. cbuild list environment List Available Toolchains Print the installed toolchains in the host development environment to identify the available compilers. The option --verbose provides additional path information. cbuild list toolchains -v Build a Project This command builds a project that is defined in the file example.csolution.yml : cbuild example.csolution.yml Options allow to rebuild and download missing software packs or to select specific context settings: cbuild example.csolution.yml --rebuild --packs --context .Release For reproducible builds in CI environments, fixed software pack versions are provided by the file *.cbuild-pack.yml . An error is reported if the file *.cbuild-pack.yml does not exist or packs are added/removed. Refer to reproducible builds for more information. cbuild example.csolution.yml --frozen-packs --packs --rebuild It is also possible to overwrite the toolchain selection and use a different toolchain for translation: cbuild example.csolution.yml --toolchain GCC Note The --toolchain option is useful for: Testing a new compiler or a different compiler version on the overall project. For unit test applications to allow the usage of different compilers. In DevOps systems that run CI test with a matrix build, it is sometimes required to separate the output of various builds. The option --output adds a prefix to the output directory for outdir: , tmpdir: and build information files. The following commands build the project with the AC6 and GCC compiler and separate the directories for output and temporary files. cbuild example.csolution.yml --toolchain AC6 --output outAC6 cbuild example.csolution.yml --toolchain GCC --output outGCC Note The --output option is not recommended in an IDE environment as it changes the location of mandatory build information files that are used by the IDE . Update RTE Configuration Files The Component Configuration\u200b is stored in the RTE directory . When files are missing or new software pack versions are installed, it might be required to update the RTE configuration files: csolution example.csolution.yml --update-rte Add Software Packs To install software packs from a public web service, run: cpackget add Arm::CMSIS cpackget add Arm::CMSIS@5.9.0 # optional with version specification List Installed Packs Print a list of installed packs. The list can be filtered by words provided with the option --filter : csolution list packs [-f \"<filter words>\"] Print a list of packs that are required by the example.csolution.yml . csolution list packs example.csolution.yml Install Missing Packs Print a list of missing packs required by the example.csolution.yml but not available in the pack repository to the file packs.txt . These missing packs can then be installed using the cpackget tool. csolution list packs example.csolution.yml -m >packs.txt cpackget update-index # optional to ensure that pack index is up-to-date cpackget add -f packs.txt List Devices or Boards Print a list of available device or board names. The list can be filtered by words provided with the option --filter : csolution list devices csolution list boards --filter NXP List Unresolved Dependencies Device, board, and software components are specified as part of the *.csolution.yml and *.cproject.yml files. Print a list of unresolved project dependencies. The list may be filtered by words provided with the option --filter : csolution list dependencies mysolution.csolution.yml [-f \"<filter words>\"] Create Build Information Convert example.csolution.yml into build information files. csolution convert example.csolution.yml Convert specific contexts of a *.csolution.yml file into build information files. csolution convert SimpleTZ.csolution.yml -c CM33_s.Debug -c CM33_ns.Release+AVH List Compatible Layers List compatible layers for ./fxls8962_normal_spi.csolution.yml and the context *+frdmk22f_agmp03 . This contains also setup information. csolution list layers ./fxls8962_normal_spi.csolution.yml -c *+frdmk22f_agmp03 Refer to Software Layers for more information. Use Generators List external code generators that are used to create software components. It outputs the generator ID that is required for the run command. When using the option --verbose the generator out directory is listed. csolution list generators mysolution.csolution.yml -v Run a generator (in this case STM32CubeMX) for a specific project context. Note that the context can be omitted when the same generator output directory is used. csolution run -g CubeMX mysolution.csolution.yml -c Blinky.Debug+STM32L4 Use context set When working with multiple related projects , it might be necessary to combine different build types for debug and download in the target hardware. With the option --context-set the selected --context options can be saved and re-used. Write the selected --context options to the file SimpleTZ.cbuild-set.yml . Refer to file structure of *.cbuild-set.yml for details. cbuild SimpleTZ.csolution.yml -S -c CM33_s.Release -c CM33_ns.Debug Read the previously stored --context setup from the file SimpleTZ.cbuild-set.yml . cbuild SimpleTZ.csolution.yml -S List configuration files List all configuration files that belong to software components and are stored in the RTE directory . When updating software packs , it shows also the update status of each file. csolution list configs SimpleTZ.csolution.yml -S Setup Project (for IDE) In an IDE environment, this command downloads missing packs, creates build information files , and generates the file compile_commands.json for IntelliSense. Refer to cbuild setup command for more information. cbuild setup example.csolution.yml --context-set --packs Note cbuild setup always enables the option --schema to validate the correct YML syntax in the csolution project files. Specify CMSIS-Pack root directory cpackget is compatible with other CMSIS-Pack management tools, such as the Pack Installer available in MDK or Eclipse variants. There are two ways to specify the CMSIS-PACK root directory: With the CMSIS_PACK_ROOT environment variable. Refer to Installation - Environment Variables . With the option --pack-root <path> , for example: cpackget add Vendor.PackName --pack-root ./MyLocal/Packs Note: As the various tools of the CMSIS-Toolbox all rely on the CMSIS-Pack root directory, it is recommended to use the CMSIS_PACK_ROOT environment variable. Initialize CMSIS-Pack root directory CMSIS-Packs are typically distributed via a public web service, that offers a Pack Index File of available software packs. To initialize the CMSIS-Pack root directory run the command: cpackget init https://www.keil.com/pack/index.pidx This command creates in the CMSIS-PACK root directory the following sub-directories. Sub-Directory Content .Web Pack Index File of a public web service and *.PDSC files. .Download Packs that are installed from a web service. Stores *.PDSC pack description file, *.pack content file, and related license information. .Local Index file local_repository.pidx that points to local installations for development of a software pack. Contains also the *.PDSC files from private software packs. The cpackget init command initializes the CMSIS-Pack root directory but does not download PDSC files. Combined with the option --all-pdsc-files it also downloads all PDSC files that are available in the public index. cpackget init https://www.keil.com/pack/indexpidx --all-pdsc-files Update Pack Index When new software packs are available in on a public web service, the local copy of the Pack Index File requires an update. To update the Pack Index File , run: cpackget update-index The option --sparse avoids the update of the PDSC files and improves therefore the speed. cpackget update-index --sparse To download all PDSC files that are available in the public index, use the option --all-pdsc-files . cpackget update-index --all-pdsc-files Add packs There are different ways to install software packs. Install public packs The commands below install software packs from a public web service. The available packs along with download URL and version information are listed in the Pack Index File . Check if a pack is installed. If not, install the latest version of a public software pack: cpackget add Vendor.PackName # or cpackget add Vendor::PackName Update an installed pack to the latest version of a public software pack: cpackget add Vendor.PackName@latest # or cpackget add Vendor::PackName@latest Install a specific version of a public software pack: cpackget add Vendor.PackName.x.y.z # or cpackget add Vendor::PackName@x.y.z cpackget add Vendor::PackName@>=x.y.z # check if there is any version greater or equal to x.y.z, install latest Install latest version of a public software pack with the same major version or same major/minor version. Within the rules of semantic versioning only compatible packs are used. cpackget add Vendor::PackName@^x.y.z # check if there is any version greater or equal to x.y.z, but with same major version x cpackget add Vendor::PackName@~x.y.z # check if there is any version greater or equal to x.y.z, but with same major/minor version x.y Install a list of software packs Frequently, a list of software packs should be installed that are used by a project. A text file can specify a list of packs, whereby each line specifies a single pack, optionally with version information as shown above: cpackget add -f list-of-packs.txt Content of list-of-packs.txt : ARM::CMSIS ARM::CMSIS-Driver ARM::CMSIS-FreeRTOS@10.4.6 ARM::mbedTLS@1.7.0 AWS::backoffAlgorithm@1.0.0-Beta : Accept End User License Agreement (EULA) from command line Some packs come with licenses. By default, cpackget will prompt the user acceptance of this license agreement. For automated installation of software packs, this user prompting can be suppressed with the command line flag --agree-embedded-license : cpackget add -f list-of-packs.txt --agree-embedded-license In some cases, the user might want to only extract the license agreement of the software pack. This is supported with the command line flag --extract-embedded-license : cpackget add --extract-embedded-license Vendor.PackName The extracted license file will be placed next to the pack. For example, if Vendor.PackName.x.y.z had a license file named LICENSE.txt , cpackget would extract it to .Download/Vendor.PackName.x.y.z.LICENSE.txt . Work behind a proxy Sometimes, cpackget seems to be unable to download software packs, for example when used behind a corporate firewall. Typically this is indicated by error messages such as: E: Get \"<url>/<pack-name>.pack\": dial tcp <ip-address>: connectex: No connection could be made because the target machine actively refused it. E: failed to download file In such cases, it might be required to access the Internet via a proxy. This can be done via environment variables that are used by cpackget : # Windows set HTTP_PROXY=http://my-proxy # proxy used for HTTP requests set HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests # Unix export HTTP_PROXY=http://my-proxy # proxy used for HTTP requests export HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests Then all HTTP/HTTPS requests will be going through the specified proxy. Install a private software pack A software pack can be distributed via different methods, for example via file exchange systems. Once the software pack is available on the local computer, it can be installed by referring to the *.pack file itself: cpackget add <path>/Vendor.PackName.x.y.z.pack A software pack that is available for download via a URL can be downloaded and installed with: cpackget add https://vendor.com/example/Vendor.PackName.x.y.z.pack Install a repository During the development of a software pack, it is possible to mark the content of a local directory (that typically reflects the repository of the software pack) as a software pack. In this case, the *.pdsc file is specified as shown below: cpackget add <local_path>/Vendor.PackName.pdsc Example: cpackget add /work/IoT_Socket/MDK-Packs.IoT_Socket.pdsc List all software packs List of all installed packs that are available in the CMSIS-Pack root directory. cpackget list This will include all packs that are installed via cpackget add command, regardless of the source of the software pack. There are also a couple of flags that allow listing extra information. List all cached packs, that are present in the .Download/ folder: cpackget list --cached List all packs present in the local copy of the Pack Index File ( index.pidx ): cpackget list --public Note: Update Pack Index File before using the list command to list all public software packs. Remove packs The commands below demonstrate how to remove packs. This is independent from how the software pack was added. Remove a software pack with a specific version: cpackget rm Vendor.PackName.x.y.z # or cpackget rm Vendor::PackName@x.y.z Remove all versions of a software pack: cpackget rm Vendor.PackName # or cpackget rm Vendor::PackName Same as above, but also remove the cached files that relate to this pack in the .Download/ directory. cpackget rm --purge Vendor.PackName` Remove a pack that was installed via a repository . cpackget rm Vendor.PackName.pdsc DevOps Usage The CMSIS-Toolbox supports Continuous Integration (CI) tests in DevOps systems. The ./out directory contains all build artifacts of an application for execution on physical hardware or simulation models. Arm Virtual Hardware - Fixed Virtual Platforms (AVH FVP) enable unit tests and integration tests with simulation models and various virtual interfaces. Using layers allows a Project Setup for Multiple Targets , for example to test on physical hardware or AVH-FVP simulation models. The following commands show typical usage of the CMSIS-Toolbox build system in CI environments. The commands below show typical builds in a CI system. Using --packs installs all public packs with implicit acceptance of licenses. This command builds all projects, target-types, and build-types. Using --context reduces the scope of the build. Using --frozen-packs uses exactly the packs that are specified in the file *.cbuild-pack.yml . cbuild Hello.csolution.yml --packs # install packs and build all cbuild Hello.csolution.yml --packs --context +AVH-SSE-300 # only build target +AVH-SSE-300 cbuild Hello.csolution.yml --packs --frozen-packs # use exact pack versions Packs are that not public are installed using cpackget . The following commands use the MDK-Middleware development repository to install a pre-release pack in a GitHub Actions CI workflow. - name: Checkout MDK-Middleware uses: actions/checkout@v4 with: repository: ARM-software/MDK-Middleware path: ./MDK-Middleware - name: Initialize CMSIS pack system and use MDK-Middleware pack from development repo run: | cpackget init https://www.keil.com/pack/index.pidx cpackget update-index cpackget add ./MDK-Middleware/Keil.MDK-Middleware.pdsc Examples There are several examples that show CI workflows using the CMSIS-Toolbox. Example Description csolution-examples Four different examples that execute CI tests with showing various concepts including matrix tests and AVH FVP simulation. AVH-Hello Build and execution test for \"Hello World\" example using a GitHub Action matrix to target all Cortex-M processors, Arm Compiler or GCC, and AVH simulation. AVH_CI_Template CI Template for unit test automation that uses GitHub Actions. CMSIS Version 6 Runs a CMSIS-Core validation test across the supported processors using multiple compilers. RTOS2 Validation Runs the CMSIS-RTOS2 validation across Keil RTX using source and library variants. STM32H743I-EVAL_BSP Build test of a Board Support Pack (BSP) with MDK-Middleware Reference Applications using Arm Compiler or GCC. The artifacts store the various example projects for testing on the hardware board. TFL Micro Speech This example project shows the Virtual Streaming Interface with Audio input and uses software layers for retargeting. IDE Usage An IDE may use the following cbuild setup command to setup the project outline view and get information about components and software layers. cbuild setup example.csolution.yml --context-set [--packs] [--update-rte] The command above is used when the IDE starts: The option --context-set uses one target-type and optionally multiple related projects that are selected by a user in the file *.cbuild-set.yml . If this file is missing, it is created with the first target-type and the first build-type that are defined in the *.csolution.yml file. The option --packs can be enabled to download missing software packs that are public. The option --update-rte is used when the IDE changes device: , board: or component: settings. The cbuild setup command creates build information files and generates the file compile_commands.json for IntelliSense in an VS Code IDE environment. Refer to cbuild setup command for more information. Project Outline View The project outline view in an IDE may utilize the project files as described below: The file *.csolution.yml contains the overall structure of projects, build-types , and target-types . The file *cbuild-set.yml specifies the selected contexts; if it does not exist, the IDE may select the first project, first build-type , and first target-type from the file *.csolution.yml . The files *.cproject.yml provides the source groups, source files and the list of components (but without source files). The files *.clayer.yml or *.cgen.yml contain software layers with additional source groups, source files, and components. The *.cbuild.<context>.yml files provide the exact location of these files, for example when variables are used. Using above information it is possible to create an outline view, but without the file list for components. For software layers, the content may required the *.cbuild.<context>.yml files that are generated with the cbuild setup command. The cbuild-idx.yml file provides the exact location of all *.cbuild.<context>.yml files that are used in this context-set. The *.cbuild.<context>.yml files contain for the components source files, configuration file information, API header files, user code templates, generator information, and links to documentation. The project outline view may provide access to this information. Build Process An IDE may use the following cbuild command to build the overall application. cbuild example.csolution.yml --context-set [--packs] [--quite] [--rebuild] The option --context-set selects the projects along with target-type and build-type for the application. The option --packs can be enabled to download missing software packs that are public. The option --quite suppresses details about the build process. The option --rebuild may be used to force a complete rebuild of the output files.","title":"Build Tools"},{"location":"build-tools/#build-tools","text":"This chapter describes the tools cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). It includes command line syntax details and examples.","title":"Build Tools"},{"location":"build-tools/#requirements","text":"Install the CMSIS-Toolbox as described in chapter Installation . The CMSIS-Pack repository must be present in the host development environment. There are several ways to configure the CMSIS-Pack repository: Use the cpackget Package Installer command init to initialize the CMSIS-Pack root directory , update the pack index file . Then add software packs . Share an existing CMSIS-Pack repository (i.e. from an IDE) via the environment variable CMSIS_PACK_ROOT .","title":"Requirements"},{"location":"build-tools/#cbuild-invocation","text":"Orchestrate the overall build steps utilizing the various tools of the CMSIS-Toolbox and a CMake-based compilation process. cbuild: Build Invocation 2.6.0 (C) 2024 Arm Ltd. and Contributors Usage: cbuild [command] <name>.csolution.yml [options] Commands: help Help about any command list List information about environment, toolchains, and contexts setup Generate project data for IDE environment Options: --cbuildgen Generate legacy *.cprj files and use cbuildgen backend -C, --clean Remove intermediate and output directories -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -S, --context-set Select the context names from cbuild-set.yml for generating the target application -d, --debug Enable debug messages --frozen-packs Pack list and versions from cbuild-pack.yml are fixed and raises errors if it changes -g, --generator arg Select build system generator (default \"Ninja\") -h, --help Print usage -j, --jobs int Number of job slots for parallel execution (default 8) -l, --load arg Set policy for packs loading [latest | all | required] (default \"required\") --log arg Save output messages in a log file -O, --output arg Add prefix to 'outdir' and 'tmpdir' -p, --packs Download missing software packs with cpackget -q, --quiet Suppress output messages except build invocations -r, --rebuild Remove intermediate and output directories and rebuild -s, --schema Validate project input file(s) against schema -t, --target arg Optional CMake target name --toolchain arg Input toolchain to be used --update-rte Update the RTE directory and files -v, --verbose Enable verbose messages from toolchain builds -V, --version Print version Use \"cbuild [command] --help\" for more information about a command. Note By default, the cbuild invocation does not update the RTE Directory . If required, use the option --update-rte .","title":"cbuild Invocation"},{"location":"build-tools/#csolution-invocation","text":"Create build information for embedded applications that consist of one or more related projects. csolution: Project Manager 2.6.0 (C) 2024 Arm Ltd. and Contributors Usage: csolution <command> [<name>.csolution.yml] [options] Commands: convert Convert user input *.yml files to *.cprj files list boards Print list of available board names list configs Print list of configuration files list contexts Print list of contexts in a <name>.csolution.yml list components Print list of available components list dependencies Print list of unresolved project dependencies list devices Print list of available device names list environment Print list of environment configurations list generators Print list of code generators of a given context list layers Print list of available, referenced and compatible layers list packs Print list of used packs from the pack repository list toolchains Print list of supported toolchains run Run code generator update-rte Create/update configuration files and validate solution Options: -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -d, --debug Enable debug messages -D, --dry-run Enable dry-run -e, --export arg Set suffix for exporting <context><suffix>.cprj retaining only specified versions -f, --filter arg Filter words -g, --generator arg Code generator identifier -l, --load arg Set policy for packs loading [latest | all | required] -L, --clayer-path arg Set search path for external clayers -m, --missing List only required packs that are missing in the pack repository -n, --no-check-schema Skip schema check -N, --no-update-rte Skip creation of RTE directory and files -o,-O --output arg Add prefix to 'outdir' and 'tmpdir' -q, --quiet Run silently, printing only error messages -R, --relative-paths Print paths relative to project or ${CMSIS_PACK_ROOT} -S, --context-set Select the context names from cbuild-set.yml for generating the target application -t, --toolchain arg Selection of the toolchain used in the project optionally with version -v, --verbose Enable verbose messages -V, --version Print version Use 'csolution <command> -h' for more information about a command.","title":"csolution Invocation"},{"location":"build-tools/#cpackget-invocation","text":"Manage the installation of software packs on the host computer. Usage: cpackget [command] [flags] Available Commands: add Add Open-CMSIS-Pack packages checksum-create Generates a .checksum file containing the digests of a pack checksum-verify Verifies the integrity of a pack using its .checksum file completion Generate the autocompletion script for the specified shell connection Check online connection to default or given URL help Help about any command init Initializes a pack root folder list List installed packs rm Remove Open-CMSIS-Pack packages signature-create Digitally signs a pack with a X.509 certificate or PGP key signature-verify Verifies a signed pack update Update Open-CMSIS-Pack packages to latest update-index Update the public index Flags: -C, --concurrent-downloads uint Number of concurrent batch downloads. Set to 0 to disable concurrency (default 20) -h, --help help for cpackget -R, --pack-root string Specifies pack root folder. Defaults to CMSIS_PACK_ROOT environment variable -q, --quiet Run cpackget silently, printing only error messages -T, --timeout uint Set maximum duration (in seconds) of a download. Disabled by default -v, --verbose Sets verboseness level: None (Errors + Info + Warnings), -v (all + Debugging). -V, --version Prints the version number of cpackget and exit Use \"cpackget [command] --help\" for more information about a command.","title":"cpackget Invocation"},{"location":"build-tools/#command-examples","text":"","title":"Command Examples"},{"location":"build-tools/#list-environment","text":"Print the settings of the host development environment to verify the correctness of the tool installation. cbuild list environment","title":"List Environment"},{"location":"build-tools/#list-available-toolchains","text":"Print the installed toolchains in the host development environment to identify the available compilers. The option --verbose provides additional path information. cbuild list toolchains -v","title":"List Available Toolchains"},{"location":"build-tools/#build-a-project","text":"This command builds a project that is defined in the file example.csolution.yml : cbuild example.csolution.yml Options allow to rebuild and download missing software packs or to select specific context settings: cbuild example.csolution.yml --rebuild --packs --context .Release For reproducible builds in CI environments, fixed software pack versions are provided by the file *.cbuild-pack.yml . An error is reported if the file *.cbuild-pack.yml does not exist or packs are added/removed. Refer to reproducible builds for more information. cbuild example.csolution.yml --frozen-packs --packs --rebuild It is also possible to overwrite the toolchain selection and use a different toolchain for translation: cbuild example.csolution.yml --toolchain GCC Note The --toolchain option is useful for: Testing a new compiler or a different compiler version on the overall project. For unit test applications to allow the usage of different compilers. In DevOps systems that run CI test with a matrix build, it is sometimes required to separate the output of various builds. The option --output adds a prefix to the output directory for outdir: , tmpdir: and build information files. The following commands build the project with the AC6 and GCC compiler and separate the directories for output and temporary files. cbuild example.csolution.yml --toolchain AC6 --output outAC6 cbuild example.csolution.yml --toolchain GCC --output outGCC Note The --output option is not recommended in an IDE environment as it changes the location of mandatory build information files that are used by the IDE .","title":"Build a Project"},{"location":"build-tools/#update-rte-configuration-files","text":"The Component Configuration\u200b is stored in the RTE directory . When files are missing or new software pack versions are installed, it might be required to update the RTE configuration files: csolution example.csolution.yml --update-rte","title":"Update RTE Configuration Files"},{"location":"build-tools/#add-software-packs","text":"To install software packs from a public web service, run: cpackget add Arm::CMSIS cpackget add Arm::CMSIS@5.9.0 # optional with version specification","title":"Add Software Packs"},{"location":"build-tools/#list-installed-packs","text":"Print a list of installed packs. The list can be filtered by words provided with the option --filter : csolution list packs [-f \"<filter words>\"] Print a list of packs that are required by the example.csolution.yml . csolution list packs example.csolution.yml","title":"List Installed Packs"},{"location":"build-tools/#install-missing-packs","text":"Print a list of missing packs required by the example.csolution.yml but not available in the pack repository to the file packs.txt . These missing packs can then be installed using the cpackget tool. csolution list packs example.csolution.yml -m >packs.txt cpackget update-index # optional to ensure that pack index is up-to-date cpackget add -f packs.txt","title":"Install Missing Packs"},{"location":"build-tools/#list-devices-or-boards","text":"Print a list of available device or board names. The list can be filtered by words provided with the option --filter : csolution list devices csolution list boards --filter NXP","title":"List Devices or Boards"},{"location":"build-tools/#list-unresolved-dependencies","text":"Device, board, and software components are specified as part of the *.csolution.yml and *.cproject.yml files. Print a list of unresolved project dependencies. The list may be filtered by words provided with the option --filter : csolution list dependencies mysolution.csolution.yml [-f \"<filter words>\"]","title":"List Unresolved Dependencies"},{"location":"build-tools/#create-build-information","text":"Convert example.csolution.yml into build information files. csolution convert example.csolution.yml Convert specific contexts of a *.csolution.yml file into build information files. csolution convert SimpleTZ.csolution.yml -c CM33_s.Debug -c CM33_ns.Release+AVH","title":"Create Build Information"},{"location":"build-tools/#list-compatible-layers","text":"List compatible layers for ./fxls8962_normal_spi.csolution.yml and the context *+frdmk22f_agmp03 . This contains also setup information. csolution list layers ./fxls8962_normal_spi.csolution.yml -c *+frdmk22f_agmp03 Refer to Software Layers for more information.","title":"List Compatible Layers"},{"location":"build-tools/#use-generators","text":"List external code generators that are used to create software components. It outputs the generator ID that is required for the run command. When using the option --verbose the generator out directory is listed. csolution list generators mysolution.csolution.yml -v Run a generator (in this case STM32CubeMX) for a specific project context. Note that the context can be omitted when the same generator output directory is used. csolution run -g CubeMX mysolution.csolution.yml -c Blinky.Debug+STM32L4","title":"Use Generators"},{"location":"build-tools/#use-context-set","text":"When working with multiple related projects , it might be necessary to combine different build types for debug and download in the target hardware. With the option --context-set the selected --context options can be saved and re-used. Write the selected --context options to the file SimpleTZ.cbuild-set.yml . Refer to file structure of *.cbuild-set.yml for details. cbuild SimpleTZ.csolution.yml -S -c CM33_s.Release -c CM33_ns.Debug Read the previously stored --context setup from the file SimpleTZ.cbuild-set.yml . cbuild SimpleTZ.csolution.yml -S","title":"Use context set"},{"location":"build-tools/#list-configuration-files","text":"List all configuration files that belong to software components and are stored in the RTE directory . When updating software packs , it shows also the update status of each file. csolution list configs SimpleTZ.csolution.yml -S","title":"List configuration files"},{"location":"build-tools/#setup-project-for-ide","text":"In an IDE environment, this command downloads missing packs, creates build information files , and generates the file compile_commands.json for IntelliSense. Refer to cbuild setup command for more information. cbuild setup example.csolution.yml --context-set --packs Note cbuild setup always enables the option --schema to validate the correct YML syntax in the csolution project files.","title":"Setup Project (for IDE)"},{"location":"build-tools/#specify-cmsis-pack-root-directory","text":"cpackget is compatible with other CMSIS-Pack management tools, such as the Pack Installer available in MDK or Eclipse variants. There are two ways to specify the CMSIS-PACK root directory: With the CMSIS_PACK_ROOT environment variable. Refer to Installation - Environment Variables . With the option --pack-root <path> , for example: cpackget add Vendor.PackName --pack-root ./MyLocal/Packs Note: As the various tools of the CMSIS-Toolbox all rely on the CMSIS-Pack root directory, it is recommended to use the CMSIS_PACK_ROOT environment variable.","title":"Specify CMSIS-Pack root directory"},{"location":"build-tools/#initialize-cmsis-pack-root-directory","text":"CMSIS-Packs are typically distributed via a public web service, that offers a Pack Index File of available software packs. To initialize the CMSIS-Pack root directory run the command: cpackget init https://www.keil.com/pack/index.pidx This command creates in the CMSIS-PACK root directory the following sub-directories. Sub-Directory Content .Web Pack Index File of a public web service and *.PDSC files. .Download Packs that are installed from a web service. Stores *.PDSC pack description file, *.pack content file, and related license information. .Local Index file local_repository.pidx that points to local installations for development of a software pack. Contains also the *.PDSC files from private software packs. The cpackget init command initializes the CMSIS-Pack root directory but does not download PDSC files. Combined with the option --all-pdsc-files it also downloads all PDSC files that are available in the public index. cpackget init https://www.keil.com/pack/indexpidx --all-pdsc-files","title":"Initialize CMSIS-Pack root directory"},{"location":"build-tools/#update-pack-index","text":"When new software packs are available in on a public web service, the local copy of the Pack Index File requires an update. To update the Pack Index File , run: cpackget update-index The option --sparse avoids the update of the PDSC files and improves therefore the speed. cpackget update-index --sparse To download all PDSC files that are available in the public index, use the option --all-pdsc-files . cpackget update-index --all-pdsc-files","title":"Update Pack Index"},{"location":"build-tools/#add-packs","text":"There are different ways to install software packs.","title":"Add packs"},{"location":"build-tools/#install-public-packs","text":"The commands below install software packs from a public web service. The available packs along with download URL and version information are listed in the Pack Index File . Check if a pack is installed. If not, install the latest version of a public software pack: cpackget add Vendor.PackName # or cpackget add Vendor::PackName Update an installed pack to the latest version of a public software pack: cpackget add Vendor.PackName@latest # or cpackget add Vendor::PackName@latest Install a specific version of a public software pack: cpackget add Vendor.PackName.x.y.z # or cpackget add Vendor::PackName@x.y.z cpackget add Vendor::PackName@>=x.y.z # check if there is any version greater or equal to x.y.z, install latest Install latest version of a public software pack with the same major version or same major/minor version. Within the rules of semantic versioning only compatible packs are used. cpackget add Vendor::PackName@^x.y.z # check if there is any version greater or equal to x.y.z, but with same major version x cpackget add Vendor::PackName@~x.y.z # check if there is any version greater or equal to x.y.z, but with same major/minor version x.y","title":"Install public packs"},{"location":"build-tools/#install-a-list-of-software-packs","text":"Frequently, a list of software packs should be installed that are used by a project. A text file can specify a list of packs, whereby each line specifies a single pack, optionally with version information as shown above: cpackget add -f list-of-packs.txt Content of list-of-packs.txt : ARM::CMSIS ARM::CMSIS-Driver ARM::CMSIS-FreeRTOS@10.4.6 ARM::mbedTLS@1.7.0 AWS::backoffAlgorithm@1.0.0-Beta :","title":"Install a list of software packs"},{"location":"build-tools/#accept-end-user-license-agreement-eula-from-command-line","text":"Some packs come with licenses. By default, cpackget will prompt the user acceptance of this license agreement. For automated installation of software packs, this user prompting can be suppressed with the command line flag --agree-embedded-license : cpackget add -f list-of-packs.txt --agree-embedded-license In some cases, the user might want to only extract the license agreement of the software pack. This is supported with the command line flag --extract-embedded-license : cpackget add --extract-embedded-license Vendor.PackName The extracted license file will be placed next to the pack. For example, if Vendor.PackName.x.y.z had a license file named LICENSE.txt , cpackget would extract it to .Download/Vendor.PackName.x.y.z.LICENSE.txt .","title":"Accept End User License Agreement (EULA) from command line"},{"location":"build-tools/#work-behind-a-proxy","text":"Sometimes, cpackget seems to be unable to download software packs, for example when used behind a corporate firewall. Typically this is indicated by error messages such as: E: Get \"<url>/<pack-name>.pack\": dial tcp <ip-address>: connectex: No connection could be made because the target machine actively refused it. E: failed to download file In such cases, it might be required to access the Internet via a proxy. This can be done via environment variables that are used by cpackget : # Windows set HTTP_PROXY=http://my-proxy # proxy used for HTTP requests set HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests # Unix export HTTP_PROXY=http://my-proxy # proxy used for HTTP requests export HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests Then all HTTP/HTTPS requests will be going through the specified proxy.","title":"Work behind a proxy"},{"location":"build-tools/#install-a-private-software-pack","text":"A software pack can be distributed via different methods, for example via file exchange systems. Once the software pack is available on the local computer, it can be installed by referring to the *.pack file itself: cpackget add <path>/Vendor.PackName.x.y.z.pack A software pack that is available for download via a URL can be downloaded and installed with: cpackget add https://vendor.com/example/Vendor.PackName.x.y.z.pack","title":"Install a private software pack"},{"location":"build-tools/#install-a-repository","text":"During the development of a software pack, it is possible to mark the content of a local directory (that typically reflects the repository of the software pack) as a software pack. In this case, the *.pdsc file is specified as shown below: cpackget add <local_path>/Vendor.PackName.pdsc Example: cpackget add /work/IoT_Socket/MDK-Packs.IoT_Socket.pdsc","title":"Install a repository"},{"location":"build-tools/#list-all-software-packs","text":"List of all installed packs that are available in the CMSIS-Pack root directory. cpackget list This will include all packs that are installed via cpackget add command, regardless of the source of the software pack. There are also a couple of flags that allow listing extra information. List all cached packs, that are present in the .Download/ folder: cpackget list --cached List all packs present in the local copy of the Pack Index File ( index.pidx ): cpackget list --public Note: Update Pack Index File before using the list command to list all public software packs.","title":"List all software packs"},{"location":"build-tools/#remove-packs","text":"The commands below demonstrate how to remove packs. This is independent from how the software pack was added. Remove a software pack with a specific version: cpackget rm Vendor.PackName.x.y.z # or cpackget rm Vendor::PackName@x.y.z Remove all versions of a software pack: cpackget rm Vendor.PackName # or cpackget rm Vendor::PackName Same as above, but also remove the cached files that relate to this pack in the .Download/ directory. cpackget rm --purge Vendor.PackName` Remove a pack that was installed via a repository . cpackget rm Vendor.PackName.pdsc","title":"Remove packs"},{"location":"build-tools/#devops-usage","text":"The CMSIS-Toolbox supports Continuous Integration (CI) tests in DevOps systems. The ./out directory contains all build artifacts of an application for execution on physical hardware or simulation models. Arm Virtual Hardware - Fixed Virtual Platforms (AVH FVP) enable unit tests and integration tests with simulation models and various virtual interfaces. Using layers allows a Project Setup for Multiple Targets , for example to test on physical hardware or AVH-FVP simulation models. The following commands show typical usage of the CMSIS-Toolbox build system in CI environments. The commands below show typical builds in a CI system. Using --packs installs all public packs with implicit acceptance of licenses. This command builds all projects, target-types, and build-types. Using --context reduces the scope of the build. Using --frozen-packs uses exactly the packs that are specified in the file *.cbuild-pack.yml . cbuild Hello.csolution.yml --packs # install packs and build all cbuild Hello.csolution.yml --packs --context +AVH-SSE-300 # only build target +AVH-SSE-300 cbuild Hello.csolution.yml --packs --frozen-packs # use exact pack versions Packs are that not public are installed using cpackget . The following commands use the MDK-Middleware development repository to install a pre-release pack in a GitHub Actions CI workflow. - name: Checkout MDK-Middleware uses: actions/checkout@v4 with: repository: ARM-software/MDK-Middleware path: ./MDK-Middleware - name: Initialize CMSIS pack system and use MDK-Middleware pack from development repo run: | cpackget init https://www.keil.com/pack/index.pidx cpackget update-index cpackget add ./MDK-Middleware/Keil.MDK-Middleware.pdsc","title":"DevOps Usage"},{"location":"build-tools/#examples","text":"There are several examples that show CI workflows using the CMSIS-Toolbox. Example Description csolution-examples Four different examples that execute CI tests with showing various concepts including matrix tests and AVH FVP simulation. AVH-Hello Build and execution test for \"Hello World\" example using a GitHub Action matrix to target all Cortex-M processors, Arm Compiler or GCC, and AVH simulation. AVH_CI_Template CI Template for unit test automation that uses GitHub Actions. CMSIS Version 6 Runs a CMSIS-Core validation test across the supported processors using multiple compilers. RTOS2 Validation Runs the CMSIS-RTOS2 validation across Keil RTX using source and library variants. STM32H743I-EVAL_BSP Build test of a Board Support Pack (BSP) with MDK-Middleware Reference Applications using Arm Compiler or GCC. The artifacts store the various example projects for testing on the hardware board. TFL Micro Speech This example project shows the Virtual Streaming Interface with Audio input and uses software layers for retargeting.","title":"Examples"},{"location":"build-tools/#ide-usage","text":"An IDE may use the following cbuild setup command to setup the project outline view and get information about components and software layers. cbuild setup example.csolution.yml --context-set [--packs] [--update-rte] The command above is used when the IDE starts: The option --context-set uses one target-type and optionally multiple related projects that are selected by a user in the file *.cbuild-set.yml . If this file is missing, it is created with the first target-type and the first build-type that are defined in the *.csolution.yml file. The option --packs can be enabled to download missing software packs that are public. The option --update-rte is used when the IDE changes device: , board: or component: settings. The cbuild setup command creates build information files and generates the file compile_commands.json for IntelliSense in an VS Code IDE environment. Refer to cbuild setup command for more information.","title":"IDE Usage"},{"location":"build-tools/#project-outline-view","text":"The project outline view in an IDE may utilize the project files as described below: The file *.csolution.yml contains the overall structure of projects, build-types , and target-types . The file *cbuild-set.yml specifies the selected contexts; if it does not exist, the IDE may select the first project, first build-type , and first target-type from the file *.csolution.yml . The files *.cproject.yml provides the source groups, source files and the list of components (but without source files). The files *.clayer.yml or *.cgen.yml contain software layers with additional source groups, source files, and components. The *.cbuild.<context>.yml files provide the exact location of these files, for example when variables are used. Using above information it is possible to create an outline view, but without the file list for components. For software layers, the content may required the *.cbuild.<context>.yml files that are generated with the cbuild setup command. The cbuild-idx.yml file provides the exact location of all *.cbuild.<context>.yml files that are used in this context-set. The *.cbuild.<context>.yml files contain for the components source files, configuration file information, API header files, user code templates, generator information, and links to documentation. The project outline view may provide access to this information.","title":"Project Outline View"},{"location":"build-tools/#build-process","text":"An IDE may use the following cbuild command to build the overall application. cbuild example.csolution.yml --context-set [--packs] [--quite] [--rebuild] The option --context-set selects the projects along with target-type and build-type for the application. The option --packs can be enabled to download missing software packs that are public. The option --quite suppresses details about the build process. The option --rebuild may be used to force a complete rebuild of the output files.","title":"Build Process"},{"location":"installation/","text":"Installation This chapter explains the setup of the CMSIS-Toolbox along with a build environment. There are three different ways to setup the CMSIS-Toolbox: Manual setup with operating system commands and environment variables. vcpkg - CLI using the vcpkg tool in command-line mode vcpkg - VS Code using the vcpkg tool with VS Code integration Manual Setup Download the CMSIS-Toolbox from the Arm tools artifactory . Signed binaries are provided for Windows (amd64), Linux (amd64, arm64), and MacOS/Darwin (amd64, arm64) in an archive file. To setup the CMSIS-Toolbox on a local computer, copy the content of the archive file to an <cmsis-toolbox-installation-dir> , for example to ~/cmsis-toolbox . Requirements The CMSIS-Toolbox uses the CMake build system with a Ninja generator. The installation of these tools is required. CMake version 3.25.2 or higher. Note For Win64, enable the install option Add CMake to the system PATH . Ninja version 1.10.2 or higher. Note Ninja may be copied to the <cmsis-toolbox-installation-dir>/bin directory. Compiler Toolchains The CMSIS-Toolbox works with the following compiler toolchains. Install one or more compilers depending on your requirements. GNU Arm Embedded Compiler version 10.3.1 or higher. Keil MDK version 5.36 or higher. Arm Compiler for Embedded version 6.18.0 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported IAR EW-Arm version 9.32.1 or higher. CLANG Embedded Compiler version 17.0.1 or higher. Environment Variables It maybe required to customize the installation for the actual setup of your development environment as described in the following. The various tools use the following environment variables. Environment Variable Description <name> _TOOLCHAIN_ <major> _ <minor> _ <patch> Required Path to the compiler binaries where <name> is one of AC6, GCC, IAR, CLANG. CMSIS_PACK_ROOT Optional Path to the CMSIS-Pack Root directory that stores software packs . CMSIS_COMPILER_ROOT Optional Path to the CMSIS-Toolbox etc directory (i.e. /c/cmsis-toolbox/etc ). Path Required Add to the system path the CMSIS-Toolbox bin directory (i.e. /c/cmsis-toolbox/bin ) as well as CMake and Ninja. Default Values The environment variable CMSIS_PACK_ROOT and CMSIS_COMPILER_ROOT are optional. If missing, default settings are used. CMSIS_PACK_ROOT default values: Platform Default path Linux ${HOME}/.cache/arm/packs Windows %LOCALAPPDATA%\\Arm\\Packs MacOS ${HOME}/.cache/arm/packs WSL_Windows ${LOCALAPPDATA}/Arm/Packs CMSIS_COMPILER_ROOT default is <toolbox>/bin/../etc , i.e., etc folder relative to the toolbox executables. It is used to locate: Toolchain cmake files <compiler-name>.<major>.<minor>.<patch>.cmake for the selected compiler . Default linker script files (to be preprocessed): <compiler-name>_linker_script.<ext>.src The cdefault.yml that is used when no other cdefault.yml file is found. Compiler Registration The compiler toolchain is registered with an environment variable that includes compiler name (AC6, GCC, IAR, LLVM) and version number (major, minor and patch). This information is used by the compiler: node or the --toolchain option to choose the compiler. Format: <name>_TOOLCHAIN_<major>_<minor>_<patch>=<path/to/toolchain/binaries> Example for Windows: set AC6_TOOLCHAIN_6_19_0=C:\\Keil_v5\\ARM\\ARMCLANG\\bin Example for Unix: export GCC_TOOLCHAIN_10_3_1=/opt/gcc-arm-none-eabi-10.3-2021.10/bin Setup Win64 For Windows, use the dialog System Properties - Advanced and add the Environment Variables listed above. Keil MDK version 5 When using Keil MDK version 5, the CMSIS-Toolbox is shipped as part of the installer. The tools are located in the directory .\\ARM\\cmsis-toolbox of the MDK installation. Adding the binary directory of the cmsis-toolbox directory to your PATH environment variable allows you to invoke the tools at the command line without the need to specify the full path (default: C:\\Keil_v5\\ARM\\cmsis-toolbox\\bin ) For sharing the pack directory between MDK and the CMSIS-Toolbox it is required that both CMSIS_PACK_ROOT environment variable and the RTEPATH setting in the MDK's TOOLS.INI (default: C:\\Keil_v5\\TOOLS.INI) point to the same directory. Note that in case the default location %LOCALAPPDATA%\\Arm\\Packs was selected during installation, the setting of CMSIS_PACK_ROOT environment variable is not required. The CMSIS_COMPILER_ROOT environment variable is not required if the compiler configuration files provided in cmsis-toolbox/etc are used. Notes: At the Windows command prompt, use set to list all environment variables. Keil \u00b5Vision may be used to: open projects in *.csolution.yml format (since v5.40). export project files in *.csolution.yml format. import project files in *.CPRJ format. Setup Linux or Bash In Linux, there are multiple ways to configure the Environment Variables . In a Bash environment, add the following content to the file .bashrc for example: Example: export CMSIS_PACK_ROOT=/home/ubuntu/packs export CMSIS_COMPILER_ROOT=/opt/cmsis-toolbox/etc export PATH=/opt/cmsis-toolbox/bin:$PATH Note: The command printenv should list these environment variables. Setup macOS Add execution permissions for all executables in ./bin chmod +x <cmsis-toolbox-installation-dir>/bin/cbridge chmod +x <cmsis-toolbox-installation-dir>/bin/cbuild ... Registering CMSIS_PACK_ROOT with cpackget Once you are done with setting up the environment variables, run the following on the command line: cpackget init https://www.keil.com/pack/index.pidx Note Arm is running a public indexing server at the URL provided. You can specify any indexing server URL if you do not wish to use this service. vcpkg - Setup using CLI The vcpkg is a management tool for packages and includes features to manage tool artifacts. Arm provides an artifactory system for tools. Refer to Arm Tools Available in vcpkg for more information. Note Microsoft changed the name of the shell version from vcpkg to vcpkg-shell . Depending on the version that you are using, you may need to call vcpkg-shell from the command line instead of vcpkg . The following describes how to setup the CMSIS-Toolbox with vcpkg in a command line (CLI) environment. In many examples there is already the file vcpkg-configuration.json which describes the tool environment required for the example. Refer to the last step to create an new vcpkg-configuration.json file. Install and enable vcpkg; the command depends on the shell. Windows Command Prompt (cmd) curl -LO https://aka.ms/vcpkg-init.cmd && .\\vcpkg-init.cmd %USERPROFILE%\\.vcpkg\\vcpkg-init.cmd Windows PowerShell iex (iwr -useb https://aka.ms/vcpkg-init.ps1) . ~/.vcpkg/vcpkg-init.ps1 Linux (x64)/macOS . <(curl https://aka.ms/vcpkg-init.sh -L) . ~/.vcpkg/vcpkg-init Note vcpkg is currently not working on - MSYS Bash (such as Git Bash) on Windows. - Linux (aarch64) Activate required tools using one of the following methods: Prerequisite: a vcpkg-configuration.json file is present in the current directory or any parent directory. vcpkg activate Note In case that activate fails, update registries to access latest versions of the tools artifacts: vcpkg x-update-registry --all Deactivate previous configuration vcpkg deactivate Create a new vcpkg-configuration.json file with these commands: vcpkg new --application vcpkg add artifact arm:cmsis-toolbox [--version major.minor.patch] vcpkg add artifact arm:cmake vcpkg add artifact arm:ninja vcpkg add artifact arm:arm-none-eabi-gcc vcpkg activate Alternatively, you may use an existing repository, for example github.com/Open-CMSIS-Pack/vscode-get-started with a vcpkg-configuration.json file. vcpkg - Setup in CI Using vcpkg in Continuous Integration (CI) environments is basically like using it in a CLI environment . The way how vcpkg artifacts updates the current shell environment needs to be taken into account when creating CI pipelines. The command vcpkg activate updates the current environment variables by extending PATH and adding additional variables required by installed artifacts. These modifications are only visible in the current running shell and spawned subprocesses. This enables also manual usage on a local prompt, given a typical user runs subsequent commands from the same parent shell process. In contrast, typical CI systems such as GitHub Actions or Jenkins spawn a new sub-shell for each step of a pipeline. Hence, modifications made to the environment in one sub-shell by running the vcpkg activate command are not persisted into the subsequent steps. Another aspect to consider is about handling the local vcpkg cache (e.g., ~/.vcpkg ). Common practice on CI systems is to recreate a clean environment for each run. Hence, vcpkg and all required artifacts are re-downloaded on every run. This may cause massive bandwidth requirements for downloading the same (huge) archives all the time. Instead, consider preserving the local vcpkg cache between runs. GitHub Actions GitHub Actions allow you to preserve environment settings via the files exposed in $GITHUB_PATH and $GITHUB_ENV . Refer to the custom action provided in github.com/ARM-software/cmsis-actions - Action: vcpkg for more information. Preserving the runners, between runs vcpkg cache is achieved with an actions/cache step preceding the first vcpkg activate command. The above custom action uses this actions/cache step. Other CI Systems In CI Systems without a vcpkg integration: Keep all tool installations depending on an activated environment within the same shell block, or Repeat activation for each new shell block before running any dependent command. . ~/.vcpkg/vcpkg-init vcpkg activate vcpkg - Setup in VS Code Download & Install Microsoft Visual Studio Code for your operating system. Launch Visual Studio Code. Using the menu View and open Extensions and install the Keil Studio Pack extensions. Use the menu View and open Source Control . Select 'Clone Repository' and enter as url https://github.com/Open-CMSIS-Pack/vscode-get-started . Specify the destination folder to clone to and select 'Open' when asked 'Would you like to open the cloned directory?' Use View menu 'Explorer' and select the file vcpkg-configuration.json . This file instructs Microsoft vcpkg to install the prerequisite artifacts required for building the solution and installs therefore: CMSIS-Toolbox 2.6.1 cmake 3.28.4 ninja 1.12.0 arm-none-eabi-gcc 13.3.1-mpacbti (GNU Arm Embedded Toolchain 13.3.1) Note In case vcpkg shows an error in the VSCode status bar, you can see further information in the vcpkg output. Once the tools are installed, you may use the CMSIS-Toolbox commands in a Terminal window of VS Code. If the terminal icon shows a yellow triangle with exclamation mark, you have to start a new terminal. This ensures that the environment settings updates triggered by the vcpkg activation are reflected in the terminal. Alternatively use View and open the CMSIS Extension. Then use the Build buttons to translate the project, flash your connected board and/or launch a debug connection. CMSIS_PACK_ROOT The environment variable CMSIS_PACK_ROOT defines location of the directory that stores the software packs. This directory has the following structure. Content of CMSIS_PACK_ROOT Description pack.idx Empty file that is touched (timestamp is updated) when packs are added or removed. /.Web Contains *.pdsc files available on public web pages. /.Web/index.pidx An index file that lists public available software packs. /.Download A local cache of packs that are downloaded. /.Local Stores the file local_repository.pidx that refers local *.pdsc files during pack development. Refer to install a repository for more information. /<vendor>/<name>/<version> Extracted software packs that are available for development using the CMSIS-Toolbox. Note For more details refer to the CMSIS_PACK_ROOT Directory Wiki page .","title":"Installation"},{"location":"installation/#installation","text":"This chapter explains the setup of the CMSIS-Toolbox along with a build environment. There are three different ways to setup the CMSIS-Toolbox: Manual setup with operating system commands and environment variables. vcpkg - CLI using the vcpkg tool in command-line mode vcpkg - VS Code using the vcpkg tool with VS Code integration","title":"Installation"},{"location":"installation/#manual-setup","text":"Download the CMSIS-Toolbox from the Arm tools artifactory . Signed binaries are provided for Windows (amd64), Linux (amd64, arm64), and MacOS/Darwin (amd64, arm64) in an archive file. To setup the CMSIS-Toolbox on a local computer, copy the content of the archive file to an <cmsis-toolbox-installation-dir> , for example to ~/cmsis-toolbox .","title":"Manual Setup"},{"location":"installation/#requirements","text":"The CMSIS-Toolbox uses the CMake build system with a Ninja generator. The installation of these tools is required. CMake version 3.25.2 or higher. Note For Win64, enable the install option Add CMake to the system PATH . Ninja version 1.10.2 or higher. Note Ninja may be copied to the <cmsis-toolbox-installation-dir>/bin directory.","title":"Requirements"},{"location":"installation/#compiler-toolchains","text":"The CMSIS-Toolbox works with the following compiler toolchains. Install one or more compilers depending on your requirements. GNU Arm Embedded Compiler version 10.3.1 or higher. Keil MDK version 5.36 or higher. Arm Compiler for Embedded version 6.18.0 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported IAR EW-Arm version 9.32.1 or higher. CLANG Embedded Compiler version 17.0.1 or higher.","title":"Compiler Toolchains"},{"location":"installation/#environment-variables","text":"It maybe required to customize the installation for the actual setup of your development environment as described in the following. The various tools use the following environment variables. Environment Variable Description <name> _TOOLCHAIN_ <major> _ <minor> _ <patch> Required Path to the compiler binaries where <name> is one of AC6, GCC, IAR, CLANG. CMSIS_PACK_ROOT Optional Path to the CMSIS-Pack Root directory that stores software packs . CMSIS_COMPILER_ROOT Optional Path to the CMSIS-Toolbox etc directory (i.e. /c/cmsis-toolbox/etc ). Path Required Add to the system path the CMSIS-Toolbox bin directory (i.e. /c/cmsis-toolbox/bin ) as well as CMake and Ninja.","title":"Environment Variables"},{"location":"installation/#default-values","text":"The environment variable CMSIS_PACK_ROOT and CMSIS_COMPILER_ROOT are optional. If missing, default settings are used. CMSIS_PACK_ROOT default values: Platform Default path Linux ${HOME}/.cache/arm/packs Windows %LOCALAPPDATA%\\Arm\\Packs MacOS ${HOME}/.cache/arm/packs WSL_Windows ${LOCALAPPDATA}/Arm/Packs CMSIS_COMPILER_ROOT default is <toolbox>/bin/../etc , i.e., etc folder relative to the toolbox executables. It is used to locate: Toolchain cmake files <compiler-name>.<major>.<minor>.<patch>.cmake for the selected compiler . Default linker script files (to be preprocessed): <compiler-name>_linker_script.<ext>.src The cdefault.yml that is used when no other cdefault.yml file is found.","title":"Default Values"},{"location":"installation/#compiler-registration","text":"The compiler toolchain is registered with an environment variable that includes compiler name (AC6, GCC, IAR, LLVM) and version number (major, minor and patch). This information is used by the compiler: node or the --toolchain option to choose the compiler. Format: <name>_TOOLCHAIN_<major>_<minor>_<patch>=<path/to/toolchain/binaries> Example for Windows: set AC6_TOOLCHAIN_6_19_0=C:\\Keil_v5\\ARM\\ARMCLANG\\bin Example for Unix: export GCC_TOOLCHAIN_10_3_1=/opt/gcc-arm-none-eabi-10.3-2021.10/bin","title":"Compiler Registration"},{"location":"installation/#setup-win64","text":"For Windows, use the dialog System Properties - Advanced and add the Environment Variables listed above. Keil MDK version 5 When using Keil MDK version 5, the CMSIS-Toolbox is shipped as part of the installer. The tools are located in the directory .\\ARM\\cmsis-toolbox of the MDK installation. Adding the binary directory of the cmsis-toolbox directory to your PATH environment variable allows you to invoke the tools at the command line without the need to specify the full path (default: C:\\Keil_v5\\ARM\\cmsis-toolbox\\bin ) For sharing the pack directory between MDK and the CMSIS-Toolbox it is required that both CMSIS_PACK_ROOT environment variable and the RTEPATH setting in the MDK's TOOLS.INI (default: C:\\Keil_v5\\TOOLS.INI) point to the same directory. Note that in case the default location %LOCALAPPDATA%\\Arm\\Packs was selected during installation, the setting of CMSIS_PACK_ROOT environment variable is not required. The CMSIS_COMPILER_ROOT environment variable is not required if the compiler configuration files provided in cmsis-toolbox/etc are used. Notes: At the Windows command prompt, use set to list all environment variables. Keil \u00b5Vision may be used to: open projects in *.csolution.yml format (since v5.40). export project files in *.csolution.yml format. import project files in *.CPRJ format.","title":"Setup Win64"},{"location":"installation/#setup-linux-or-bash","text":"In Linux, there are multiple ways to configure the Environment Variables . In a Bash environment, add the following content to the file .bashrc for example: Example: export CMSIS_PACK_ROOT=/home/ubuntu/packs export CMSIS_COMPILER_ROOT=/opt/cmsis-toolbox/etc export PATH=/opt/cmsis-toolbox/bin:$PATH Note: The command printenv should list these environment variables.","title":"Setup Linux or Bash"},{"location":"installation/#setup-macos","text":"Add execution permissions for all executables in ./bin chmod +x <cmsis-toolbox-installation-dir>/bin/cbridge chmod +x <cmsis-toolbox-installation-dir>/bin/cbuild ...","title":"Setup macOS"},{"location":"installation/#registering-cmsis_pack_root-with-cpackget","text":"Once you are done with setting up the environment variables, run the following on the command line: cpackget init https://www.keil.com/pack/index.pidx Note Arm is running a public indexing server at the URL provided. You can specify any indexing server URL if you do not wish to use this service.","title":"Registering CMSIS_PACK_ROOT with cpackget"},{"location":"installation/#vcpkg-setup-using-cli","text":"The vcpkg is a management tool for packages and includes features to manage tool artifacts. Arm provides an artifactory system for tools. Refer to Arm Tools Available in vcpkg for more information. Note Microsoft changed the name of the shell version from vcpkg to vcpkg-shell . Depending on the version that you are using, you may need to call vcpkg-shell from the command line instead of vcpkg . The following describes how to setup the CMSIS-Toolbox with vcpkg in a command line (CLI) environment. In many examples there is already the file vcpkg-configuration.json which describes the tool environment required for the example. Refer to the last step to create an new vcpkg-configuration.json file. Install and enable vcpkg; the command depends on the shell. Windows Command Prompt (cmd) curl -LO https://aka.ms/vcpkg-init.cmd && .\\vcpkg-init.cmd %USERPROFILE%\\.vcpkg\\vcpkg-init.cmd Windows PowerShell iex (iwr -useb https://aka.ms/vcpkg-init.ps1) . ~/.vcpkg/vcpkg-init.ps1 Linux (x64)/macOS . <(curl https://aka.ms/vcpkg-init.sh -L) . ~/.vcpkg/vcpkg-init Note vcpkg is currently not working on - MSYS Bash (such as Git Bash) on Windows. - Linux (aarch64) Activate required tools using one of the following methods: Prerequisite: a vcpkg-configuration.json file is present in the current directory or any parent directory. vcpkg activate Note In case that activate fails, update registries to access latest versions of the tools artifacts: vcpkg x-update-registry --all Deactivate previous configuration vcpkg deactivate Create a new vcpkg-configuration.json file with these commands: vcpkg new --application vcpkg add artifact arm:cmsis-toolbox [--version major.minor.patch] vcpkg add artifact arm:cmake vcpkg add artifact arm:ninja vcpkg add artifact arm:arm-none-eabi-gcc vcpkg activate Alternatively, you may use an existing repository, for example github.com/Open-CMSIS-Pack/vscode-get-started with a vcpkg-configuration.json file.","title":"vcpkg - Setup using CLI"},{"location":"installation/#vcpkg-setup-in-ci","text":"Using vcpkg in Continuous Integration (CI) environments is basically like using it in a CLI environment . The way how vcpkg artifacts updates the current shell environment needs to be taken into account when creating CI pipelines. The command vcpkg activate updates the current environment variables by extending PATH and adding additional variables required by installed artifacts. These modifications are only visible in the current running shell and spawned subprocesses. This enables also manual usage on a local prompt, given a typical user runs subsequent commands from the same parent shell process. In contrast, typical CI systems such as GitHub Actions or Jenkins spawn a new sub-shell for each step of a pipeline. Hence, modifications made to the environment in one sub-shell by running the vcpkg activate command are not persisted into the subsequent steps. Another aspect to consider is about handling the local vcpkg cache (e.g., ~/.vcpkg ). Common practice on CI systems is to recreate a clean environment for each run. Hence, vcpkg and all required artifacts are re-downloaded on every run. This may cause massive bandwidth requirements for downloading the same (huge) archives all the time. Instead, consider preserving the local vcpkg cache between runs.","title":"vcpkg - Setup in CI"},{"location":"installation/#github-actions","text":"GitHub Actions allow you to preserve environment settings via the files exposed in $GITHUB_PATH and $GITHUB_ENV . Refer to the custom action provided in github.com/ARM-software/cmsis-actions - Action: vcpkg for more information. Preserving the runners, between runs vcpkg cache is achieved with an actions/cache step preceding the first vcpkg activate command. The above custom action uses this actions/cache step.","title":"GitHub Actions"},{"location":"installation/#other-ci-systems","text":"In CI Systems without a vcpkg integration: Keep all tool installations depending on an activated environment within the same shell block, or Repeat activation for each new shell block before running any dependent command. . ~/.vcpkg/vcpkg-init vcpkg activate","title":"Other CI Systems"},{"location":"installation/#vcpkg-setup-in-vs-code","text":"Download & Install Microsoft Visual Studio Code for your operating system. Launch Visual Studio Code. Using the menu View and open Extensions and install the Keil Studio Pack extensions. Use the menu View and open Source Control . Select 'Clone Repository' and enter as url https://github.com/Open-CMSIS-Pack/vscode-get-started . Specify the destination folder to clone to and select 'Open' when asked 'Would you like to open the cloned directory?' Use View menu 'Explorer' and select the file vcpkg-configuration.json . This file instructs Microsoft vcpkg to install the prerequisite artifacts required for building the solution and installs therefore: CMSIS-Toolbox 2.6.1 cmake 3.28.4 ninja 1.12.0 arm-none-eabi-gcc 13.3.1-mpacbti (GNU Arm Embedded Toolchain 13.3.1) Note In case vcpkg shows an error in the VSCode status bar, you can see further information in the vcpkg output. Once the tools are installed, you may use the CMSIS-Toolbox commands in a Terminal window of VS Code. If the terminal icon shows a yellow triangle with exclamation mark, you have to start a new terminal. This ensures that the environment settings updates triggered by the vcpkg activation are reflected in the terminal. Alternatively use View and open the CMSIS Extension. Then use the Build buttons to translate the project, flash your connected board and/or launch a debug connection.","title":"vcpkg - Setup in VS Code"},{"location":"installation/#cmsis_pack_root","text":"The environment variable CMSIS_PACK_ROOT defines location of the directory that stores the software packs. This directory has the following structure. Content of CMSIS_PACK_ROOT Description pack.idx Empty file that is touched (timestamp is updated) when packs are added or removed. /.Web Contains *.pdsc files available on public web pages. /.Web/index.pidx An index file that lists public available software packs. /.Download A local cache of packs that are downloaded. /.Local Stores the file local_repository.pidx that refers local *.pdsc files during pack development. Refer to install a repository for more information. /<vendor>/<name>/<version> Extracted software packs that are available for development using the CMSIS-Toolbox. Note For more details refer to the CMSIS_PACK_ROOT Directory Wiki page .","title":"CMSIS_PACK_ROOT"},{"location":"migration/","text":"Migrating examples created for cmsis-toolbox 1.x.y to 2.0.0 This document clarifies breaking changes introduced in the CMSIS-Toolbox 2.0.0 and describes most common issues faced when migrating examples created for older versions. Please extend this document if you encounter further issues. For highlighting changes in yml nodes it's recommended to update the YAML Language Support extension settings to use the tagged schemas schemas/projmgr/2.0.0 . For example the following # yaml-language-server comment can be used: in *.csolution.yml: yml # yaml-language-server: $schema=https://github.com/Open-CMSIS-Pack/devtools/blob/schemas/projmgr/2.0.0/tools/projmgr/schemas/csolution.schema.json in *.cproject.yml: yml # yaml-language-server: $schema=https://github.com/Open-CMSIS-Pack/devtools/blob/schemas/projmgr/2.0.0/tools/projmgr/schemas/cproject.schema.json in *.clayer.yml: yml # yaml-language-server: $schema=https://github.com/Open-CMSIS-Pack/devtools/blob/schemas/projmgr/2.0.0/tools/projmgr/schemas/clayer.schema.json The following deprecated yml nodes and related handling were removed: all occurrences: add-paths (replaced by add-path ) del-paths (replaced by del-path ) defines (replaced by define ) undefines (replaced by undefine ) for-type (replaced by for-context ) not-for-type (replaced by not-for-context ) output-type (replaced by output node) in misc : compiler (replaced by [ for-compiler ) C* (replaced by C-CPP ) in output-dirs : gendir (replaced by generators node) rtedir (replaced by rte node in *.cproject.yml ) Note: RTE files belonging to components specified in *.clayer.yml files remain next to such *.clayer.yml. in processor : fpu and endian (but accepted with disabled schema check) in cdefault: : packs build-types output-dirs The cdefault enablement has changed: The cdefault: empty node must be added to *.csolution.yml to activate its use. Note: the file must be named cdefault.yml or cdefault.yaml without leading dot. The following Access Sequences were removed: $Source(context) (replaced by $ProjectDir(context)$ ) $Out(context) (replaced by $elf(context)$ , $bin(context)$ , $hex(context)$ , $lib(context)$ and $cmse-lib(context)$ ) The following environment variable must be unset or removed: CMSIS_BUILD_ROOT Note: This is needed because cbuild calls binaries pointed by CMSIS_BUILD_ROOT which are potentially outdated.","title":"Migrating examples created for cmsis-toolbox 1.x.y to 2.0.0"},{"location":"migration/#migrating-examples-created-for-cmsis-toolbox-1xy-to-200","text":"This document clarifies breaking changes introduced in the CMSIS-Toolbox 2.0.0 and describes most common issues faced when migrating examples created for older versions. Please extend this document if you encounter further issues. For highlighting changes in yml nodes it's recommended to update the YAML Language Support extension settings to use the tagged schemas schemas/projmgr/2.0.0 . For example the following # yaml-language-server comment can be used: in *.csolution.yml: yml # yaml-language-server: $schema=https://github.com/Open-CMSIS-Pack/devtools/blob/schemas/projmgr/2.0.0/tools/projmgr/schemas/csolution.schema.json in *.cproject.yml: yml # yaml-language-server: $schema=https://github.com/Open-CMSIS-Pack/devtools/blob/schemas/projmgr/2.0.0/tools/projmgr/schemas/cproject.schema.json in *.clayer.yml: yml # yaml-language-server: $schema=https://github.com/Open-CMSIS-Pack/devtools/blob/schemas/projmgr/2.0.0/tools/projmgr/schemas/clayer.schema.json The following deprecated yml nodes and related handling were removed: all occurrences: add-paths (replaced by add-path ) del-paths (replaced by del-path ) defines (replaced by define ) undefines (replaced by undefine ) for-type (replaced by for-context ) not-for-type (replaced by not-for-context ) output-type (replaced by output node) in misc : compiler (replaced by [ for-compiler ) C* (replaced by C-CPP ) in output-dirs : gendir (replaced by generators node) rtedir (replaced by rte node in *.cproject.yml ) Note: RTE files belonging to components specified in *.clayer.yml files remain next to such *.clayer.yml. in processor : fpu and endian (but accepted with disabled schema check) in cdefault: : packs build-types output-dirs The cdefault enablement has changed: The cdefault: empty node must be added to *.csolution.yml to activate its use. Note: the file must be named cdefault.yml or cdefault.yaml without leading dot. The following Access Sequences were removed: $Source(context) (replaced by $ProjectDir(context)$ ) $Out(context) (replaced by $elf(context)$ , $bin(context)$ , $hex(context)$ , $lib(context)$ and $cmse-lib(context)$ ) The following environment variable must be unset or removed: CMSIS_BUILD_ROOT Note: This is needed because cbuild calls binaries pointed by CMSIS_BUILD_ROOT which are potentially outdated.","title":"Migrating examples created for cmsis-toolbox 1.x.y to 2.0.0"},{"location":"overview/","text":"Overview Target Audience This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs. The CMSIS-Toolbox supports currently: Arm Compiler for Embedded version 6.18 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported Arm GNU Toolchain (GCC) version 10.3.1 or higher IAR Compiler version 9.32.1 or higher CLANG Compiler version 17.0.1 or higher based on LLVM technology Overall Workflow The CMSIS-Toolbox uses software packs for device/board support and access reusable software components. The operation is controlled via intuitive csolution project files in YAML format . The overall application is defined in the *.csolution.yml file and contains one or more projects that can utilize pre-configured software layers. The build engine CMake/Ninja calls the C/C++ compiler toolchain that generates the Build Output. The cbuild: Build Invocation command orchestrates the overall build steps. This command calls individual command line tools to generate the application as outlined in the following diagram. The build steps are: cpackget downloads Software Packs that are required for *.csolution.yml when using the option --pack . csolution processes the User Input and the Software Packs to generate the overall Build Information. Refer to Overview of Operation for details. cbuild2cmake converts this Build Information into CMake format. CMake/Ninja call the C/C++ compiler toolchain to translate the source files into the application image. Note The CMSIS-Toolbox build system does not use the CMake compiler and linker flags specified by environment variables CFLAGS, LDFLAGS . Refer to the chapter Build Operation for further details of the build process. Command Line and IDE Usage The CMSIS-Toolbox is a set of command line tools that are designed for stand-alone usage and integration into IDEs or DevOps systems for Continuous Integration (CI) workflows. The VS Code IDE integration available from Arm is a viewer to the csolution project files and provides graphical ways to modify the content. Refer to DevOps Usage for more information on integration into CI workflows. Benefits The overall benefits of the CMSIS-Toolbox are: Flexible command line tools that can be used stand-alone or integrated into VS Code or DevOps systems for Continuous Integration (CI) . Stand-alone tools are available for all host platforms (Windows, Mac, Linux) for flexible deployment. Software packs simplify tool setup with device: or board: selection and project creation with access to reusable software components. Organize solutions with projects that are independently managed simplifies a wide range of use cases including multi-processor applications or unit testing. Integrates with domain specific generators (i.e. CubeMX) that support configuration of devices/boards and complex software stacks such as motor control. Provisions for product lifecycle management (PLM) with versioned software packs that ease update and management for configuration files. Software layers enable code reuse across similar applications with a pre-configured set of source files and software components. Target types allow application deployment to different hardware (test board, production hardware, virtual simulation models, etc.). Build types support software testing and verification (debug build, test build, release build, ect.). Support for multiple toolchains, even within the same set of project files and command line options to select different toolchains during verification. Linker Script Management utilizes device and board information of software packs to define available memory and allows flexible control of linker operation. Uses a CMake backend for the build process that integrates with other tools such as VS Code intellisense. Provides a list of software licenses used by the various software packs and software components.","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#target-audience","text":"This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs. The CMSIS-Toolbox supports currently: Arm Compiler for Embedded version 6.18 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported Arm GNU Toolchain (GCC) version 10.3.1 or higher IAR Compiler version 9.32.1 or higher CLANG Compiler version 17.0.1 or higher based on LLVM technology","title":"Target Audience"},{"location":"overview/#overall-workflow","text":"The CMSIS-Toolbox uses software packs for device/board support and access reusable software components. The operation is controlled via intuitive csolution project files in YAML format . The overall application is defined in the *.csolution.yml file and contains one or more projects that can utilize pre-configured software layers. The build engine CMake/Ninja calls the C/C++ compiler toolchain that generates the Build Output. The cbuild: Build Invocation command orchestrates the overall build steps. This command calls individual command line tools to generate the application as outlined in the following diagram. The build steps are: cpackget downloads Software Packs that are required for *.csolution.yml when using the option --pack . csolution processes the User Input and the Software Packs to generate the overall Build Information. Refer to Overview of Operation for details. cbuild2cmake converts this Build Information into CMake format. CMake/Ninja call the C/C++ compiler toolchain to translate the source files into the application image. Note The CMSIS-Toolbox build system does not use the CMake compiler and linker flags specified by environment variables CFLAGS, LDFLAGS . Refer to the chapter Build Operation for further details of the build process.","title":"Overall Workflow"},{"location":"overview/#command-line-and-ide-usage","text":"The CMSIS-Toolbox is a set of command line tools that are designed for stand-alone usage and integration into IDEs or DevOps systems for Continuous Integration (CI) workflows. The VS Code IDE integration available from Arm is a viewer to the csolution project files and provides graphical ways to modify the content. Refer to DevOps Usage for more information on integration into CI workflows.","title":"Command Line and IDE Usage"},{"location":"overview/#benefits","text":"The overall benefits of the CMSIS-Toolbox are: Flexible command line tools that can be used stand-alone or integrated into VS Code or DevOps systems for Continuous Integration (CI) . Stand-alone tools are available for all host platforms (Windows, Mac, Linux) for flexible deployment. Software packs simplify tool setup with device: or board: selection and project creation with access to reusable software components. Organize solutions with projects that are independently managed simplifies a wide range of use cases including multi-processor applications or unit testing. Integrates with domain specific generators (i.e. CubeMX) that support configuration of devices/boards and complex software stacks such as motor control. Provisions for product lifecycle management (PLM) with versioned software packs that ease update and management for configuration files. Software layers enable code reuse across similar applications with a pre-configured set of source files and software components. Target types allow application deployment to different hardware (test board, production hardware, virtual simulation models, etc.). Build types support software testing and verification (debug build, test build, release build, ect.). Support for multiple toolchains, even within the same set of project files and command line options to select different toolchains during verification. Linker Script Management utilizes device and board information of software packs to define available memory and allows flexible control of linker operation. Uses a CMake backend for the build process that integrates with other tools such as VS Code intellisense. Provides a list of software licenses used by the various software packs and software components.","title":"Benefits"},{"location":"pack-tools/","text":"Pack Creation This chapter describes how to create software packs and explains the tools packchk (software pack verification) and svdconv (SVD file converter). Pack Creation Tools The following tools support the creation of Software Packs in CMSIS-Pack format : Tool Description packchk Pack Validation: installs and manages software packs in the local development environment. svdconv SVD Check / Convert: validate and/or convert System View Description (SVD) files. Scripts Several tools and scripts help to automate the pack creation. Hands-on Tutorials These scripts are in several hands-on tutorials. Hands-on Tutorial Description DFP-Pack-HandsOn Explains the structure and creation of a Device Family Pack (DFP). BSP-Pack-HandsOn Explains the structure and creation of a Board Support Pack (BSP). SW-Pack-HandsOn Explains the steps to create a simple software pack using the Open-CMSIS-Pack technology. Create-Scaleable-SW Explains how to structure complex middleware stacks. Hints for Pack Creation Use C startup files that allows to use a DFP with any toolchain. For elements use a brief description text with less than 128 characters to explain the purpose. When possible link to documentation with detailed information. Example: A component Device:HAL:ENET should not have description ENET HAL Driver , use Ethernet HAL driver instead. Consider adding project templates to help get started with more complex projects. This is useful when devices are are configured using generators or provide multiple linker scripts (i.e. RAM/ROM execution). To distribute toolchain agnostic examples as part of packs: Consider to use select-compiler to make projects toolchain independent. To avoid that examples need updates with every pack release, specify the minium pack version required . Use CI workflows to validate that projects compile correctly. Add an overview.md file that describes the overall usage of the software pack. These files are displayed on www.keil.arm.com/packs and index by Web search engines. Project Examples Project examples help to get started with new devices, boards, and middleware software components. The CMSIS-Pack format supports therefore different types of project examples: Template Projects are stub projects that help to get started. Some software packs may contain device specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications are hardware agnostic project examples that required layers to add the hardware abstraction of a target (typically a board). In addition packs may contain: Layers are pre-configured software components or source code that can be shared across multiple projects. Code Templates are stub source files for middleware components that can be incorporated into user code. The picture below shows the different packs that are used to publish project examples. These examples are available for software developers on web pages and can be directly accessed from IDEs that are for example enabled with the VS Code Arm CMSIS Solution extension. The following section explains how the different types of project examples are structured and registered within a CMSIS-Pack. Support Multiple Compilers To make project examples independent of a specific compiler toolchain, the *.csolution.yml file should include the select-compiler: node with a list of tested compilers. When a user or IDE starts such an example, the compiler: node that selects the compiler gets added. Example: solution: description: <brief description of the project example> created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG : Related Examples The *.csolution.yml file may contain several related projects that share the same target-types: and build-types: . Example: solution: : projects: - project: BSD_Server/BSD_Server.cproject.yml - project: FTP_Server/FTP_Server.cproject.yml - project: HTTP_Server/HTTP_Server.cproject.yml Template Projects A template project does not define a device: or board: in the *.csolution.yml file. When a IDE starts such an template the device: and/or board: information along with pack: information is added depending on user selection. The target-types: contains a Name that may be replaced by a descriptive target name. Note A template project should not specify the DFP or BSP with a pack: node as this gets added by the IDE during project start. Simple Template: A simple template only defines one target. solution: : target-types: - type: Name # board: # added during creation of solution # device: # added during creation of solution : Multi-Target Template: A multi-target template may contain different configurations for the same target, for example a configuration that executes from ROM and another that executes from RAM. The example below shows how this could be achieved using variables: . solution: : target-types: - type: Name-ROM # board: # added during creation of solution # device: # added during creation of solution variables: - regions_header: path/region_ROM.h - type: Name-RAM # board: # added during creation of solution # device: # added during creation of solution variables: - regions_header: path/region_RAM.h : In the example above, projects can use the linker: node in the *.cproject.yml file to reference the regions header file of the selected target. project: linker: - regions: $regions_header$ Note Templates should compile when the above information is added to the *.csolution.yml file. The exception is when templates require parts of the code provided by a generator. Register Template in PDSC File: Templates are published using the <csolution> element in the PDSC file. Device-specific Templates should be part of the DFP. Board-specific templates should be part of the BSP. <csolution> <template name=\"Simple Device project\" path=\"/device/Simple\" file=\"Simple.csolution.yml\" condition=\"Device_Spec\"> <description>Single-core project with empty main function configured for device</description> </template> <template name=\"Simple Board project\" path=\"/board/Simple\" file=\"Simple.csolution.yml\" condition=\"Board_Spec\"> <description>Single-core project with empty main function configured for board</description> </template> </csolution> Examples Examples are complete projects that typically run on a board. They should therefore specify a target-type with board: and list the packs: that are used, specifically the DFP and BSP. To minimize maintenance of Examples that are part of a pack, consider these rules: IMPORTANT: Store all files that are part of the ./RTE directory . These files store configuration and are important for PLM . Use select-compiler: when the Example works with several toolchains. Do not specify compiler: . Specify minimum pack version . Do not store *.cbuild-pack.yml . The tool selects first target-type and first build-type when cbuild-set.yml is missing. For simple projects do not store *.cbuild-set.yml . For simple projects, rely on the cdefault.yml file that is provided with CMSIS-Toolbox. Examples that work with several compiler toolchains should use select-compiler: and not define compiler: explicit. The compiler: node of the available toolchain is added when the Example is loaded into the IDE. When minimum pack versions are specified, the semantic versioning of packs should ensure that newer pack versions work also. As the *.cbuild-pack.yml file fixes pack versions, this file should be not stored in the pack. Examples may contain in the *.csolution.yml file multiple related projects that for example cover different aspects of a peripheral or middleware. For such Examples it is not required to store the *.cbuild-set.yml file as the tools select the first target-type and build-type of the *.csolution.yml file. Examples that do not require special compiler controls may rely on the cdefault.yml file that is provided with CMSIS-Toolbox as this file contains reasonable default settings. For more complex Examples , provide a local copy of the cdefault.yml file in the same directory as the *.csolution.yml file. Refer to Toolchain Agnostic Project for further information. csolution.yml file of an Example : solution: # Optional: Add a brief description line (recommendation less than 128 characters) description: Example that shows the usage of Fault component on an Cortex-M33 with TrustZone created-for: CMSIS-Toolbox@2.6.0 # minimum CMSIS-Toolbox version, newer versions will work also cdefault: select-compiler: - compiler: GCC # GCC is supported - compiler: AC6 # AC6 is supported - compiler: IAR # IAR is supported packs: - pack: Keil::STM32U5xx_DFP@^2.1.0 # minimum compatible pack version - pack: Keil::B-U585I-IOT02A_BSP@^1.0.0 target-types: - type: B-U585I-IOT02A board: STMicroelectronics::B-U585I-IOT02A device: STMicroelectronics::STM32U585AIIx build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Secure/Fault_S.cproject.yml - project: ./NonSecure/Fault_NS.cproject.yml Register Examples in PDSC File: Examples can be part of any pack and are published using the <examples> element in the PDSC file. Note that it is possible to register multiple project formats to support different tool environments. <examples> <example name=\"Fault example\" folder=\"Examples/Fault/B-U585I-IOT02A\" doc=\"README.md\"> <description>Example that shows the usage of Fault component on an Cortex-M33 with TrustZone</description> <board name=\"B-U585I-IOT02A\" vendor=\"STMicroelectronics\"/> <project> <environment name=\"csolution\" load=\"Fault.csolution.yml\"/> <environment name=\"uv\" load=\"Fault.uvmpw\"/> </project> </example> </examples> Reference Applications Reference applications can run on many different target hardware boards. Similar to template projects the device: and board: along with the required DFP and BSP pack: is not specified in the *.csolution.yml file. solution: description: IPv4/IPv6 Network examples created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG target-types: - type: Name # board: # added during creation of solution # variables: # - Board-Layer: <board_layer>.clayer.yml Note The MDK-Middleware contains several reference applications that exemplify the overall structure. Register Reference Applications in PDSC File: Reference Applications are typically part of a middleware software pack and publish using the <examples> element in the PDSC file. The difference to examples is that no <board> element is used as the reference application is hardware agnostic. <examples> </example> <example name=\"Network\" doc=\"README.md\" folder=\"Examples/Network\"> <description>MDK-Middleware: IPv4/IPv6 Client and Server applications via Ethernet</description> <project> <environment name=\"csolution\" load=\"Network.csolution.yml\"/> </project> </example> Layers Layers with connections are used to by Reference Applications to target hardware. These layers are added when a reference application is configured for a board: , typically in the IDE. Register Layers in PDSC File: Layers are part of a BSP and published using the <csolution> element in the PDSC file. <csolution> <clayer type=\"Board\" path=\"Layers/Default\" file=\"Board.clayer.yml\" copy-to=\"Board/MyBoard\" condition=\"Board-Spec\"/> </csolution> Note Several STM32 Board Support Packs (BSP) contain layers that are pre-configured for certain applications. For example, the layer in the ST_NUCLEO-F756ZG_BSP supports applications that require Ethernet, USB Device, UART, or I2C interfaces. Code Templates Code templates are part of the components files in the PDSC file and can be manually added by the user to a software project. Code templates show how a software component is used and the source code can be directly adapted to the requirements of the application program. Register Code Templates in PDSC File: Code Templates are part of a software component and published using the <components> element using attr=\"template\" in the PDSC file. <component Cgroup=\"Socket\" Csub=\"UDP\" condition=\"Network Interface\"> : <files> <file category=\"doc\" name=\"Documentation/html/Network/group__netUDP__Func.html\"/> <file category=\"header\" name=\"Components/Network/Config/Net_Config_UDP.h\" attr=\"config\" version=\"5.1.1\"/> <file category=\"source\" name=\"Components/Network/Template/UDP_Socket.c\" attr=\"template\" select=\"UDP Socket\"/> <!-- Library source files --> <file category=\"source\" name=\"Components/Network/Source/net_udp.c\"/> </files> Note The CMSIS-RTX and MDK-Middleware pack contains several code templates that exemplify the overall structure. Pack Examples Several pack examples available on github.com/Open-CMSIS-Pack exemplify how to create software packs. Other packs that are a good reference are the various Arm CMSIS packs or the MDK Middleware pack . The source of these packs is available on Github/Arm-software .","title":"Pack Creation"},{"location":"pack-tools/#pack-creation","text":"This chapter describes how to create software packs and explains the tools packchk (software pack verification) and svdconv (SVD file converter).","title":"Pack Creation"},{"location":"pack-tools/#pack-creation-tools","text":"The following tools support the creation of Software Packs in CMSIS-Pack format : Tool Description packchk Pack Validation: installs and manages software packs in the local development environment. svdconv SVD Check / Convert: validate and/or convert System View Description (SVD) files.","title":"Pack Creation Tools"},{"location":"pack-tools/#scripts","text":"Several tools and scripts help to automate the pack creation.","title":"Scripts"},{"location":"pack-tools/#hands-on-tutorials","text":"These scripts are in several hands-on tutorials. Hands-on Tutorial Description DFP-Pack-HandsOn Explains the structure and creation of a Device Family Pack (DFP). BSP-Pack-HandsOn Explains the structure and creation of a Board Support Pack (BSP). SW-Pack-HandsOn Explains the steps to create a simple software pack using the Open-CMSIS-Pack technology. Create-Scaleable-SW Explains how to structure complex middleware stacks.","title":"Hands-on Tutorials"},{"location":"pack-tools/#hints-for-pack-creation","text":"Use C startup files that allows to use a DFP with any toolchain. For elements use a brief description text with less than 128 characters to explain the purpose. When possible link to documentation with detailed information. Example: A component Device:HAL:ENET should not have description ENET HAL Driver , use Ethernet HAL driver instead. Consider adding project templates to help get started with more complex projects. This is useful when devices are are configured using generators or provide multiple linker scripts (i.e. RAM/ROM execution). To distribute toolchain agnostic examples as part of packs: Consider to use select-compiler to make projects toolchain independent. To avoid that examples need updates with every pack release, specify the minium pack version required . Use CI workflows to validate that projects compile correctly. Add an overview.md file that describes the overall usage of the software pack. These files are displayed on www.keil.arm.com/packs and index by Web search engines.","title":"Hints for Pack Creation"},{"location":"pack-tools/#project-examples","text":"Project examples help to get started with new devices, boards, and middleware software components. The CMSIS-Pack format supports therefore different types of project examples: Template Projects are stub projects that help to get started. Some software packs may contain device specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications are hardware agnostic project examples that required layers to add the hardware abstraction of a target (typically a board). In addition packs may contain: Layers are pre-configured software components or source code that can be shared across multiple projects. Code Templates are stub source files for middleware components that can be incorporated into user code. The picture below shows the different packs that are used to publish project examples. These examples are available for software developers on web pages and can be directly accessed from IDEs that are for example enabled with the VS Code Arm CMSIS Solution extension. The following section explains how the different types of project examples are structured and registered within a CMSIS-Pack.","title":"Project Examples"},{"location":"pack-tools/#support-multiple-compilers","text":"To make project examples independent of a specific compiler toolchain, the *.csolution.yml file should include the select-compiler: node with a list of tested compilers. When a user or IDE starts such an example, the compiler: node that selects the compiler gets added. Example: solution: description: <brief description of the project example> created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG :","title":"Support Multiple Compilers"},{"location":"pack-tools/#related-examples","text":"The *.csolution.yml file may contain several related projects that share the same target-types: and build-types: . Example: solution: : projects: - project: BSD_Server/BSD_Server.cproject.yml - project: FTP_Server/FTP_Server.cproject.yml - project: HTTP_Server/HTTP_Server.cproject.yml","title":"Related Examples"},{"location":"pack-tools/#template-projects","text":"A template project does not define a device: or board: in the *.csolution.yml file. When a IDE starts such an template the device: and/or board: information along with pack: information is added depending on user selection. The target-types: contains a Name that may be replaced by a descriptive target name. Note A template project should not specify the DFP or BSP with a pack: node as this gets added by the IDE during project start. Simple Template: A simple template only defines one target. solution: : target-types: - type: Name # board: # added during creation of solution # device: # added during creation of solution : Multi-Target Template: A multi-target template may contain different configurations for the same target, for example a configuration that executes from ROM and another that executes from RAM. The example below shows how this could be achieved using variables: . solution: : target-types: - type: Name-ROM # board: # added during creation of solution # device: # added during creation of solution variables: - regions_header: path/region_ROM.h - type: Name-RAM # board: # added during creation of solution # device: # added during creation of solution variables: - regions_header: path/region_RAM.h : In the example above, projects can use the linker: node in the *.cproject.yml file to reference the regions header file of the selected target. project: linker: - regions: $regions_header$ Note Templates should compile when the above information is added to the *.csolution.yml file. The exception is when templates require parts of the code provided by a generator. Register Template in PDSC File: Templates are published using the <csolution> element in the PDSC file. Device-specific Templates should be part of the DFP. Board-specific templates should be part of the BSP. <csolution> <template name=\"Simple Device project\" path=\"/device/Simple\" file=\"Simple.csolution.yml\" condition=\"Device_Spec\"> <description>Single-core project with empty main function configured for device</description> </template> <template name=\"Simple Board project\" path=\"/board/Simple\" file=\"Simple.csolution.yml\" condition=\"Board_Spec\"> <description>Single-core project with empty main function configured for board</description> </template> </csolution>","title":"Template Projects"},{"location":"pack-tools/#examples","text":"Examples are complete projects that typically run on a board. They should therefore specify a target-type with board: and list the packs: that are used, specifically the DFP and BSP. To minimize maintenance of Examples that are part of a pack, consider these rules: IMPORTANT: Store all files that are part of the ./RTE directory . These files store configuration and are important for PLM . Use select-compiler: when the Example works with several toolchains. Do not specify compiler: . Specify minimum pack version . Do not store *.cbuild-pack.yml . The tool selects first target-type and first build-type when cbuild-set.yml is missing. For simple projects do not store *.cbuild-set.yml . For simple projects, rely on the cdefault.yml file that is provided with CMSIS-Toolbox. Examples that work with several compiler toolchains should use select-compiler: and not define compiler: explicit. The compiler: node of the available toolchain is added when the Example is loaded into the IDE. When minimum pack versions are specified, the semantic versioning of packs should ensure that newer pack versions work also. As the *.cbuild-pack.yml file fixes pack versions, this file should be not stored in the pack. Examples may contain in the *.csolution.yml file multiple related projects that for example cover different aspects of a peripheral or middleware. For such Examples it is not required to store the *.cbuild-set.yml file as the tools select the first target-type and build-type of the *.csolution.yml file. Examples that do not require special compiler controls may rely on the cdefault.yml file that is provided with CMSIS-Toolbox as this file contains reasonable default settings. For more complex Examples , provide a local copy of the cdefault.yml file in the same directory as the *.csolution.yml file. Refer to Toolchain Agnostic Project for further information. csolution.yml file of an Example : solution: # Optional: Add a brief description line (recommendation less than 128 characters) description: Example that shows the usage of Fault component on an Cortex-M33 with TrustZone created-for: CMSIS-Toolbox@2.6.0 # minimum CMSIS-Toolbox version, newer versions will work also cdefault: select-compiler: - compiler: GCC # GCC is supported - compiler: AC6 # AC6 is supported - compiler: IAR # IAR is supported packs: - pack: Keil::STM32U5xx_DFP@^2.1.0 # minimum compatible pack version - pack: Keil::B-U585I-IOT02A_BSP@^1.0.0 target-types: - type: B-U585I-IOT02A board: STMicroelectronics::B-U585I-IOT02A device: STMicroelectronics::STM32U585AIIx build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Secure/Fault_S.cproject.yml - project: ./NonSecure/Fault_NS.cproject.yml Register Examples in PDSC File: Examples can be part of any pack and are published using the <examples> element in the PDSC file. Note that it is possible to register multiple project formats to support different tool environments. <examples> <example name=\"Fault example\" folder=\"Examples/Fault/B-U585I-IOT02A\" doc=\"README.md\"> <description>Example that shows the usage of Fault component on an Cortex-M33 with TrustZone</description> <board name=\"B-U585I-IOT02A\" vendor=\"STMicroelectronics\"/> <project> <environment name=\"csolution\" load=\"Fault.csolution.yml\"/> <environment name=\"uv\" load=\"Fault.uvmpw\"/> </project> </example> </examples>","title":"Examples"},{"location":"pack-tools/#reference-applications","text":"Reference applications can run on many different target hardware boards. Similar to template projects the device: and board: along with the required DFP and BSP pack: is not specified in the *.csolution.yml file. solution: description: IPv4/IPv6 Network examples created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG target-types: - type: Name # board: # added during creation of solution # variables: # - Board-Layer: <board_layer>.clayer.yml Note The MDK-Middleware contains several reference applications that exemplify the overall structure. Register Reference Applications in PDSC File: Reference Applications are typically part of a middleware software pack and publish using the <examples> element in the PDSC file. The difference to examples is that no <board> element is used as the reference application is hardware agnostic. <examples> </example> <example name=\"Network\" doc=\"README.md\" folder=\"Examples/Network\"> <description>MDK-Middleware: IPv4/IPv6 Client and Server applications via Ethernet</description> <project> <environment name=\"csolution\" load=\"Network.csolution.yml\"/> </project> </example>","title":"Reference Applications"},{"location":"pack-tools/#layers","text":"Layers with connections are used to by Reference Applications to target hardware. These layers are added when a reference application is configured for a board: , typically in the IDE. Register Layers in PDSC File: Layers are part of a BSP and published using the <csolution> element in the PDSC file. <csolution> <clayer type=\"Board\" path=\"Layers/Default\" file=\"Board.clayer.yml\" copy-to=\"Board/MyBoard\" condition=\"Board-Spec\"/> </csolution> Note Several STM32 Board Support Packs (BSP) contain layers that are pre-configured for certain applications. For example, the layer in the ST_NUCLEO-F756ZG_BSP supports applications that require Ethernet, USB Device, UART, or I2C interfaces.","title":"Layers"},{"location":"pack-tools/#code-templates","text":"Code templates are part of the components files in the PDSC file and can be manually added by the user to a software project. Code templates show how a software component is used and the source code can be directly adapted to the requirements of the application program. Register Code Templates in PDSC File: Code Templates are part of a software component and published using the <components> element using attr=\"template\" in the PDSC file. <component Cgroup=\"Socket\" Csub=\"UDP\" condition=\"Network Interface\"> : <files> <file category=\"doc\" name=\"Documentation/html/Network/group__netUDP__Func.html\"/> <file category=\"header\" name=\"Components/Network/Config/Net_Config_UDP.h\" attr=\"config\" version=\"5.1.1\"/> <file category=\"source\" name=\"Components/Network/Template/UDP_Socket.c\" attr=\"template\" select=\"UDP Socket\"/> <!-- Library source files --> <file category=\"source\" name=\"Components/Network/Source/net_udp.c\"/> </files> Note The CMSIS-RTX and MDK-Middleware pack contains several code templates that exemplify the overall structure.","title":"Code Templates"},{"location":"pack-tools/#pack-examples","text":"Several pack examples available on github.com/Open-CMSIS-Pack exemplify how to create software packs. Other packs that are a good reference are the various Arm CMSIS packs or the MDK Middleware pack . The source of these packs is available on Github/Arm-software .","title":"Pack Examples"},{"location":"progress/","text":"Implementation Progress Feature Status Version csolution.yml , cproject.yml and clayer.yml handling :heavy_check_mark: csolution 0.9.0 cdefault.yml handling :heavy_check_mark: csolution 0.9.3 build-types and target-types at csolution level :heavy_check_mark: csolution 0.9.0 for-type / not-for-type context handling :heavy_check_mark: csolution 0.9.0 list packs , devices , components , dependencies at cproject level :heavy_check_mark: csolution 0.9.0 defines / undefines / add-paths / del-paths at solution/project/target level :heavy_check_mark: csolution 0.9.0 defines / undefines / add-paths / del-paths at component/group/file level in csolution :heavy_check_mark: csolution 0.9.3 defines / undefines / includes / excludes at component/group/file level in cbuild :heavy_check_mark: cbuild 0.10.6 compiler misc options :heavy_check_mark: csolution 0.9.0 device discovering from board setting :heavy_check_mark: csolution 0.9.1 optimize , debug , warnings in csolution :heavy_check_mark: csolution 1.2.0 optimize , debug , warnings in cbuild :heavy_check_mark: cbuild 1.3.0 access sequences handling in csolution :heavy_check_mark: csolution 0.9.1 access sequences handling in cbuild :heavy_check_mark: cbuild 0.11.0 list commands at csolution and context level :heavy_check_mark: csolution 0.9.1 csolution context input parameter :heavy_check_mark: csolution 0.9.1 generator commands: list generators and run --generator <id> :heavy_check_mark: csolution 0.9.1 automatic schema checking :heavy_check_mark: csolution 0.9.1 config files PLM :heavy_check_mark: csolution 0.9.2 pack selection: pack keyword in csolution :heavy_check_mark: csolution 0.9.2 pack selection: context filtering :heavy_check_mark: csolution 0.9.3 pack selection: path keyword in csolution :heavy_check_mark: csolution 0.9.2 pack selection: path attribute in cbuild :heavy_check_mark: cbuild 0.10.6 device variant handling :heavy_check_mark: csolution 0.9.2 schema for flexible vendor specific additions :heavy_check_mark: csolution 0.9.2 user provided linker script selection :heavy_check_mark: csolution 0.9.2 support for IAR compiler :heavy_check_mark: cbuild 0.10.5 minimum/range component version handling :heavy_check_mark: csolution 1.1.0 replacement of cbuild bash scripts :heavy_check_mark: cbuild 0.11.0 multi-project solution handling in cbuild :heavy_check_mark: cbuild 1.5.0 layered solutions in-source conversion :heavy_check_mark: csolution 0.9.4 support for output directories customization at csolution level :heavy_check_mark: csolution 1.0.0 support for board attributes in conditions :heavy_check_mark: csolution 1.0.0 for-compiler and setup handling :heavy_check_mark: csolution 1.0.0 multiple contexts selection via wildcards :heavy_check_mark: csolution 1.0.0 layer interfaces definitions :heavy_check_mark: csolution 1.1.0 separation of config files belonging to layers :heavy_check_mark: csolution 1.2.0 generation of cbuild-idx.yml and cbuild.yml files :heavy_check_mark: csolution 1.2.0 support for linux-arm64 host platform :heavy_check_mark: csolution 1.3.0 support for win-arm64 and mac-arm64 host platforms :heavy_check_mark: csolution 1.7.0 disable update of RTE folder by default in cbuild :heavy_check_mark: cbuild 1.4.0 --update-rte flag to enable the update of RTE folder contents in cbuild :heavy_check_mark: cbuild 1.4.0 --no-update-rte flag to skip the update of RTE folder contents in csolution :heavy_check_mark: csolution 1.4.0 connections handling replacing interfaces :heavy_check_mark: csolution 1.4.0 variables handling for setting layer paths :heavy_check_mark: csolution 1.4.0 list layers command for finding layers with compatible connections :heavy_check_mark: csolution 1.4.0 list toolchains command for finding configured toolchains :heavy_check_mark: csolution 1.4.0 support csolution.yml and context as input data in cbuild :heavy_check_mark: cbuild 1.5.0 add output filenames customization handling in cbuild :heavy_check_mark: cbuild 1.5.0 add output filenames customization handling in csolution :heavy_check_mark: csolution 1.5.0 rework toolchains registration in cbuild :heavy_check_mark: cbuild 1.5.0 rework toolchains registration in csolution :heavy_check_mark: csolution 1.5.0 --toolchains command line option for selecting the compiler :heavy_check_mark: csolution 1.5.0 linker script file pre-processing in csolution :heavy_check_mark: csolution 1.7.0 linker script file pre-processing in cbuild :heavy_check_mark: cbuild 1.7.0 generate regions_*.h file from memory tags :heavy_check_mark: csolution 1.7.0 context-map handling :heavy_check_mark: csolution 2.0.0-dev0 reworked output nodes :heavy_check_mark: csolution 2.0.0-dev0 reworked output file types :heavy_check_mark: cbuild 2.0.0-dev0 updated access sequences :heavy_check_mark: csolution 2.0.0-dev0 removed deprecated nodes :heavy_check_mark: csolution 2.0.0-dev0 update-rte command for creating/updating and listing config files :heavy_check_mark: csolution 2.0.0-dev1 rte base-dir at cproject level for RTE folder customization :heavy_check_mark: csolution 2.0.0-dev1 reworked cdefault handling :heavy_check_mark: csolution 2.0.0-dev1 support multiple --context inputs :heavy_check_mark: csolution 2.0.0-dev2 support multiple setup for each context :heavy_check_mark: csolution 2.0.0-dev2 support for standard language options in cbuild :heavy_check_mark: cbuild 2.0.0-dev3 support for standard language options in csolution :heavy_check_mark: csolution 2.0.0-dev3 support for language and scope component file attributes in csolution :heavy_check_mark: csolution 2.0.0-dev3 alpha support for LLVM/Clang in cbuild :heavy_check_mark: cbuild 2.0.0 alpha support for LLVM/Clang in csolution :heavy_check_mark: csolution 2.0.0 add list configs command to list configuration files :heavy_check_mark: csolution 2.1.0 add license information to cbuild.yml :heavy_check_mark: csolution 2.1.0 support dry-running generators :heavy_check_mark: csolution 2.1.0 support for simplified global generators :heavy_check_mark: csolution 2.2.0 support for *.cbuild-pack.yml lock file mechanism :heavy_check_mark: csolution 2.2.0 support for branch protection (PACBTI) :heavy_check_mark: csolution 2.2.0 add option --context-set to handle selected contexts *.cbuild-set.yml :heavy_check_mark: csolution 2.2.0 add auto node for automatic linker script generation :heavy_check_mark: csolution 2.2.0 processor attributes trustzone , fpu , dsp , mve , endian and branch-protection :heavy_check_mark: csolution 2.2.0 alpha support for LLVM/Clang updated to 17.0.1 :heavy_check_mark: cbuild 2.2.0 add *.src file extension as linker script source for pre-processing :heavy_check_mark: cbuild 2.2.0 support multiple component instances :heavy_check_mark: csolution 2.3.0-dev0 add cbuild setup command :heavy_check_mark: cbuild 2.3.0-dev0 add alpha build manager backend :heavy_check_mark: cbuild2cmake 0.9.0-dev0 executes nodes in csolution :heavy_check_mark: csolution 2.4.0 executes nodes in cbuild2cmake :heavy_check_mark: cbuild2cmake 0.9.1 extended cbuild setup with layers discovery :heavy_check_mark: cbuild 2.4.0 set cbuild2cmake as default backend :heavy_check_mark: cbuild 2.5.0","title":"Implementation Progress"},{"location":"progress/#implementation-progress","text":"Feature Status Version csolution.yml , cproject.yml and clayer.yml handling :heavy_check_mark: csolution 0.9.0 cdefault.yml handling :heavy_check_mark: csolution 0.9.3 build-types and target-types at csolution level :heavy_check_mark: csolution 0.9.0 for-type / not-for-type context handling :heavy_check_mark: csolution 0.9.0 list packs , devices , components , dependencies at cproject level :heavy_check_mark: csolution 0.9.0 defines / undefines / add-paths / del-paths at solution/project/target level :heavy_check_mark: csolution 0.9.0 defines / undefines / add-paths / del-paths at component/group/file level in csolution :heavy_check_mark: csolution 0.9.3 defines / undefines / includes / excludes at component/group/file level in cbuild :heavy_check_mark: cbuild 0.10.6 compiler misc options :heavy_check_mark: csolution 0.9.0 device discovering from board setting :heavy_check_mark: csolution 0.9.1 optimize , debug , warnings in csolution :heavy_check_mark: csolution 1.2.0 optimize , debug , warnings in cbuild :heavy_check_mark: cbuild 1.3.0 access sequences handling in csolution :heavy_check_mark: csolution 0.9.1 access sequences handling in cbuild :heavy_check_mark: cbuild 0.11.0 list commands at csolution and context level :heavy_check_mark: csolution 0.9.1 csolution context input parameter :heavy_check_mark: csolution 0.9.1 generator commands: list generators and run --generator <id> :heavy_check_mark: csolution 0.9.1 automatic schema checking :heavy_check_mark: csolution 0.9.1 config files PLM :heavy_check_mark: csolution 0.9.2 pack selection: pack keyword in csolution :heavy_check_mark: csolution 0.9.2 pack selection: context filtering :heavy_check_mark: csolution 0.9.3 pack selection: path keyword in csolution :heavy_check_mark: csolution 0.9.2 pack selection: path attribute in cbuild :heavy_check_mark: cbuild 0.10.6 device variant handling :heavy_check_mark: csolution 0.9.2 schema for flexible vendor specific additions :heavy_check_mark: csolution 0.9.2 user provided linker script selection :heavy_check_mark: csolution 0.9.2 support for IAR compiler :heavy_check_mark: cbuild 0.10.5 minimum/range component version handling :heavy_check_mark: csolution 1.1.0 replacement of cbuild bash scripts :heavy_check_mark: cbuild 0.11.0 multi-project solution handling in cbuild :heavy_check_mark: cbuild 1.5.0 layered solutions in-source conversion :heavy_check_mark: csolution 0.9.4 support for output directories customization at csolution level :heavy_check_mark: csolution 1.0.0 support for board attributes in conditions :heavy_check_mark: csolution 1.0.0 for-compiler and setup handling :heavy_check_mark: csolution 1.0.0 multiple contexts selection via wildcards :heavy_check_mark: csolution 1.0.0 layer interfaces definitions :heavy_check_mark: csolution 1.1.0 separation of config files belonging to layers :heavy_check_mark: csolution 1.2.0 generation of cbuild-idx.yml and cbuild.yml files :heavy_check_mark: csolution 1.2.0 support for linux-arm64 host platform :heavy_check_mark: csolution 1.3.0 support for win-arm64 and mac-arm64 host platforms :heavy_check_mark: csolution 1.7.0 disable update of RTE folder by default in cbuild :heavy_check_mark: cbuild 1.4.0 --update-rte flag to enable the update of RTE folder contents in cbuild :heavy_check_mark: cbuild 1.4.0 --no-update-rte flag to skip the update of RTE folder contents in csolution :heavy_check_mark: csolution 1.4.0 connections handling replacing interfaces :heavy_check_mark: csolution 1.4.0 variables handling for setting layer paths :heavy_check_mark: csolution 1.4.0 list layers command for finding layers with compatible connections :heavy_check_mark: csolution 1.4.0 list toolchains command for finding configured toolchains :heavy_check_mark: csolution 1.4.0 support csolution.yml and context as input data in cbuild :heavy_check_mark: cbuild 1.5.0 add output filenames customization handling in cbuild :heavy_check_mark: cbuild 1.5.0 add output filenames customization handling in csolution :heavy_check_mark: csolution 1.5.0 rework toolchains registration in cbuild :heavy_check_mark: cbuild 1.5.0 rework toolchains registration in csolution :heavy_check_mark: csolution 1.5.0 --toolchains command line option for selecting the compiler :heavy_check_mark: csolution 1.5.0 linker script file pre-processing in csolution :heavy_check_mark: csolution 1.7.0 linker script file pre-processing in cbuild :heavy_check_mark: cbuild 1.7.0 generate regions_*.h file from memory tags :heavy_check_mark: csolution 1.7.0 context-map handling :heavy_check_mark: csolution 2.0.0-dev0 reworked output nodes :heavy_check_mark: csolution 2.0.0-dev0 reworked output file types :heavy_check_mark: cbuild 2.0.0-dev0 updated access sequences :heavy_check_mark: csolution 2.0.0-dev0 removed deprecated nodes :heavy_check_mark: csolution 2.0.0-dev0 update-rte command for creating/updating and listing config files :heavy_check_mark: csolution 2.0.0-dev1 rte base-dir at cproject level for RTE folder customization :heavy_check_mark: csolution 2.0.0-dev1 reworked cdefault handling :heavy_check_mark: csolution 2.0.0-dev1 support multiple --context inputs :heavy_check_mark: csolution 2.0.0-dev2 support multiple setup for each context :heavy_check_mark: csolution 2.0.0-dev2 support for standard language options in cbuild :heavy_check_mark: cbuild 2.0.0-dev3 support for standard language options in csolution :heavy_check_mark: csolution 2.0.0-dev3 support for language and scope component file attributes in csolution :heavy_check_mark: csolution 2.0.0-dev3 alpha support for LLVM/Clang in cbuild :heavy_check_mark: cbuild 2.0.0 alpha support for LLVM/Clang in csolution :heavy_check_mark: csolution 2.0.0 add list configs command to list configuration files :heavy_check_mark: csolution 2.1.0 add license information to cbuild.yml :heavy_check_mark: csolution 2.1.0 support dry-running generators :heavy_check_mark: csolution 2.1.0 support for simplified global generators :heavy_check_mark: csolution 2.2.0 support for *.cbuild-pack.yml lock file mechanism :heavy_check_mark: csolution 2.2.0 support for branch protection (PACBTI) :heavy_check_mark: csolution 2.2.0 add option --context-set to handle selected contexts *.cbuild-set.yml :heavy_check_mark: csolution 2.2.0 add auto node for automatic linker script generation :heavy_check_mark: csolution 2.2.0 processor attributes trustzone , fpu , dsp , mve , endian and branch-protection :heavy_check_mark: csolution 2.2.0 alpha support for LLVM/Clang updated to 17.0.1 :heavy_check_mark: cbuild 2.2.0 add *.src file extension as linker script source for pre-processing :heavy_check_mark: cbuild 2.2.0 support multiple component instances :heavy_check_mark: csolution 2.3.0-dev0 add cbuild setup command :heavy_check_mark: cbuild 2.3.0-dev0 add alpha build manager backend :heavy_check_mark: cbuild2cmake 0.9.0-dev0 executes nodes in csolution :heavy_check_mark: csolution 2.4.0 executes nodes in cbuild2cmake :heavy_check_mark: cbuild2cmake 0.9.1 extended cbuild setup with layers discovery :heavy_check_mark: cbuild 2.4.0 set cbuild2cmake as default backend :heavy_check_mark: cbuild 2.5.0","title":"Implementation Progress"}]}