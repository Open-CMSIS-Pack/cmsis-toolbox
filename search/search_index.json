{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CMSIS-Toolbox Thank you for using the CMSIS-Toolbox that provides command-line tools for: Project creation and build of embedded applications that utilize software packs . Various compilation tools are supported. Pack creation, maintenance, and distribution of software packs in Open-CMSIS-Pack format . Manual Chapters Overview of the CMSIS-Toolbox with tool workflow and benefits such as command-line and IDE usage. Installation explains the setup of the CMSIS-Toolbox along with a build environment for embedded applications that are based on Arm Cortex-M processors. Build Tools contains command line descriptions for cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). CSolution Project Structure describes the overall concept, outlines the csolution project files that describe the software application, and contains references to examples and project templates. CSolution Project Format is a detailed description of the csolution project files that define the software application in YAML format. Create Applications explains how to start projects using software packs. It also covers linker script creation, software pack structure, and project maintenance with pack upgrades. Reference Applications explains how to use and creates examples that show middleware usage on many different evaluation boards, including custom hardware. Build Information Files details the build information generated by the csolution tool. It includes license information for components and configuration for download and debug. Theory of Operation contains further details about the build process including CMake, West, generator (device configurators), and debugger integration for advanced users. Pack Creation describes how to create software packs that optionally include examples and explains the pack creation tools packchk (software pack verification) and svdconv (SVD file verification and header file generator). Troubleshooting lists known issues (such as missing file dependencies from assembler) with information on how to resolve it. Experimental Features for resource management of multi-project linker scripts, run and debug management. Debugger Support pyOCD Debugger explains the usage of the pyOCD Debugger in combination with the CMSIS-Toolbox configuration features. J-Link Debugger explains the usage of the J-Link GDB Server in combination with the CMSIS-Toolbox configuration features. Device Configuration Tools MCUXpresso for NXP Devices shows how to use MCUXpresso Config Tools to manage device and board configuration. STM32CubeMX for STM32 explains how to use STM32CubeMX to manage device and board configuration. Revision History Version Description 2.12.0 CMSIS-Toolbox 2.12.0 fixes several issues . The new West Build System Integration manages Zephyr applications in context with a csolution project. 2.11.0 CMSIS-Toolbox 2.11.0 . For a image: the device: node can be used to specify a processor pname . csolution adds commands that list debuggers, examples, and templates. The files cbuild.yml and cbuild-run.yml are now located in out directory. 2.10.0 CMSIS-Toolbox 2.10.0 . Extends load: to project-context: , adds a server mode and corrects several issues such as ST-Link debug adapter selection and CubeMX support. 2.9.0 CMSIS-Toolbox 2.9.0 . Added the input nodes link-time-optimize: and target-set: to configure application scope and debugger: . The images: node (previously load: ) adds ELF files generated with other systems. The Run and Debug Configuration using the cbuild-run.yml file is extended for multi-core systems and a range of supported Debug Adapters . See here for more details . 2.8.0 CMSIS-Toolbox 2.8.0 . New YML input nodes to add memory: , configure debugger: , and load: to add image files. The *.cbuild-run.yml file contains run and debug information for a target. See here for more details . 2.7.0 CMSIS-Toolbox 2.7.0 . Adds C++ language : c++23 , gnu++23 ; output linker MAP file control; MCUXpresso Config Tool ; experimental features for multi-project linker scripts, debug, and run. Fixed: components: now require Csub specifier; LLVM/Clang 19 compatibility; handling of group options . See here for more details . 2.6.0 CMSIS-Toolbox 2.6.0 ; extends pack: version specifier and C language support to C17 and C23. Improved is regions header file generation for linker scripts. It adds trustzone: secure-only for projects without secure entries, apis , messages , and PLM status for config files to cbuild.yml information, and fixes several minor issues. It is no longer possible to specify compiler in the cdefault.yml file. See here for more details . 2.5.0 CMSIS-Toolbox 2.5.0 ; direct CMake interface is now default, tmpdir: controls location of interim files, adds add-path-asm: , adds define-asm , adds regular expression search to for-context: / not-for-context , and contains several corrections. 2.4.0 CMSIS-Toolbox 2.4.0 ; adds CubeMX integration , pre/post-build steps , simplifies the generator integration , and contains several corrections. 2.3.0 CMSIS-Toolbox 2.3.0 adds in the csolution project files component instances and optimize: debug . Tools are extended with cbuild setup command , --frozen-pack option . Refer to release information for more details. 2.2.0 CMSIS-Toolbox 2.2.0 adds generator integration , extends translation controls , adds context set , adds pack locking , and improves linker script management . Refer to release information for more details. 2.0.0 Initial release for CMSIS-Toolbox 2.0.0","title":"Home"},{"location":"#cmsis-toolbox","text":"Thank you for using the CMSIS-Toolbox that provides command-line tools for: Project creation and build of embedded applications that utilize software packs . Various compilation tools are supported. Pack creation, maintenance, and distribution of software packs in Open-CMSIS-Pack format .","title":"CMSIS-Toolbox"},{"location":"#manual-chapters","text":"Overview of the CMSIS-Toolbox with tool workflow and benefits such as command-line and IDE usage. Installation explains the setup of the CMSIS-Toolbox along with a build environment for embedded applications that are based on Arm Cortex-M processors. Build Tools contains command line descriptions for cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). CSolution Project Structure describes the overall concept, outlines the csolution project files that describe the software application, and contains references to examples and project templates. CSolution Project Format is a detailed description of the csolution project files that define the software application in YAML format. Create Applications explains how to start projects using software packs. It also covers linker script creation, software pack structure, and project maintenance with pack upgrades. Reference Applications explains how to use and creates examples that show middleware usage on many different evaluation boards, including custom hardware. Build Information Files details the build information generated by the csolution tool. It includes license information for components and configuration for download and debug. Theory of Operation contains further details about the build process including CMake, West, generator (device configurators), and debugger integration for advanced users. Pack Creation describes how to create software packs that optionally include examples and explains the pack creation tools packchk (software pack verification) and svdconv (SVD file verification and header file generator). Troubleshooting lists known issues (such as missing file dependencies from assembler) with information on how to resolve it. Experimental Features for resource management of multi-project linker scripts, run and debug management. Debugger Support pyOCD Debugger explains the usage of the pyOCD Debugger in combination with the CMSIS-Toolbox configuration features. J-Link Debugger explains the usage of the J-Link GDB Server in combination with the CMSIS-Toolbox configuration features. Device Configuration Tools MCUXpresso for NXP Devices shows how to use MCUXpresso Config Tools to manage device and board configuration. STM32CubeMX for STM32 explains how to use STM32CubeMX to manage device and board configuration.","title":"Manual Chapters"},{"location":"#revision-history","text":"Version Description 2.12.0 CMSIS-Toolbox 2.12.0 fixes several issues . The new West Build System Integration manages Zephyr applications in context with a csolution project. 2.11.0 CMSIS-Toolbox 2.11.0 . For a image: the device: node can be used to specify a processor pname . csolution adds commands that list debuggers, examples, and templates. The files cbuild.yml and cbuild-run.yml are now located in out directory. 2.10.0 CMSIS-Toolbox 2.10.0 . Extends load: to project-context: , adds a server mode and corrects several issues such as ST-Link debug adapter selection and CubeMX support. 2.9.0 CMSIS-Toolbox 2.9.0 . Added the input nodes link-time-optimize: and target-set: to configure application scope and debugger: . The images: node (previously load: ) adds ELF files generated with other systems. The Run and Debug Configuration using the cbuild-run.yml file is extended for multi-core systems and a range of supported Debug Adapters . See here for more details . 2.8.0 CMSIS-Toolbox 2.8.0 . New YML input nodes to add memory: , configure debugger: , and load: to add image files. The *.cbuild-run.yml file contains run and debug information for a target. See here for more details . 2.7.0 CMSIS-Toolbox 2.7.0 . Adds C++ language : c++23 , gnu++23 ; output linker MAP file control; MCUXpresso Config Tool ; experimental features for multi-project linker scripts, debug, and run. Fixed: components: now require Csub specifier; LLVM/Clang 19 compatibility; handling of group options . See here for more details . 2.6.0 CMSIS-Toolbox 2.6.0 ; extends pack: version specifier and C language support to C17 and C23. Improved is regions header file generation for linker scripts. It adds trustzone: secure-only for projects without secure entries, apis , messages , and PLM status for config files to cbuild.yml information, and fixes several minor issues. It is no longer possible to specify compiler in the cdefault.yml file. See here for more details . 2.5.0 CMSIS-Toolbox 2.5.0 ; direct CMake interface is now default, tmpdir: controls location of interim files, adds add-path-asm: , adds define-asm , adds regular expression search to for-context: / not-for-context , and contains several corrections. 2.4.0 CMSIS-Toolbox 2.4.0 ; adds CubeMX integration , pre/post-build steps , simplifies the generator integration , and contains several corrections. 2.3.0 CMSIS-Toolbox 2.3.0 adds in the csolution project files component instances and optimize: debug . Tools are extended with cbuild setup command , --frozen-pack option . Refer to release information for more details. 2.2.0 CMSIS-Toolbox 2.2.0 adds generator integration , extends translation controls , adds context set , adds pack locking , and improves linker script management . Refer to release information for more details. 2.0.0 Initial release for CMSIS-Toolbox 2.0.0","title":"Revision History"},{"location":"CreateApplications/","text":"Create Applications The following chapter explains the structure of a software pack and how it can be used in an application. Start a Project An application is based on a device and/or board supported by a Device Family Pack (DFP) or Board Support Pack (BSP). The steps to start a project are: Step 1: Install the DFP and BSP Use Device search or Board search available on web portals to identify the software packs required for your target. Download the Device Family Pack (DFP) and optionally the Board Support Pack (BSP) with cpackget . Note that a BSP is only required if you want to work with a specific board. For custom hardware, typically the DFP is sufficient. Step 2: Use a Template Project and add DFP and BSP Select a suitable generic Template Project or refer to the DFP documentation as some devices have specific template projects. Copy the template project and open the *.csolution.yml file. Add under packs: the packs identified in step (1). You may omit the version number during initial project development. : compiler: AC6 # List the packs that define the device and/or board. packs: - pack: AnalogDevices::ADuCM320_DFP : Step 3: Use csolution list to identify the device or board Use csolution list devices <name>.csolution.yml or csolution list boards <name>.csolution.yml to get the device or board name. Enter the device or board name under target-types: . A device is typically used for custom hardware. : target-types: - type: ADuCM320-Board # choose a brief name for your target hardware # device: MyDeviceName # replace with your device or comment out to use a board board: Analog Devices::EVAL-ADuCM320EBZ # you may omit version information : Step 4: Add required software components Most projects at least require the CMSIS:CORE and Device:Startup (or a variant) software components to be present. Use csolution list components <name>.csolution.yml to identify the name of the startup component and add it to the file *.cproject.yml of your project. Use csolution list components <name>.csolution.yml to identify additional software components from the selected packs. Use the components: in the <name>.cproject.yml file to add new components and refer to related documentation for usage instructions. Note that you may omit vendor and version information for components as this is defined already by the packs that are selected. : components: # List components to use for your application - component: CMSIS:CORE # The CMSIS-Core component used in most projects - component: Device:Startup&Baremetal - component: Device:Peripheral Libraries:ADC : Refer to Using Components for more information. Now, the project should already compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Note that this step downloads missing packs and copies configuration files to the RTE directory . Step 5: Review and configure RTE files Review the configuration files in the RTE directory and refer to the documentation of the software components for instructions. Configure Linker Scripts below explains how to setup physical memory. For simple projects, the default settings should be sufficient. The build information file <name>.cbuild.Debug+<target-name>.yml lists configuration files of components and other useful information such as links to documentation of the component. Step 6: Add application functionality Implement the application code in C/C++ source files. Use the groups: section in <name>.cproject.yml to add new source files. : groups: - group: Source Files files: - file: main.c - file: MyFile1.c : Again, the project should compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Repeat step (4) when you add new components that require configuration. Note The Arm CMSIS Solution extension for VS Code guides you through these steps with the Create New Solution workflow . Configure Linker Scripts A linker script file defines the physical memory layout for a *.cproject.yml based. It may also allocate specific program sections (for example, DMA buffers or non-volatile variables) to special memory regions. While complex devices may use a bespoke linker script to manage multi-core and multi-master bus systems, many single-core devices can use the automatic linker script generation of the csolution Project Manager which uses a generic regions header file in combination with a toolchain-specific linker script template . The following section describes the usage of a linker script template and a regions header file which is combined by a C preprocessor into the final linker script file . It uses auto-generated files , but the methods also apply somewhat to bespoke linker scripts. The overall process to configure linker scripts for independent projects is: Step: Review and adjust the physical memory layout in the regions header file . Step: Optionally add specific program sections to the linker script template or change the default behaviour of that file. Regions Header File An initial regions header file is generated based on the memory information coming from the used software packs (DFP and BSP). This file has the name regions_<device_or_board>.h and is located in the directory ./RTE/Device/<device> . For memory with the default attribute set in DFP or BSP, the following region settings are generated: The region __ROM0 is the startup region and contains memory with the startup attribute set . The region __RAM0 contains uninitialized memory, STACK and HEAP. STACK default is 0x200. HEAP default is 0xC00 for devices with more than 6KB RAM (otherwise, HEAP is set to 0). Contiguous memory with the same access (rw, rwx, rx) is combined into one region. For memory with the default attribute no set in DFP or BSP, the memory is listed under resources that are not allocated to linker regions . The user may modify this generated regions header file : to adapt the physical memory layout of the project. to add not allocated memory resources to regions __ROM n and __RAM n . Example: regions_B-U585-IOT02A.h header file for a board #ifndef REGIONS_B_U585I_IOT02A_H #define REGIONS_B_U585I_IOT02A_H //-------- <<< Use Configuration Wizard in Context Menu >>> -------------------- //------ With VS Code: Open Preview for Configuration Wizard ------------------- // <n> Auto-generated using information from packs // <i> Device Family Pack (DFP): Keil::STM32U5xx_DFP@3.0.0-dev0 // <i> Board Support Pack (BSP): Keil::B-U585I-IOT02A_BSP@2.0.0-dev0 // <h> ROM Configuration // ======================= // <h> __ROM0 (is rx memory: Flash from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x08000000 // <i> Contains Startup and Vector Table #define __ROM0_BASE 0x08000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00200000 #define __ROM0_SIZE 0x00200000 // </h> // <h> __ROM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM1_SIZE 0 // </h> // <h> __ROM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM2_SIZE 0 // </h> // <h> __ROM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM3_SIZE 0 // </h> // </h> // <h> RAM Configuration // ======================= // <h> __RAM0 (is rwx memory: SRAM1_2 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20000000 // <i> Contains uninitialized RAM, Stack, and Heap #define __RAM0_BASE 0x20000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00040000 #define __RAM0_SIZE 0x00040000 // </h> // <h> __RAM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM1_SIZE 0 // </h> // <h> __RAM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM2_SIZE 0 // </h> // <h> __RAM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM3_SIZE 0 // </h> // </h> // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000C00 // </h> // <n> Resources that are not allocated to linker regions // <i> rwx RAM: SRAM3 from DFP: BASE: 0x20040000 SIZE: 0x00080000 // <i> rwx RAM: RAM-External from BSP: BASE: 0x90000000 SIZE: 0x00800000 // <i> rx ROM: Flash-External from BSP: BASE: 0x70000000 SIZE: 0x04000000 #endif /* REGIONS_B_U585I_IOT02A_H */ Linker Script Template A template linker script file is copied to the directory ./RTE/Device/<device> . The user may modify this file: to specify program sections that require dedicated physical memory regions. to change the allocation behaviour of the linker script. Example: DMA section allocation in ac6_linker_script.sct.src linker script template #if __RAM1_SIZE > 0 RW_RAM1 __RAM2_BASE __RAM2_SIZE { *(.RxDecripSection) // added DMA descriptors *(.TxDecripSection) *(.driver.eth_mac0_rx_buf) *(.driver.eth_mac0_tx_buf) .ANY (+RW +ZI) } #endif Note It is recommended to add a note to the regions header file about such user modifications as shown below: // <h> __RAM1 (is rwx memory: SRAM3 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20040000 // <i> Note: DMA descriptors and buffers are in this region Software Components A software component encapsulates a set of related functions. Offering API headers provides interfaces to other software components or to the user application. The software pack provides for a software component other optional items such as configuration files, documentation, user code templates that show the usage of the software component, and a debug view description (for CMSIS-View ). A software component typically interfaces to other software components or to device peripherals. In the CMSIS-Pack system software components: Are identified by the node components: using a component name . Use dependencies to describe required interfaces. List API header files for provided interfaces. For example, the lwIP network stack: requires a CMSIS-RTOS2 compliant kernel or a FreeRTOS kernel CMSIS drivers for the communication interface. List API header files for their interfaces. Required Interfaces There are two ways to describe required interfaces, as shown in the diagram below. Dependency reference to a component (a selection list is supported). Dependency reference to an API definition. Components that implement this API fulfil then the required interface. The API definition has the benefit that components which implement the interface can be added over time. The exact name of the component that requires an interface does not need to be known by the component. ToDo: A potential improvement is to use the command csolution list components to show available implementations for a required interface. Using Components The steps to create an application based on software components are: Step: Select software components Install the software pack that provides the required functionality (this could be based on pack datasheets) and identify the required software component(s). Add the pack and the component to your *.cproject.yml file. Run csolution *.csolution.yml list dependencies to identify other required software components. Run csolution list components --filter to identify packs that provide these software components. Repeat this step until all software components are part of your project. Step: Configure software components Run csolution *.csolution.yml update-rte to copy configuration files into the RTE directory . Set the parameters in the configuration files for your application. Step: Use software components in application program User code templates provide a starting point for your application. Copy these template files to your project directory and add them to your *.cproject.yml file. Adjust the code in the user template files as required. Example: Network Stack In this example, the application requires TCP Socket connectivity. The steps described under Using Components deliver this content for the *.cproject.yml file. packs: - pack: Keil::MDK-Middleware@7.16.0 - pack: ARM::CMSIS@5.9.0 - pack: ARM::CMSIS-Driver@2.7.2 - pack: Keil::LPC1700_DFP@2.7.1 components: - component: Network&MDK-Pro Net_v6:Socket:TCP - component: Network&MDK-Pro Net_v6:CORE&Release - component: Network&MDK-Pro Net_v6:Interface:ETH - component: CMSIS:CORE - component: CMSIS:RTOS2:Keil RTX5&Source - component: CMSIS Driver:Ethernet:KSZ8851SNL - component: CMSIS Driver:SPI:SPI - component: Device:PIN - component: Device:GPIO - component: Device:Startup The required interfaces are identified using csolution list dependencies : Adding more components, such as an IoT Client, would be the next step. Update Software Packs An update of a software pack can be performed with these steps: Download new software packs as needed using cpackget . Use the command csolution convert with the option --load latest to update the software packs. csolution convert Hello.csolution.yml --load latest List potentially outdated configuration files using the command csolution list configs . csolution list configs Hello.csolution.yml --context-set ../RTE/CMSIS/RTX_Config.c@5.1.1 (update@5.2.0) from ARM::CMSIS:RTOS2:Keil RTX5&Source@5.8.0 ../RTE/Device/SSE-300-MPS3/startup_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 ../RTE/Device/SSE-300-MPS3/system_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 Note The text update@version indicates that a new configuration file is available. Use a merge utility to identify and merge configuration settings from a previous version. Refer to PLM of configuration files for more information.","title":"Create Applications"},{"location":"CreateApplications/#create-applications","text":"The following chapter explains the structure of a software pack and how it can be used in an application.","title":"Create Applications"},{"location":"CreateApplications/#start-a-project","text":"An application is based on a device and/or board supported by a Device Family Pack (DFP) or Board Support Pack (BSP). The steps to start a project are:","title":"Start a Project"},{"location":"CreateApplications/#step-1-install-the-dfp-and-bsp","text":"Use Device search or Board search available on web portals to identify the software packs required for your target. Download the Device Family Pack (DFP) and optionally the Board Support Pack (BSP) with cpackget . Note that a BSP is only required if you want to work with a specific board. For custom hardware, typically the DFP is sufficient.","title":"Step 1: Install the DFP and BSP"},{"location":"CreateApplications/#step-2-use-a-template-project-and-add-dfp-and-bsp","text":"Select a suitable generic Template Project or refer to the DFP documentation as some devices have specific template projects. Copy the template project and open the *.csolution.yml file. Add under packs: the packs identified in step (1). You may omit the version number during initial project development. : compiler: AC6 # List the packs that define the device and/or board. packs: - pack: AnalogDevices::ADuCM320_DFP :","title":"Step 2: Use a Template Project and add DFP and BSP"},{"location":"CreateApplications/#step-3-use-csolution-list-to-identify-the-device-or-board","text":"Use csolution list devices <name>.csolution.yml or csolution list boards <name>.csolution.yml to get the device or board name. Enter the device or board name under target-types: . A device is typically used for custom hardware. : target-types: - type: ADuCM320-Board # choose a brief name for your target hardware # device: MyDeviceName # replace with your device or comment out to use a board board: Analog Devices::EVAL-ADuCM320EBZ # you may omit version information :","title":"Step 3: Use csolution list to identify the device or board"},{"location":"CreateApplications/#step-4-add-required-software-components","text":"Most projects at least require the CMSIS:CORE and Device:Startup (or a variant) software components to be present. Use csolution list components <name>.csolution.yml to identify the name of the startup component and add it to the file *.cproject.yml of your project. Use csolution list components <name>.csolution.yml to identify additional software components from the selected packs. Use the components: in the <name>.cproject.yml file to add new components and refer to related documentation for usage instructions. Note that you may omit vendor and version information for components as this is defined already by the packs that are selected. : components: # List components to use for your application - component: CMSIS:CORE # The CMSIS-Core component used in most projects - component: Device:Startup&Baremetal - component: Device:Peripheral Libraries:ADC : Refer to Using Components for more information. Now, the project should already compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Note that this step downloads missing packs and copies configuration files to the RTE directory .","title":"Step 4: Add required software components"},{"location":"CreateApplications/#step-5-review-and-configure-rte-files","text":"Review the configuration files in the RTE directory and refer to the documentation of the software components for instructions. Configure Linker Scripts below explains how to setup physical memory. For simple projects, the default settings should be sufficient. The build information file <name>.cbuild.Debug+<target-name>.yml lists configuration files of components and other useful information such as links to documentation of the component.","title":"Step 5: Review and configure RTE files"},{"location":"CreateApplications/#step-6-add-application-functionality","text":"Implement the application code in C/C++ source files. Use the groups: section in <name>.cproject.yml to add new source files. : groups: - group: Source Files files: - file: main.c - file: MyFile1.c : Again, the project should compile with the command cbuild <name>.csolution.yml --update-rte --packs --context .Debug . Repeat step (4) when you add new components that require configuration. Note The Arm CMSIS Solution extension for VS Code guides you through these steps with the Create New Solution workflow .","title":"Step 6: Add application functionality"},{"location":"CreateApplications/#configure-linker-scripts","text":"A linker script file defines the physical memory layout for a *.cproject.yml based. It may also allocate specific program sections (for example, DMA buffers or non-volatile variables) to special memory regions. While complex devices may use a bespoke linker script to manage multi-core and multi-master bus systems, many single-core devices can use the automatic linker script generation of the csolution Project Manager which uses a generic regions header file in combination with a toolchain-specific linker script template . The following section describes the usage of a linker script template and a regions header file which is combined by a C preprocessor into the final linker script file . It uses auto-generated files , but the methods also apply somewhat to bespoke linker scripts. The overall process to configure linker scripts for independent projects is: Step: Review and adjust the physical memory layout in the regions header file . Step: Optionally add specific program sections to the linker script template or change the default behaviour of that file.","title":"Configure Linker Scripts"},{"location":"CreateApplications/#regions-header-file","text":"An initial regions header file is generated based on the memory information coming from the used software packs (DFP and BSP). This file has the name regions_<device_or_board>.h and is located in the directory ./RTE/Device/<device> . For memory with the default attribute set in DFP or BSP, the following region settings are generated: The region __ROM0 is the startup region and contains memory with the startup attribute set . The region __RAM0 contains uninitialized memory, STACK and HEAP. STACK default is 0x200. HEAP default is 0xC00 for devices with more than 6KB RAM (otherwise, HEAP is set to 0). Contiguous memory with the same access (rw, rwx, rx) is combined into one region. For memory with the default attribute no set in DFP or BSP, the memory is listed under resources that are not allocated to linker regions . The user may modify this generated regions header file : to adapt the physical memory layout of the project. to add not allocated memory resources to regions __ROM n and __RAM n . Example: regions_B-U585-IOT02A.h header file for a board #ifndef REGIONS_B_U585I_IOT02A_H #define REGIONS_B_U585I_IOT02A_H //-------- <<< Use Configuration Wizard in Context Menu >>> -------------------- //------ With VS Code: Open Preview for Configuration Wizard ------------------- // <n> Auto-generated using information from packs // <i> Device Family Pack (DFP): Keil::STM32U5xx_DFP@3.0.0-dev0 // <i> Board Support Pack (BSP): Keil::B-U585I-IOT02A_BSP@2.0.0-dev0 // <h> ROM Configuration // ======================= // <h> __ROM0 (is rx memory: Flash from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x08000000 // <i> Contains Startup and Vector Table #define __ROM0_BASE 0x08000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00200000 #define __ROM0_SIZE 0x00200000 // </h> // <h> __ROM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM1_SIZE 0 // </h> // <h> __ROM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM2_SIZE 0 // </h> // <h> __ROM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __ROM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __ROM3_SIZE 0 // </h> // </h> // <h> RAM Configuration // ======================= // <h> __RAM0 (is rwx memory: SRAM1_2 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20000000 // <i> Contains uninitialized RAM, Stack, and Heap #define __RAM0_BASE 0x20000000 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. Default: 0x00040000 #define __RAM0_SIZE 0x00040000 // </h> // <h> __RAM1 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM1_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM1_SIZE 0 // </h> // <h> __RAM2 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM2_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM2_SIZE 0 // </h> // <h> __RAM3 (unused) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. #define __RAM3_BASE 0 // <o> Region size [bytes] <0x0-0xFFFFFFFF:8> // <i> Defines size of memory region. #define __RAM3_SIZE 0 // </h> // </h> // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000C00 // </h> // <n> Resources that are not allocated to linker regions // <i> rwx RAM: SRAM3 from DFP: BASE: 0x20040000 SIZE: 0x00080000 // <i> rwx RAM: RAM-External from BSP: BASE: 0x90000000 SIZE: 0x00800000 // <i> rx ROM: Flash-External from BSP: BASE: 0x70000000 SIZE: 0x04000000 #endif /* REGIONS_B_U585I_IOT02A_H */","title":"Regions Header File"},{"location":"CreateApplications/#linker-script-template","text":"A template linker script file is copied to the directory ./RTE/Device/<device> . The user may modify this file: to specify program sections that require dedicated physical memory regions. to change the allocation behaviour of the linker script. Example: DMA section allocation in ac6_linker_script.sct.src linker script template #if __RAM1_SIZE > 0 RW_RAM1 __RAM2_BASE __RAM2_SIZE { *(.RxDecripSection) // added DMA descriptors *(.TxDecripSection) *(.driver.eth_mac0_rx_buf) *(.driver.eth_mac0_tx_buf) .ANY (+RW +ZI) } #endif Note It is recommended to add a note to the regions header file about such user modifications as shown below: // <h> __RAM1 (is rwx memory: SRAM3 from DFP) // <o> Base address <0x0-0xFFFFFFFF:8> // <i> Defines base address of memory region. Default: 0x20040000 // <i> Note: DMA descriptors and buffers are in this region","title":"Linker Script Template"},{"location":"CreateApplications/#software-components","text":"A software component encapsulates a set of related functions. Offering API headers provides interfaces to other software components or to the user application. The software pack provides for a software component other optional items such as configuration files, documentation, user code templates that show the usage of the software component, and a debug view description (for CMSIS-View ). A software component typically interfaces to other software components or to device peripherals. In the CMSIS-Pack system software components: Are identified by the node components: using a component name . Use dependencies to describe required interfaces. List API header files for provided interfaces. For example, the lwIP network stack: requires a CMSIS-RTOS2 compliant kernel or a FreeRTOS kernel CMSIS drivers for the communication interface. List API header files for their interfaces.","title":"Software Components"},{"location":"CreateApplications/#required-interfaces","text":"There are two ways to describe required interfaces, as shown in the diagram below. Dependency reference to a component (a selection list is supported). Dependency reference to an API definition. Components that implement this API fulfil then the required interface. The API definition has the benefit that components which implement the interface can be added over time. The exact name of the component that requires an interface does not need to be known by the component. ToDo: A potential improvement is to use the command csolution list components to show available implementations for a required interface.","title":"Required Interfaces"},{"location":"CreateApplications/#using-components","text":"The steps to create an application based on software components are: Step: Select software components Install the software pack that provides the required functionality (this could be based on pack datasheets) and identify the required software component(s). Add the pack and the component to your *.cproject.yml file. Run csolution *.csolution.yml list dependencies to identify other required software components. Run csolution list components --filter to identify packs that provide these software components. Repeat this step until all software components are part of your project. Step: Configure software components Run csolution *.csolution.yml update-rte to copy configuration files into the RTE directory . Set the parameters in the configuration files for your application. Step: Use software components in application program User code templates provide a starting point for your application. Copy these template files to your project directory and add them to your *.cproject.yml file. Adjust the code in the user template files as required.","title":"Using Components"},{"location":"CreateApplications/#example-network-stack","text":"In this example, the application requires TCP Socket connectivity. The steps described under Using Components deliver this content for the *.cproject.yml file. packs: - pack: Keil::MDK-Middleware@7.16.0 - pack: ARM::CMSIS@5.9.0 - pack: ARM::CMSIS-Driver@2.7.2 - pack: Keil::LPC1700_DFP@2.7.1 components: - component: Network&MDK-Pro Net_v6:Socket:TCP - component: Network&MDK-Pro Net_v6:CORE&Release - component: Network&MDK-Pro Net_v6:Interface:ETH - component: CMSIS:CORE - component: CMSIS:RTOS2:Keil RTX5&Source - component: CMSIS Driver:Ethernet:KSZ8851SNL - component: CMSIS Driver:SPI:SPI - component: Device:PIN - component: Device:GPIO - component: Device:Startup The required interfaces are identified using csolution list dependencies : Adding more components, such as an IoT Client, would be the next step.","title":"Example: Network Stack"},{"location":"CreateApplications/#update-software-packs","text":"An update of a software pack can be performed with these steps: Download new software packs as needed using cpackget . Use the command csolution convert with the option --load latest to update the software packs. csolution convert Hello.csolution.yml --load latest List potentially outdated configuration files using the command csolution list configs . csolution list configs Hello.csolution.yml --context-set ../RTE/CMSIS/RTX_Config.c@5.1.1 (update@5.2.0) from ARM::CMSIS:RTOS2:Keil RTX5&Source@5.8.0 ../RTE/Device/SSE-300-MPS3/startup_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 ../RTE/Device/SSE-300-MPS3/system_SSE300MPS3.c@1.1.1 (up to date) from ARM::Device:Startup&C Startup@2.0.0 Note The text update@version indicates that a new configuration file is available. Use a merge utility to identify and merge configuration settings from a previous version. Refer to PLM of configuration files for more information.","title":"Update Software Packs"},{"location":"CubeMX/","text":"Configure STM32 Devices with CubeMX This chapter explains how to use STM32CubeMX with the CMSIS-Toolbox to manage device and board configuration. Note For the CMSIS-Toolbox CubeMX integration, STM32 packs with generator support are required. These software packs contain in the release information: Updated for new CMSIS-Toolbox CubeMX integration . Introduction STM32CubeMX (CubeMX) is a graphical tool for configuration of an STM32 device or board. CubeMX generates C code for project and peripheral initialization, based on user settings. Depending on the device configuration, related drivers are added to the user application. The CMSIS-Toolbox interacts with CubeMX using the generic interface for generators . The component: Device:CubeMX connects a csolution project to CubeMX. This component imports the CubeMX generated files for a selected device: or board: using the generator import file *.cgen.yml . This file is similar to a software layer but managed by CubeMX and should be not modified directly. An example project created with CubeMX can be found in csolution-examples/CubeMX . Note If a board is specified in the csolution project , CubeMX pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the CubeMX dialogues. If a device is specified, the user needs to configure the peripherals manually using CubeMX dialogues. Simple Project Below is a simple project that just adds the CubeMX-generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: CubeMX.csolution.yml solution: created-for: CMSIS-Toolbox@2.3.0 description: Simple CubeMX example cdefault: # use toolchain default settings compiler: AC6 # select toolchain # it is recommended to list the pack or packs that define the device or board used in the csolution.yml file packs: - pack: ARM::CMSIS # CMSIS pack is required for most projects - pack: Keil::B-U585I-IOT02A_BSP - pack: Keil::STM32U5xx_DFP@>=3.0.0-0 target-types: - type: MyBoard # My evaluation kit board: B-U585I-IOT02A # Board name as defined by the pack build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced projects: # list related projects - project: ./CubeMX.cproject.yml File: CubeMX.cproject.yml project: components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX Such a project cannot be directly built, as initially, the *.cgen.yml file is missing. It requires to run the CubeMX generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # generator name base-dir: STM32CubeMX/MyBoard # directory for generated files context: CubeMX.Debug+MyBoard # list of context that uses this directory context: CubeMX.Release+MyBoard Use the information above to run the generator: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard This starts CubeMX and passes the information about the selected board, device, and select toolchain. For a project that selects a board, CubeMX imports the default configuration for it. In CubeMX, review and adjust configuration options as required for your application, then just click the button GENERATE CODE . The generated files will be stored in the directory STM32CubeMX/MyBoard . Build the project using this command: cbuild CubeMX.csolution.yml --update-rte Note You may run the CubeMX generator at any time to change the configuration setting of your device or board. Directory with generated files CubeMX generates the following content in the generator output directory of the csolution project . In our example, the generator output directory is STM32CubeMX/MyBoard . Directory STM32CubeMX/MyBoard Content CubeMX.cgen.yml Generator import file that adds the CubeMX generated files to the csolution project . MX_Device/MX_Device.h Header file with configuration settings for CMSIS software components. STM32CubeMX/STM32CubeMX.ioc CubeMX native project file that includes settings. STM32CubeMX/Src CubeMX generated application code: main.c and STM32 setup code. STM32CubeMX/Inc Header files for CubeMX generated application code. STM32CubeMX/EWARM Project files for IAR; only startup code and linker scripts are used for csolution projects . STM32CubeMX/STM32CubeIDE Project files for STM32CubeIDE (GCC); only startup code and linker scripts are used for csolution projects . STM32CubeMX/MDK-ARM Project files for MDK version 5; only startup code and linker scripts are used for csolution projects . Note CubeMX generates only the directory for the selected toolchain, which is either STM32CubeMX/EWARM , STM32CubeMX/STM32CubeIDE , or STM32CubeMX/MDK-ARM . Content of Generator Import File: CubeMX.cgen.yml The file *.cgen.yml lists the files and settings that are generated by CubeMX and imported in the csolution project . The files under group: CubeMX may be modified by the user in sections marked with USER CODE BEGIN and USER CODE END to implement the application-specific features. In the file *.cproject.yml additional user files can be added. generator-import: for-device: STM32U585AIIx for-board: B-U585I-IOT02A define: - USE_FULL_LL_DRIVER - USE_HAL_DRIVER - STM32U585xx add-path: - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc/Legacy - ./STM32CubeMX/Drivers/CMSIS/Device/ST/STM32U5xx/Include - ./STM32CubeMX/Inc - ./MX_Device/CubeMX groups: - group: CubeMX files: - file: ./STM32CubeMX/Src/main.c - file: ./STM32CubeMX/Src/stm32u5xx_it.c - file: ./STM32CubeMX/Src/stm32u5xx_hal_msp.c - file: ./STM32CubeMX/MDK-ARM/startup_stm32u585xx.s - file: ./STM32CubeMX/Src/system_stm32u5xx.c - group: STM32 HAL Driver files: - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_utils.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_exti.c : - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_hal_pcd_ex.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_usb.c Adding an RTOS Many applications require an RTOS kernel. By default, CubeMX implements interrupt functions for all Cortex-M exception handlers. However, some exception handlers are typically required for the RTOS kernel execution. Adding an RTOS kernel requires these steps: Step 1: Add RTOS The example below adds the CMSIS-RTX RTOS kernel to a project. Other kernels require different components and packs, but the concept is similar. File: CubeMX.cproject.yml project: packs: - pack: ARM::CMSIS-RTX # RTOS Software Pack groups: - group: MyApp files: - file: MyMain.c components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX - component: CMSIS:RTOS2:Keil RTX5&Source # RTOS component - component: CMSIS:OS Tick:SysTick # OS Tick implementation for RTOS Step 2: Configure interrupt handlers Configure the interrupt handlers by running CubeMX with: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard Open the dialog Pinout & Configuration - System Core NVIC - Code generation and disable Generate IRQ handler for: System service call via SWI instruction Pendable request for system service System tick timer Then click the button GENERATE CODE to update the generated files in the directory STM32CubeMX/MyBoard Linker Script Usually, STM32CubeMX generates a linker script file that is tightly coupled with the generated startup and system initialization code. To ensure proper memory layout and application behavior, the generated linker script file must be used for all toolchains. It serves as a reliable baseline and can be tailored by the user to meet specific application requirements. Adding the linker script manually If generated, the linker script is available as described in this table: Toolchain Name in STM32CubeMX Linker script location Arm Compiler for Embedded (AC6) MDK-ARM ./STM32CubeMX/<target_name>/STM32CubeMX/MDK-ARM/<device_name>.sct IAR Compiler EWARM ./STM32CubeMX/<target_name>/STM32CubeMX/EWARM/<device_name>.icf GCC STM2CubeIDE/Makefile/CMake ./STM32CubeMX/<target_name>/STM32CubeMX/<device_name>.ld Add the linker script to your project by referencing it in the *.cproject.yml or *.clayer.yml file using the linker: node as shown in this example (adapt the for-compiler to your needs): linker: - script: ./STM32CubeMX/B-U585I-IOT02A/STM32CubeMX/STM32U585AIIX_FLASH.ld for-compiler: GCC Special case for Arm Compiler For Arm Compiler for Embedded (AC6), linker scripts are only generated for advanced configurations (e.g., when using the CubeMX Memory Manager). If generated, they must be used as shown above, as they align with the CubeMX-generated startup/system code. If no linker script is generated by STM32CubeMX, the default CMSIS-Toolbox linker script can be used, but it requires manual modification to remove ARM_LIB_HEAP and ARM_LIB_STACK , which are already defined in the generated startup file. In the regions_<device>.h file, remove this code: // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000C00 // </h> In the project's ac6_linker_script.sct.src file, add this at the beginning before the \"Stack seal size definition\": /* Stack and Heap are configured in startup file */ #define __STACK_SIZE 0 #define __HEAP_SIZE 0 In the project's ac6_linker_script.sct.src file around line 64, guard the ARM_LIB_STACK as follows: #if __STACK_SIZE > 0 ARM_LIB_STACK (__RAM0_BASE + __RAM0_SIZE - __STACKSEAL_SIZE) EMPTY -__STACK_SIZE { ; Reserve empty region for stack } #endif Use CubeMX with Board Layer A software layer is a set of pre-configured software components and source files that can be reused in multiple projects. A board layer typically contains basic I/O drivers and related device and board configuration. For a board layer, CubeMX can be used to generate device configuration and peripheral drivers. As a board layer uses a separate directory that is independent of a specific csolution project , the location of the STM32CubeMX generated files should be specified using the generators: node in the <board>.clayer.yml file. This locates the CubeMX-generated files in the directory structure of the software layer . As a board layer is used by several projects, the name of the generator import file should also be explicitly specified, as shown below: generators: options: - generator: CubeMX path: ./CubeMX # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`. This configuration results in the following directory structure: Directory and Files Description <board>.clayer.yml Defines the source files and software components of the board layer. CubeMX/ Directory with CubeMX ioc file and other generated files and folders. CubeMX/Board.cgen.yml Generator import file that lists CubeMX-generated files and options. CubeMX/STM32CubeMX/ Directory with CubeMX generated files. CubeMX/STM32CubeMX/Drivers/ Directory with driver-related source files. Several STM32 Board Support Packs with Generator Support contain board layers that use such a configuration. For examples, the Nucleo-F756ZG_BSP or B-U585I-IOT02A_BSP . TrustZone or Multi-Core Project Projects that use TrustZone or a multi-core device share the same STM32CubeMX configuration. Therefore, there is just one directory, STM32CubeMX, located at the same level as the *.csolution.yml project file. CubeMX Runtime Context Mapping Some devices, for example the STM32H7S series, provide in CubeMX runtime contexts , for example: Boot , Appli , ExtMemLoader . To map the csolution project context to these CubeMX runtime contexts it is required for this type of devices to use map: key in the generator : option, as shown below. The STM32H7S series uses the following CubeMX run-time names: Boot for the boot loader. Appli for the user application program. ExtMemLoader for the part that is in external memory. The generators: node is used to map a *.cproject.yml or *.clayer.yml file to a CubeMX run-time context as shown below. generators: options: - generator: CubeMX map: Appli # map project or layer to CubeMX runtime context Migration to CMSIS-Toolbox CubeMX Integration In previous CubeMX integrations a *.gpdsc file is used to import the generator output. The following table compares the CMSIS-Toolbox CubeMX integration (based on *.cgen.yml files) with the previous STM32CubeMX integration (based on *.gpdsc files). Comparison CMSIS-Toolbox *.cgen.yml Integration Previous *.gdpsc Integration IDE Support VS Code , Keil uVision 5.40 or higher Keil uVision, CMSIS-Pack for Eclipse CLI Tools CMSIS-Toolbox 2.4.0 or higher n/a STM32CubeMX project file STM32CubeMX.ioc STCubeGenerated.ioc STM32CubeMX source location ./STM32CubeMX/<target-type/STM32CubeMX/Src ./RTE/Device/<device name>/STCubeGenerated/Src or ./Board/<board name>/STM32CubeMX/Src STM32CubeMX include location ./STM32CubeMX/<target-type/STM32CubeMX/Inc ./RTE/Device/<device name>/STCubeGenerated/Inc or ./Board/<board name>/STM32CubeMX/Inc ST Firmware Provided by STM32Cube Firmware Packs Provided by STM32*_DFP software pack CMSIS-Driver Provided by CMSIS-Driver_STM32 software pack Provided by STM32*_DFP software pack To migrate existing projects that were using the previous STM32CubeMX integration (based on *.gpdsc files), use the following steps: Remove all component: Keil::Device:xxx from the *.cproject.yml file. Add the component: Device:CubeMX to the *.cproject.yml file. Use csolution run *.csolution.yml -g CubeMX to initialize the directory structure. Replace the file STM32CubeMX.ioc with the file STCubeGenerated.ioc from the previous project. Copy the source and include files from the previous location, as they may contain user modifications. Use csolution run *.csolution.yml -g CubeMX to generate the output from the previous STM32CubeMX project. Update the configuration in STM32CubeMX: In the tab Project Manager - Project set Project Settings - Toolchain/IDE to match the compiler selection in the csolution project. In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration. uVision - Update STM32 DFP Packs The Generator Integration of the CMSIS-Toolbox is also available with uVision version 5.40 or higher. New STM32*_DFP software packs containing release information Updated for new CMSIS-Toolbox CubeMX integration require migration. The steps below describe the migration process of a previous CubeMX configuration. In \u00b5Vision open the dialog Manage - Run-Time Environment . Remove all components from the Device Cclass, as CubeMX now manages the STM32 device firmware. Close Manage - Run-Time Environment with OK . Open the dialog Manage - Run-Time Environment again. Select the component Device:CubeMX and start STM32CubeMX with the play button. Update the configuration in STM32CubeMX: In the tab Project Manager - Project , set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration. Starting a new project works similarly with these steps: In uVision use Project - New uVision Project and select the STM32 device that you want to use. Optional: Project - Manage - Project items tab Project Info / Layer allows to select an evaluation board under Board . Open the dialog Manage - Run-Time Environment . Select the component Device:CubeMX and start STM32CubeMX with the play button. Create a new device configuration in STM32CubeMX: Follow the instructions of STM32CubeMX and verify settings. In the tab Project Manager - Project set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration.","title":"STM32CubeMX for STM32 Devices"},{"location":"CubeMX/#configure-stm32-devices-with-cubemx","text":"This chapter explains how to use STM32CubeMX with the CMSIS-Toolbox to manage device and board configuration. Note For the CMSIS-Toolbox CubeMX integration, STM32 packs with generator support are required. These software packs contain in the release information: Updated for new CMSIS-Toolbox CubeMX integration .","title":"Configure STM32 Devices with CubeMX"},{"location":"CubeMX/#introduction","text":"STM32CubeMX (CubeMX) is a graphical tool for configuration of an STM32 device or board. CubeMX generates C code for project and peripheral initialization, based on user settings. Depending on the device configuration, related drivers are added to the user application. The CMSIS-Toolbox interacts with CubeMX using the generic interface for generators . The component: Device:CubeMX connects a csolution project to CubeMX. This component imports the CubeMX generated files for a selected device: or board: using the generator import file *.cgen.yml . This file is similar to a software layer but managed by CubeMX and should be not modified directly. An example project created with CubeMX can be found in csolution-examples/CubeMX . Note If a board is specified in the csolution project , CubeMX pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the CubeMX dialogues. If a device is specified, the user needs to configure the peripherals manually using CubeMX dialogues.","title":"Introduction"},{"location":"CubeMX/#simple-project","text":"Below is a simple project that just adds the CubeMX-generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: CubeMX.csolution.yml solution: created-for: CMSIS-Toolbox@2.3.0 description: Simple CubeMX example cdefault: # use toolchain default settings compiler: AC6 # select toolchain # it is recommended to list the pack or packs that define the device or board used in the csolution.yml file packs: - pack: ARM::CMSIS # CMSIS pack is required for most projects - pack: Keil::B-U585I-IOT02A_BSP - pack: Keil::STM32U5xx_DFP@>=3.0.0-0 target-types: - type: MyBoard # My evaluation kit board: B-U585I-IOT02A # Board name as defined by the pack build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced projects: # list related projects - project: ./CubeMX.cproject.yml File: CubeMX.cproject.yml project: components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX Such a project cannot be directly built, as initially, the *.cgen.yml file is missing. It requires to run the CubeMX generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # generator name base-dir: STM32CubeMX/MyBoard # directory for generated files context: CubeMX.Debug+MyBoard # list of context that uses this directory context: CubeMX.Release+MyBoard Use the information above to run the generator: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard This starts CubeMX and passes the information about the selected board, device, and select toolchain. For a project that selects a board, CubeMX imports the default configuration for it. In CubeMX, review and adjust configuration options as required for your application, then just click the button GENERATE CODE . The generated files will be stored in the directory STM32CubeMX/MyBoard . Build the project using this command: cbuild CubeMX.csolution.yml --update-rte Note You may run the CubeMX generator at any time to change the configuration setting of your device or board. Directory with generated files CubeMX generates the following content in the generator output directory of the csolution project . In our example, the generator output directory is STM32CubeMX/MyBoard . Directory STM32CubeMX/MyBoard Content CubeMX.cgen.yml Generator import file that adds the CubeMX generated files to the csolution project . MX_Device/MX_Device.h Header file with configuration settings for CMSIS software components. STM32CubeMX/STM32CubeMX.ioc CubeMX native project file that includes settings. STM32CubeMX/Src CubeMX generated application code: main.c and STM32 setup code. STM32CubeMX/Inc Header files for CubeMX generated application code. STM32CubeMX/EWARM Project files for IAR; only startup code and linker scripts are used for csolution projects . STM32CubeMX/STM32CubeIDE Project files for STM32CubeIDE (GCC); only startup code and linker scripts are used for csolution projects . STM32CubeMX/MDK-ARM Project files for MDK version 5; only startup code and linker scripts are used for csolution projects . Note CubeMX generates only the directory for the selected toolchain, which is either STM32CubeMX/EWARM , STM32CubeMX/STM32CubeIDE , or STM32CubeMX/MDK-ARM . Content of Generator Import File: CubeMX.cgen.yml The file *.cgen.yml lists the files and settings that are generated by CubeMX and imported in the csolution project . The files under group: CubeMX may be modified by the user in sections marked with USER CODE BEGIN and USER CODE END to implement the application-specific features. In the file *.cproject.yml additional user files can be added. generator-import: for-device: STM32U585AIIx for-board: B-U585I-IOT02A define: - USE_FULL_LL_DRIVER - USE_HAL_DRIVER - STM32U585xx add-path: - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc - ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Inc/Legacy - ./STM32CubeMX/Drivers/CMSIS/Device/ST/STM32U5xx/Include - ./STM32CubeMX/Inc - ./MX_Device/CubeMX groups: - group: CubeMX files: - file: ./STM32CubeMX/Src/main.c - file: ./STM32CubeMX/Src/stm32u5xx_it.c - file: ./STM32CubeMX/Src/stm32u5xx_hal_msp.c - file: ./STM32CubeMX/MDK-ARM/startup_stm32u585xx.s - file: ./STM32CubeMX/Src/system_stm32u5xx.c - group: STM32 HAL Driver files: - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_utils.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_exti.c : - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_hal_pcd_ex.c - file: ./STM32CubeMX/Drivers/STM32U5xx_HAL_Driver/Src/stm32u5xx_ll_usb.c","title":"Simple Project"},{"location":"CubeMX/#adding-an-rtos","text":"Many applications require an RTOS kernel. By default, CubeMX implements interrupt functions for all Cortex-M exception handlers. However, some exception handlers are typically required for the RTOS kernel execution. Adding an RTOS kernel requires these steps:","title":"Adding an RTOS"},{"location":"CubeMX/#step-1-add-rtos","text":"The example below adds the CMSIS-RTX RTOS kernel to a project. Other kernels require different components and packs, but the concept is similar. File: CubeMX.cproject.yml project: packs: - pack: ARM::CMSIS-RTX # RTOS Software Pack groups: - group: MyApp files: - file: MyMain.c components: - component: CMSIS:CORE # CMSIS-Core component is required - component: Device:CubeMX # Component that connects to CubeMX - component: CMSIS:RTOS2:Keil RTX5&Source # RTOS component - component: CMSIS:OS Tick:SysTick # OS Tick implementation for RTOS","title":"Step 1: Add RTOS"},{"location":"CubeMX/#step-2-configure-interrupt-handlers","text":"Configure the interrupt handlers by running CubeMX with: csolution CubeMX.csolution.yml run --generator CubeMX --context CubeMX.Debug+MyBoard Open the dialog Pinout & Configuration - System Core NVIC - Code generation and disable Generate IRQ handler for: System service call via SWI instruction Pendable request for system service System tick timer Then click the button GENERATE CODE to update the generated files in the directory STM32CubeMX/MyBoard","title":"Step 2: Configure interrupt handlers"},{"location":"CubeMX/#linker-script","text":"Usually, STM32CubeMX generates a linker script file that is tightly coupled with the generated startup and system initialization code. To ensure proper memory layout and application behavior, the generated linker script file must be used for all toolchains. It serves as a reliable baseline and can be tailored by the user to meet specific application requirements.","title":"Linker Script"},{"location":"CubeMX/#adding-the-linker-script-manually","text":"If generated, the linker script is available as described in this table: Toolchain Name in STM32CubeMX Linker script location Arm Compiler for Embedded (AC6) MDK-ARM ./STM32CubeMX/<target_name>/STM32CubeMX/MDK-ARM/<device_name>.sct IAR Compiler EWARM ./STM32CubeMX/<target_name>/STM32CubeMX/EWARM/<device_name>.icf GCC STM2CubeIDE/Makefile/CMake ./STM32CubeMX/<target_name>/STM32CubeMX/<device_name>.ld Add the linker script to your project by referencing it in the *.cproject.yml or *.clayer.yml file using the linker: node as shown in this example (adapt the for-compiler to your needs): linker: - script: ./STM32CubeMX/B-U585I-IOT02A/STM32CubeMX/STM32U585AIIX_FLASH.ld for-compiler: GCC","title":"Adding the linker script manually"},{"location":"CubeMX/#special-case-for-arm-compiler","text":"For Arm Compiler for Embedded (AC6), linker scripts are only generated for advanced configurations (e.g., when using the CubeMX Memory Manager). If generated, they must be used as shown above, as they align with the CubeMX-generated startup/system code. If no linker script is generated by STM32CubeMX, the default CMSIS-Toolbox linker script can be used, but it requires manual modification to remove ARM_LIB_HEAP and ARM_LIB_STACK , which are already defined in the generated startup file. In the regions_<device>.h file, remove this code: // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000C00 // </h> In the project's ac6_linker_script.sct.src file, add this at the beginning before the \"Stack seal size definition\": /* Stack and Heap are configured in startup file */ #define __STACK_SIZE 0 #define __HEAP_SIZE 0 In the project's ac6_linker_script.sct.src file around line 64, guard the ARM_LIB_STACK as follows: #if __STACK_SIZE > 0 ARM_LIB_STACK (__RAM0_BASE + __RAM0_SIZE - __STACKSEAL_SIZE) EMPTY -__STACK_SIZE { ; Reserve empty region for stack } #endif","title":"Special case for Arm Compiler"},{"location":"CubeMX/#use-cubemx-with-board-layer","text":"A software layer is a set of pre-configured software components and source files that can be reused in multiple projects. A board layer typically contains basic I/O drivers and related device and board configuration. For a board layer, CubeMX can be used to generate device configuration and peripheral drivers. As a board layer uses a separate directory that is independent of a specific csolution project , the location of the STM32CubeMX generated files should be specified using the generators: node in the <board>.clayer.yml file. This locates the CubeMX-generated files in the directory structure of the software layer . As a board layer is used by several projects, the name of the generator import file should also be explicitly specified, as shown below: generators: options: - generator: CubeMX path: ./CubeMX # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`. This configuration results in the following directory structure: Directory and Files Description <board>.clayer.yml Defines the source files and software components of the board layer. CubeMX/ Directory with CubeMX ioc file and other generated files and folders. CubeMX/Board.cgen.yml Generator import file that lists CubeMX-generated files and options. CubeMX/STM32CubeMX/ Directory with CubeMX generated files. CubeMX/STM32CubeMX/Drivers/ Directory with driver-related source files. Several STM32 Board Support Packs with Generator Support contain board layers that use such a configuration. For examples, the Nucleo-F756ZG_BSP or B-U585I-IOT02A_BSP .","title":"Use CubeMX with Board Layer"},{"location":"CubeMX/#trustzone-or-multi-core-project","text":"Projects that use TrustZone or a multi-core device share the same STM32CubeMX configuration. Therefore, there is just one directory, STM32CubeMX, located at the same level as the *.csolution.yml project file.","title":"TrustZone or Multi-Core Project"},{"location":"CubeMX/#cubemx-runtime-context-mapping","text":"Some devices, for example the STM32H7S series, provide in CubeMX runtime contexts , for example: Boot , Appli , ExtMemLoader . To map the csolution project context to these CubeMX runtime contexts it is required for this type of devices to use map: key in the generator : option, as shown below. The STM32H7S series uses the following CubeMX run-time names: Boot for the boot loader. Appli for the user application program. ExtMemLoader for the part that is in external memory. The generators: node is used to map a *.cproject.yml or *.clayer.yml file to a CubeMX run-time context as shown below. generators: options: - generator: CubeMX map: Appli # map project or layer to CubeMX runtime context","title":"CubeMX Runtime Context Mapping"},{"location":"CubeMX/#migration-to-cmsis-toolbox-cubemx-integration","text":"In previous CubeMX integrations a *.gpdsc file is used to import the generator output. The following table compares the CMSIS-Toolbox CubeMX integration (based on *.cgen.yml files) with the previous STM32CubeMX integration (based on *.gpdsc files). Comparison CMSIS-Toolbox *.cgen.yml Integration Previous *.gdpsc Integration IDE Support VS Code , Keil uVision 5.40 or higher Keil uVision, CMSIS-Pack for Eclipse CLI Tools CMSIS-Toolbox 2.4.0 or higher n/a STM32CubeMX project file STM32CubeMX.ioc STCubeGenerated.ioc STM32CubeMX source location ./STM32CubeMX/<target-type/STM32CubeMX/Src ./RTE/Device/<device name>/STCubeGenerated/Src or ./Board/<board name>/STM32CubeMX/Src STM32CubeMX include location ./STM32CubeMX/<target-type/STM32CubeMX/Inc ./RTE/Device/<device name>/STCubeGenerated/Inc or ./Board/<board name>/STM32CubeMX/Inc ST Firmware Provided by STM32Cube Firmware Packs Provided by STM32*_DFP software pack CMSIS-Driver Provided by CMSIS-Driver_STM32 software pack Provided by STM32*_DFP software pack To migrate existing projects that were using the previous STM32CubeMX integration (based on *.gpdsc files), use the following steps: Remove all component: Keil::Device:xxx from the *.cproject.yml file. Add the component: Device:CubeMX to the *.cproject.yml file. Use csolution run *.csolution.yml -g CubeMX to initialize the directory structure. Replace the file STM32CubeMX.ioc with the file STCubeGenerated.ioc from the previous project. Copy the source and include files from the previous location, as they may contain user modifications. Use csolution run *.csolution.yml -g CubeMX to generate the output from the previous STM32CubeMX project. Update the configuration in STM32CubeMX: In the tab Project Manager - Project set Project Settings - Toolchain/IDE to match the compiler selection in the csolution project. In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration.","title":"Migration to CMSIS-Toolbox CubeMX Integration"},{"location":"CubeMX/#uvision-update-stm32-dfp-packs","text":"The Generator Integration of the CMSIS-Toolbox is also available with uVision version 5.40 or higher. New STM32*_DFP software packs containing release information Updated for new CMSIS-Toolbox CubeMX integration require migration. The steps below describe the migration process of a previous CubeMX configuration. In \u00b5Vision open the dialog Manage - Run-Time Environment . Remove all components from the Device Cclass, as CubeMX now manages the STM32 device firmware. Close Manage - Run-Time Environment with OK . Open the dialog Manage - Run-Time Environment again. Select the component Device:CubeMX and start STM32CubeMX with the play button. Update the configuration in STM32CubeMX: In the tab Project Manager - Project , set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration. Starting a new project works similarly with these steps: In uVision use Project - New uVision Project and select the STM32 device that you want to use. Optional: Project - Manage - Project items tab Project Info / Layer allows to select an evaluation board under Board . Open the dialog Manage - Run-Time Environment . Select the component Device:CubeMX and start STM32CubeMX with the play button. Create a new device configuration in STM32CubeMX: Follow the instructions of STM32CubeMX and verify settings. In the tab Project Manager - Project set Project Settings - Toolchain/IDE to MDK-ARM . In the tab Project Manager - Code Generator under STM32Cube MCU packages and embedded software packs select Copy only necessary library files . Click GENERATE CODE to complete the migration.","title":"uVision - Update STM32 DFP Packs"},{"location":"Experimental-Features/","text":"Experimental Features Experimental features are implemented to iterate on new functionality. Experimental features have limited test coverage and the functionality may change in future versions of the CMSIS-Toolbox without further notice. The CMSIS-Toolbox version 2.7 implements the experimental features for: - Resource Management Hardening and finalizing of these features is planned for CMSIS-Toolbox version 2.9. Resource Management In a multi-processor or multi-project application, the target type describes the target hardware. A solution is a collection of related projects, and the context set defines the projects that are deployed to the target hardware. A project uses a subset of resources (called regions at linker level). The linker script management is extended for multi-processor or multi-project applications with the following features: When resources: node is specified in one of the *.cproject.yml or *.clayer.yml files of a csolution project : The file .\\cmsis\\<solution-name>+<target-name>.regions.h is generated. This file contains the global region settings of a solution for one target type. The file .\\cmsis\\<solution-name>+<target-name>.regions.h replaces the regions_<device_or_board>.h that is located in the directory ./RTE/Device/<device> . The regions_<device_or_board>.h is no longer generated. A define: <project-name>_cproject is always added to the linker script pre-processor (also when no resources: node is used). The following picture explains the extended linker script management for multi-project applications. resources: The resources: node specifies the resources required by a project. It is used at the level of project: , setup: , or layer: . The resources: node is additive; when multiple resources: nodes specify the same region, the size is added. Note In a next iteration, the linker script may be generated by the CMSIS-Toolbox and features from uVision to allocate source modules to specific regions may get added. Therefore the resources: node is forward-looking in the way heap and stack are specified. resources: regions: - region: __ROM0 # region name pre-defined in script template: __ROM0..3 size: 0x10000 # specifies region size # name: ITCM_Flash - maps to physical memory name(s), if missing use PDSC default memory # address: - absolution address of region; not in scope for 2.7 # startup: - locate startup/vectors to this region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 - region: __RAM0 # region name pre-defined in script template: __RAM0..3 size: 0x8000 # specifies region size heap: 0x2000 # heap size (only permitted region __RAM0) stack: 0x4000 # stack size (only permitted in region __RAM0) # name: - maps to physical memory name(s), if missing use PDSC default memory # - SRAM1 # - SRAM2 # address: - absolution address of region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 # sections: - potentially locate sections (requires linker script generation); not in scope for 2.7 # - .text.function Example <solution-name>+<target-name>.regions.h file #ifndef USBD_STM32F746G_DISCO_REGIONS_H #define USBD_STM32F746G_DISCO_REGIONS_H // *** DO NOT MODIFY THIS FILE! *** // // Generated by csolution 2.7.0 based on packs and csolution project resources // Device Family Pack (DFP): Keil::STM32F7xx_DFP@3.0.0 // Board Support Pack (BSP): Keil::STM32F746G-DISCO_BSP@1.0.0 // Available Physical Memory Resources // rx ROM: Name: ITCM_Flash (from DFP) BASE: 0x00200000 SIZE: 0x00100000 // rx ROM: Name: Flash (from DFP) BASE: 0x08000000 SIZE: 0x00100000 (default) // rwx RAM: Name: DTCM (from DFP) BASE: 0x20000000 SIZE: 0x00010000 // rwx RAM: Name: SRAM1 (from DFP) BASE: 0x20010000 SIZE: 0x00020000 (default) // rwx RAM: Name: SRAM2 (from DFP) BASE: 0x20030000 SIZE: 0x00020000 (default) // rwx RAM: Name: BKP_SRAM (from DFP) BASE: 0x40024000 SIZE: 0x00001000 // rwx RAM: Name: ITCM (from DFP) BASE: 0x00000000 SIZE: 0x00004000 //-------------------------------------- #ifdef A_cproject // Resources allocated in A.cproject.yml #define __ROM0_BASE 0x08000000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00010000 #define __RAM0_BASE 0x20010000 /* Memory Name: SRAM1 */ #define __RAM0_SIZE 0x00008000 #define __STACK_SIZE 0x00004000 #define __HEAP_SIZE 0x00002000 #endif /* A_cproject */ //-------------------------------------- #ifdef B_cproject // Resources allocated in B.cproject.yml #define __ROM0_BASE 0x08010000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00030000 #define __RAM0_BASE 0x20018000 /* Memory Name: SRAM1+SRAM2 */ #define __RAM0_SIZE 0x00020000 #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000000 #endif /* B_cproject */ #endif /* USBD_STM32F746G_DISCO_REGIONS_H */ Question Should the <solution-name>+<target-name>.regions.h file contain also #define symbols for the overall available memory, i.e. for a boot loader? Server Mode The csolution tool supports the command line argument rpc to initiate a server mode. With this mode rpc commands can be initiated. The first set of commands will be used by the VS Code CMSIS Solution extension to select components and packs for projects and layers. Refer to github.com/Open-CMSIS-Pack/csolution-rpc for more information.","title":"Experimental Features"},{"location":"Experimental-Features/#experimental-features","text":"Experimental features are implemented to iterate on new functionality. Experimental features have limited test coverage and the functionality may change in future versions of the CMSIS-Toolbox without further notice. The CMSIS-Toolbox version 2.7 implements the experimental features for: - Resource Management Hardening and finalizing of these features is planned for CMSIS-Toolbox version 2.9.","title":"Experimental Features"},{"location":"Experimental-Features/#resource-management","text":"In a multi-processor or multi-project application, the target type describes the target hardware. A solution is a collection of related projects, and the context set defines the projects that are deployed to the target hardware. A project uses a subset of resources (called regions at linker level). The linker script management is extended for multi-processor or multi-project applications with the following features: When resources: node is specified in one of the *.cproject.yml or *.clayer.yml files of a csolution project : The file .\\cmsis\\<solution-name>+<target-name>.regions.h is generated. This file contains the global region settings of a solution for one target type. The file .\\cmsis\\<solution-name>+<target-name>.regions.h replaces the regions_<device_or_board>.h that is located in the directory ./RTE/Device/<device> . The regions_<device_or_board>.h is no longer generated. A define: <project-name>_cproject is always added to the linker script pre-processor (also when no resources: node is used). The following picture explains the extended linker script management for multi-project applications.","title":"Resource Management"},{"location":"Experimental-Features/#resources","text":"The resources: node specifies the resources required by a project. It is used at the level of project: , setup: , or layer: . The resources: node is additive; when multiple resources: nodes specify the same region, the size is added. Note In a next iteration, the linker script may be generated by the CMSIS-Toolbox and features from uVision to allocate source modules to specific regions may get added. Therefore the resources: node is forward-looking in the way heap and stack are specified. resources: regions: - region: __ROM0 # region name pre-defined in script template: __ROM0..3 size: 0x10000 # specifies region size # name: ITCM_Flash - maps to physical memory name(s), if missing use PDSC default memory # address: - absolution address of region; not in scope for 2.7 # startup: - locate startup/vectors to this region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 - region: __RAM0 # region name pre-defined in script template: __RAM0..3 size: 0x8000 # specifies region size heap: 0x2000 # heap size (only permitted region __RAM0) stack: 0x4000 # stack size (only permitted in region __RAM0) # name: - maps to physical memory name(s), if missing use PDSC default memory # - SRAM1 # - SRAM2 # address: - absolution address of region; not in scope for 2.7 # align: - alignment restrictions of the regions; not in scope for 2.7 # sections: - potentially locate sections (requires linker script generation); not in scope for 2.7 # - .text.function","title":"resources:"},{"location":"Experimental-Features/#example-solution-nametarget-nameregionsh-file","text":"#ifndef USBD_STM32F746G_DISCO_REGIONS_H #define USBD_STM32F746G_DISCO_REGIONS_H // *** DO NOT MODIFY THIS FILE! *** // // Generated by csolution 2.7.0 based on packs and csolution project resources // Device Family Pack (DFP): Keil::STM32F7xx_DFP@3.0.0 // Board Support Pack (BSP): Keil::STM32F746G-DISCO_BSP@1.0.0 // Available Physical Memory Resources // rx ROM: Name: ITCM_Flash (from DFP) BASE: 0x00200000 SIZE: 0x00100000 // rx ROM: Name: Flash (from DFP) BASE: 0x08000000 SIZE: 0x00100000 (default) // rwx RAM: Name: DTCM (from DFP) BASE: 0x20000000 SIZE: 0x00010000 // rwx RAM: Name: SRAM1 (from DFP) BASE: 0x20010000 SIZE: 0x00020000 (default) // rwx RAM: Name: SRAM2 (from DFP) BASE: 0x20030000 SIZE: 0x00020000 (default) // rwx RAM: Name: BKP_SRAM (from DFP) BASE: 0x40024000 SIZE: 0x00001000 // rwx RAM: Name: ITCM (from DFP) BASE: 0x00000000 SIZE: 0x00004000 //-------------------------------------- #ifdef A_cproject // Resources allocated in A.cproject.yml #define __ROM0_BASE 0x08000000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00010000 #define __RAM0_BASE 0x20010000 /* Memory Name: SRAM1 */ #define __RAM0_SIZE 0x00008000 #define __STACK_SIZE 0x00004000 #define __HEAP_SIZE 0x00002000 #endif /* A_cproject */ //-------------------------------------- #ifdef B_cproject // Resources allocated in B.cproject.yml #define __ROM0_BASE 0x08010000 /* Memory Name: Flash */ #define __ROM0_SIZE 0x00030000 #define __RAM0_BASE 0x20018000 /* Memory Name: SRAM1+SRAM2 */ #define __RAM0_SIZE 0x00020000 #define __STACK_SIZE 0x00000200 #define __HEAP_SIZE 0x00000000 #endif /* B_cproject */ #endif /* USBD_STM32F746G_DISCO_REGIONS_H */","title":"Example &lt;solution-name&gt;+&lt;target-name&gt;.regions.h file"},{"location":"Experimental-Features/#question","text":"Should the <solution-name>+<target-name>.regions.h file contain also #define symbols for the overall available memory, i.e. for a boot loader?","title":"Question"},{"location":"Experimental-Features/#server-mode","text":"The csolution tool supports the command line argument rpc to initiate a server mode. With this mode rpc commands can be initiated. The first set of commands will be used by the VS Code CMSIS Solution extension to select components and packs for projects and layers. Refer to github.com/Open-CMSIS-Pack/csolution-rpc for more information.","title":"Server Mode"},{"location":"JLink-Debugger/","text":"Segger J-Link Debugger Note This section contains preliminary information and is work-in-progress. The CMSIS-Toolbox organizes for debuggers projects and configuration options. This chapter explains the usage of the Segger J-Link GDB Server in combination with the CMSIS-Toolbox. Extended Options explains additional configuration features that are required in specific use-cases. Other manual sections describe how to configure debuggers: Run and Debug Configuration explains overall structure and how projects and images are configured. Debugger Configuration - J-Link Server contains details about the options that are specific to J-Link. Extended Options The section Debugger Configuration - J-Link Server contains the J-Link configuration for typical systems. connect: Configures the behavior for connecting J-Link to the hardware target for interactive debug. connect: Description mode: Required Selects the connect mode: attach , halt (default). Connect Mode Description attach Do not change state of the core(s). No reset is executed. halt Halt core(s) after connect. reset: Configures the reset behavior for each core when a reset is requested during interactive debug. reset: Description - pname: Optional Identifies the processor (not requried for single core system). type: Required Selects the reset type: hardware , system (default), core . Reset Types Description hardware Use the J-Link reset pin reset mode. system Use the J-Link normal reset mode. core Use the J-Link core reset mode. Examples: debugger: name: J-Link Server # default connect, halt and reset behavior debugger: name: J-Link Server connect: attach # connect without reset and without CPU state change reset: - type: system # use system reset debugger: name: J-Link Server connect: halt # halt CPU after connect reset: - pname: Core0 # for Core0 type: hardware # use hardware reset - pname: Core1 # for Core1 type: core # use core reset","title":"J-Link Debugger"},{"location":"JLink-Debugger/#segger-j-link-debugger","text":"Note This section contains preliminary information and is work-in-progress. The CMSIS-Toolbox organizes for debuggers projects and configuration options. This chapter explains the usage of the Segger J-Link GDB Server in combination with the CMSIS-Toolbox. Extended Options explains additional configuration features that are required in specific use-cases. Other manual sections describe how to configure debuggers: Run and Debug Configuration explains overall structure and how projects and images are configured. Debugger Configuration - J-Link Server contains details about the options that are specific to J-Link.","title":"Segger J-Link Debugger"},{"location":"JLink-Debugger/#extended-options","text":"The section Debugger Configuration - J-Link Server contains the J-Link configuration for typical systems.","title":"Extended Options"},{"location":"JLink-Debugger/#connect","text":"Configures the behavior for connecting J-Link to the hardware target for interactive debug. connect: Description mode: Required Selects the connect mode: attach , halt (default). Connect Mode Description attach Do not change state of the core(s). No reset is executed. halt Halt core(s) after connect.","title":"connect:"},{"location":"JLink-Debugger/#reset","text":"Configures the reset behavior for each core when a reset is requested during interactive debug. reset: Description - pname: Optional Identifies the processor (not requried for single core system). type: Required Selects the reset type: hardware , system (default), core . Reset Types Description hardware Use the J-Link reset pin reset mode. system Use the J-Link normal reset mode. core Use the J-Link core reset mode. Examples: debugger: name: J-Link Server # default connect, halt and reset behavior debugger: name: J-Link Server connect: attach # connect without reset and without CPU state change reset: - type: system # use system reset debugger: name: J-Link Server connect: halt # halt CPU after connect reset: - pname: Core0 # for Core0 type: hardware # use hardware reset - pname: Core1 # for Core1 type: core # use core reset","title":"reset:"},{"location":"MCUXpressoConfig/","text":"MCUXpresso for NXP Devices This chapter explains how to use the MCUXpresso Config Tool with the CMSIS-Toolbox to manage device and board configuration. Note MCUXpresso Config Tools integration with CMSIS-Toolbox is available with CMSIS packs based on MCUXpresso SDK 2.16.0 (or higher). Overview The MCUXpresso Config Tool is a graphical tool for configuring an NXP device or board. Based on user settings, MCUXpresso generates C code for project and peripheral initialization. The CMSIS-Toolbox interacts with MCUXpresso Config Tools using the generic interface for generators and automatically adds generated source code to the project. The component: Device:Config Tools connects a csolution project to MCUXpresso. This component imports the MCUXpresso generated files for a selected device: or board: using the generator import file ( *.cgen.yml ). This *.cgen.yml file is similar to a software layer but managed by MCUXpresso and should not be modified directly. An example project created with MCUXpresso can be found in csolution-examples/DualCore . Note When a board is specified in the csolution project , MCUXpresso pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the MCUXpresso dialogues. When only a device is specified, the user needs to configure the peripherals manually using MCUXpresso dialogs. Simple Project Below is a simple project that just adds the MCUXpresso-generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: Simple.csolution.yml solution: created-for: CMSIS-Toolbox@2.6.0 # List of tested compilers that can be selected select-compiler: - compiler: AC6 - compiler: GCC - compiler: IAR # List the packs that define the device and/or board. packs: - pack: NXP::FRDM-MCXN947_BSP - pack: NXP::MCXN947_DFP - pack: ARM::CMSIS # List different hardware targets that are used to deploy the solution. target-types: - type: MCXN947VDF board: NXP::FRDM-MCXN947 device: NXP::MCXN947VDF # List of different build configurations. build-types: - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced # List related projects. projects: - project: Simple.cproject.yml File: Simple.cproject.yml project: device: :cm33_core0 generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig name: ConfigTools # List components to use for your application. # A software component is a reusable unit that may be configurable. components: - component: Device:Config Tools:Init - component: Device:Startup - component: Device:CMSIS:MCXN947_header - component: Device:CMSIS:MCXN947_system - component: Device:SDK Drivers:clock - component: Device:SDK Drivers:common - component: Device:SDK Drivers:mcx_spc - component: Device:SDK Drivers:reset - component: CMSIS:CORE groups: - group: Main files: - file: ./main.c Such a project cannot be built directly as the *.cgen.yml file is initially missing. It requires running the MCUXpresso generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution Simple.csolution.yml list generators --verbose MCUXpressoConfig (Global Registered Generator MCUXpresso Config tools) base-dir: MCUXpressoConfig cgen-file: MCUXpressoConfig/ConfigTools.cgen.yml context: Simple.Debug+MCXN947VDF context: Simple.Release+MCXN947VDF Using the above information to run the generator using this command: csolution Simple.csolution.yml run --generator MCUXpressoConfig --context Simple.Debug+MCXN947VDF It starts MCUXpresso and passes information about the selected board, device, and selected toolchain. For a project that selects a board, MCUXpresso imports the default configuration for the evaluation kit. In MCUXpresso, review and adjust configuration options as required for your application, then just click the button Update Code . The generated files will be stored in the directory ./MCUXpressoConfig . Build the project using this command: cbuild Simple.csolution.yml --update-rte Note You may run the MCUXpresso Config Tools at any time to change the configuration setting of your device or board. Directory with generated files MCUXpresso generates the following content in the generator output directory of the csolution project . In our example, the generator output directory is ./MCUXpressoConfig . Directory ./MCUXpressoConfig Content ConfigTools.cgen.yml Import file, which adds the generated files to the csolution project . FRDM-MCXN947.mex MCUXpresso Config Tools configuration file. board/clock_config.c Clock setup using clock driver functions. board/clock_config.h Clock configuration header file. board/peripherals.c Board peripherals are set up via init functions. board/peripherals.h Board peripherals setup header file. board/pin_mux.c Board pin setup via init functions. board/pin_mux.h Board pin setup header file. Content of Generator Import File: ConfigTools.cgen.yml The file ConfigTools.cgen.yml lists the files and settings that are generated by MCUXpresso and imported into the csolution project . You may add further user files here. generator-import: generated-by: 'MCUXpresso config tools Generated: 09/12/2024 17:02:22' for-device: MCXN947 for-board: FRDM-MCXN947 groups: - group: ConfigTools board files: - file: board/clock_config.c - file: board/clock_config.h - file: board/peripherals.c - file: board/peripherals.h - file: board/pin_mux.c - file: board/pin_mux.h Linker Script Depending on the toolchain, NXP provides a linker script. For Arm Compiler 6, a scatter file with the ending *.scf is provided, for GCC, a linker script file with the ending *.ld is provided and for IAR, the provided linker script files end with *.icf extension. Create a Board Layer A software layer is a set of pre-configured software components and source files that can be reused in multiple projects. A board layer typically contains basic I/O drivers and related device and board configuration. MCUXpresso generates a significant part of a board layer. The board layer is stored in a separate directory that is independent of a specific csolution project . To create a board layer, copy the related source files, the MCUXpresso generated files, and the configuration files of the RTE directory that relate to software components in the board layer. Example directory content of a NXP board layer Directory and Files Description Board.clayer.yml Defines the source files and software components of the board layer. MCUXpressoConfig/ Directory with MCUXpresso generated files. MCUXpressoConfig/Board.cgen.yml Generator import file that lists MCUXpresso generated files and options. The Board.clayer.yml file defines, with the generators: node, options to locate the MCUXpresso generated files in the directory structure of the software layer . As a board layer is used by many projects, the name of the generator import file should be explicitly specified, as shown below: generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`.","title":"MCUXpresso for NXP Devices"},{"location":"MCUXpressoConfig/#mcuxpresso-for-nxp-devices","text":"This chapter explains how to use the MCUXpresso Config Tool with the CMSIS-Toolbox to manage device and board configuration. Note MCUXpresso Config Tools integration with CMSIS-Toolbox is available with CMSIS packs based on MCUXpresso SDK 2.16.0 (or higher).","title":"MCUXpresso for NXP Devices"},{"location":"MCUXpressoConfig/#overview","text":"The MCUXpresso Config Tool is a graphical tool for configuring an NXP device or board. Based on user settings, MCUXpresso generates C code for project and peripheral initialization. The CMSIS-Toolbox interacts with MCUXpresso Config Tools using the generic interface for generators and automatically adds generated source code to the project. The component: Device:Config Tools connects a csolution project to MCUXpresso. This component imports the MCUXpresso generated files for a selected device: or board: using the generator import file ( *.cgen.yml ). This *.cgen.yml file is similar to a software layer but managed by MCUXpresso and should not be modified directly. An example project created with MCUXpresso can be found in csolution-examples/DualCore . Note When a board is specified in the csolution project , MCUXpresso pre-configures the device peripherals with sensible settings for the evaluation board. The user may change these settings using the MCUXpresso dialogues. When only a device is specified, the user needs to configure the peripherals manually using MCUXpresso dialogs.","title":"Overview"},{"location":"MCUXpressoConfig/#simple-project","text":"Below is a simple project that just adds the MCUXpresso-generated components. Tip The packs required for boards and devices are listed on www.keil.arm.com/boards and www.keil.arm.com/devices . File: Simple.csolution.yml solution: created-for: CMSIS-Toolbox@2.6.0 # List of tested compilers that can be selected select-compiler: - compiler: AC6 - compiler: GCC - compiler: IAR # List the packs that define the device and/or board. packs: - pack: NXP::FRDM-MCXN947_BSP - pack: NXP::MCXN947_DFP - pack: ARM::CMSIS # List different hardware targets that are used to deploy the solution. target-types: - type: MCXN947VDF board: NXP::FRDM-MCXN947 device: NXP::MCXN947VDF # List of different build configurations. build-types: - type: Debug debug: on optimize: none - type: Release debug: off optimize: balanced # List related projects. projects: - project: Simple.cproject.yml File: Simple.cproject.yml project: device: :cm33_core0 generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig name: ConfigTools # List components to use for your application. # A software component is a reusable unit that may be configurable. components: - component: Device:Config Tools:Init - component: Device:Startup - component: Device:CMSIS:MCXN947_header - component: Device:CMSIS:MCXN947_system - component: Device:SDK Drivers:clock - component: Device:SDK Drivers:common - component: Device:SDK Drivers:mcx_spc - component: Device:SDK Drivers:reset - component: CMSIS:CORE groups: - group: Main files: - file: ./main.c Such a project cannot be built directly as the *.cgen.yml file is initially missing. It requires running the MCUXpresso generator. Before you start, you may need to install missing packs . Identify the required generator and the directory where the generated files are stored with: csolution Simple.csolution.yml list generators --verbose MCUXpressoConfig (Global Registered Generator MCUXpresso Config tools) base-dir: MCUXpressoConfig cgen-file: MCUXpressoConfig/ConfigTools.cgen.yml context: Simple.Debug+MCXN947VDF context: Simple.Release+MCXN947VDF Using the above information to run the generator using this command: csolution Simple.csolution.yml run --generator MCUXpressoConfig --context Simple.Debug+MCXN947VDF It starts MCUXpresso and passes information about the selected board, device, and selected toolchain. For a project that selects a board, MCUXpresso imports the default configuration for the evaluation kit. In MCUXpresso, review and adjust configuration options as required for your application, then just click the button Update Code . The generated files will be stored in the directory ./MCUXpressoConfig . Build the project using this command: cbuild Simple.csolution.yml --update-rte Note You may run the MCUXpresso Config Tools at any time to change the configuration setting of your device or board. Directory with generated files MCUXpresso generates the following content in the generator output directory of the csolution project . In our example, the generator output directory is ./MCUXpressoConfig . Directory ./MCUXpressoConfig Content ConfigTools.cgen.yml Import file, which adds the generated files to the csolution project . FRDM-MCXN947.mex MCUXpresso Config Tools configuration file. board/clock_config.c Clock setup using clock driver functions. board/clock_config.h Clock configuration header file. board/peripherals.c Board peripherals are set up via init functions. board/peripherals.h Board peripherals setup header file. board/pin_mux.c Board pin setup via init functions. board/pin_mux.h Board pin setup header file. Content of Generator Import File: ConfigTools.cgen.yml The file ConfigTools.cgen.yml lists the files and settings that are generated by MCUXpresso and imported into the csolution project . You may add further user files here. generator-import: generated-by: 'MCUXpresso config tools Generated: 09/12/2024 17:02:22' for-device: MCXN947 for-board: FRDM-MCXN947 groups: - group: ConfigTools board files: - file: board/clock_config.c - file: board/clock_config.h - file: board/peripherals.c - file: board/peripherals.h - file: board/pin_mux.c - file: board/pin_mux.h","title":"Simple Project"},{"location":"MCUXpressoConfig/#linker-script","text":"Depending on the toolchain, NXP provides a linker script. For Arm Compiler 6, a scatter file with the ending *.scf is provided, for GCC, a linker script file with the ending *.ld is provided and for IAR, the provided linker script files end with *.icf extension.","title":"Linker Script"},{"location":"MCUXpressoConfig/#create-a-board-layer","text":"A software layer is a set of pre-configured software components and source files that can be reused in multiple projects. A board layer typically contains basic I/O drivers and related device and board configuration. MCUXpresso generates a significant part of a board layer. The board layer is stored in a separate directory that is independent of a specific csolution project . To create a board layer, copy the related source files, the MCUXpresso generated files, and the configuration files of the RTE directory that relate to software components in the board layer. Example directory content of a NXP board layer Directory and Files Description Board.clayer.yml Defines the source files and software components of the board layer. MCUXpressoConfig/ Directory with MCUXpresso generated files. MCUXpressoConfig/Board.cgen.yml Generator import file that lists MCUXpresso generated files and options. The Board.clayer.yml file defines, with the generators: node, options to locate the MCUXpresso generated files in the directory structure of the software layer . As a board layer is used by many projects, the name of the generator import file should be explicitly specified, as shown below: generators: options: - generator: MCUXpressoConfig path: ./MCUXpressoConfig # path relative to the `*.clayer.yml` file name: Board # generator import file is named `Board.cgen.yml`.","title":"Create a Board Layer"},{"location":"ReferenceApplications/","text":"Reference Applications This chapter explains how to work with Reference Applications that can run on several evaluation boards. Introduction The CMSIS-Pack format supports different types of project examples: Template Projects are stub projects that help getting started. Some software packs may contain device-specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These project examples show the usage of middleware components and require additional software layers with API drivers for the specific target hardware, typically an evaluation board. The following sections explain the usage, structure, and creation of Reference Applications that can target many different evaluation boards. Refer to Pack Creation s\u00bb Project Examples for information on how to publish project examples as part of software packs. Types of Reference Applications Reference Applications may show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Such software uses application programming interfaces (APIs) to interface with hardware interfaces or other software components. MDK-Middleware Reference Applications The MDK-Middleware provides software components for IPv4/IPv6 networking, USB Host/Device communication, and a variety of file systems for data storage. The MDK-Middleware software pack contains Reference Applications that show how to use these software components. These examples are hardware agnostic; adding a board layer that provides the required APIs allows running the example project on specific target hardware. The picture above shows how a USB HID example connects to a board-specific software layer. The Reference Application does not specify a target hardware. For execution on target hardware, a software layer is required that provides the hardware-specific APIs. These board-specific layers are provided in BSP packs, which allows the example to run on many different hardware targets. The Reference example uses connections: to list the consumed (required) APIs. The board layer in the BSP pack provides these connections: and may offer several additional connections: , making the layer suitable for a wide range of Reference Applications. As the Reference Application is not hardware-specific, it does not define a target type. Also, it does not add the board-specific software layer. It requires two steps to configure the *.csolution.yml file of such an example for an evaluation board. Refer to the Usage section for more information. Reference Application *.csolution.yml file solution: cdefault: compiler: AC6 : packs: # Step 1: Specify DFP and BSP for the device and board, for example with: # - pack: Keil::STM32U5xx_DFP # - pack: Keil::B-U585I-IOT02A_BSP target-types: # Step 1: Specify your board, for example with: # - type: STM32U585 # board: B-U585I-IOT02A # Step 2: Run `cbuild setup` and use cbuild-idx.yml to identify variables, for example: # variables: # - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml Sensor Reference Applications The overall concept of Reference Applications and the same board-specific software layers can be used for a wide range of software stacks. For example, a sensor SDK pack may provide Reference Applications that show the usage of a MEMS sensor. This MEMS sensor is additional hardware that could be provided by a widely supported Arduino UNO shield. The sensor SDK with the related Arduino shield can be structured to work with a wide range of evaluation boards that offer a compatible board-specific software layer. The overall structure of a sensor example project is shown in the picture below. It is composed of: The Reference Application with sensor-specific middleware that shows the usage of a MEMS sensor. Layer type: Board contains the hardware-specific setup of an evaluation board with a Cortex-M processor along with drivers, i.e. for SPI or I2C that connect to the pins of the Arduino shield. Layer type: Shield defines the pin routing of the Arduino UNO shield, which adds the MEMS sensor to the evaluation board. Note As the connections: for the MEMS sensor are specific to the sensor itself, the same Reference Application also works with an evaluation board that integrates the MEMS sensor (and, therefore, requires no Shield layer). In this case, the board-specific software layer adds the sensor-specific connections: . Targeting Custom Hardware A Reference Application may serve as a starting point for user applications that target custom hardware. It is required to provide: A software layer with a compatible set of APIs ( connections: ) consumed by the Reference Application . This software layer can be added along with the target type (in the *.csolution.yml file) that defines the custom hardware. Note It is not required to define connections: as this information is only used to identify compatible layers. A header file that replaces the CMSIS_target_header . Refer to Header File Structure for more information. Example *.csolution.yml file for custom hardware solution: cdefault: compiler: AC6 : target-types: - type: MyHardware device: STM32U585AIIx # custom hardware uses only a device definition variables: - Board-Layer: $SolutionDir()$/MyTarget/MyHardware.clayer.yml Example MyHardware.clayer.yml You may use a *.clayer.yml file for implementing the HAL drivers for the application and define the CMSIS_target_header as shown below: layer: : define: - CMSIS_target_header: \"\\\"MyHardware.h\\\"\" Usage A Reference Application is an incomplete *.csolution.yml project file that requires additional intervention. The following steps explain how to compile the project: Step 1: Add DFP and BSP In the *.csolution.yml file under the packs: node, add the DFP (for the device) and the BSP (for the board). Under target-types: , add your board. solution: cdefault: : packs: - pack: Keil::STM32U5xx_DFP - pack: Keil::B-U585I-IOT02A_BSP target-types: - type: MyBoard board: B-U585I-IOT02A # name of a target board Step 2: Run cbuild setup Run cbuild setup with the *.csolution.yml file. This identifies compatible layers that are part of the software packs listed in the *.csolution.yml file with an output similar to: >cbuild setup xxx.csolution.yml error csolution: undefined variables in xxx.csolution.yml: - $Board-Layer$ To resolve undefined variables, copy the settings from cbuild-idx.yml to csolution.yml The related *.cbuild-idx.yml should contain information similar to this: build-idx: generated-by: csolution version 2.4.0 cdefault: cdefault.yml csolution: xxx.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml description: B-U585I-IOT02A Board setup for IoT path: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT file: Board.clayer.yml copy-to: .Board/U585 As a user, you have now two choices to work with the identified software layer: Refer layers in ${CMSIS_PACK_ROOT} This is useful when there is no plan to modify the software layer, for example, in the early phase of adoption. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml Copy layers to csolution project This allows the modification of the layer, for example, adding or removing drivers or changing device settings. It requires these steps: Copy all files from path , i.e. ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT to the local csolution project directory. If set, remove the R/O attribute from the copied files. Under variables: , add the path to the *.clayer.yml file. Use $SolutionDir() as base path to make the project portable. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml Note The copy step is executed for you by some IDEs during the Create New Project workflow. Structure The following section describes the overall file structure of Reference Applications . Project Files A *.csolution.yml project file containing software layers for two different evaluation boards should look like the one shown below. This project contains three examples that show the different features of USB device middleware. The actual example project (HID, MSC, or CDC1) is selected using a context set ; the compiler is selected using the --toolchain option. To translate the completed Reference Applications use: cbuild USB_Device.csolution.yml --context-set --toolchain AC6 Example USB_Device.csolution.yml file for two boards with three projects solution: created-for: CMSIS-Toolbox@2.4.0 cdefault: target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A variables: - Board-Layer: $SolutionDir()$\\Board\\B-U585I-IOT02A\\Board.clayer.yml - type: LPC55S69-EVK # type name identical with board name? board: LPC55S69-EVK variables: - Board-Layer: $SolutionDir()$\\Board\\LPC55S69-EVK\\Board.clayer.yml build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: HID/HID.cproject.yml - project: MSC/MassStorage.cproject.yml - project: CDC1/VirtualCOM.cproject.yml Typical Directory Structure The table below shows the typical directory structure of the above example from the programmer's point of view. The software layer in the directory ./Board is copied from the BSP of the related board. Directory Content Content USB_Device.csolution.yml Overall CMSIS solution project file. ./HID/ HID example project from MDK-Middleware pack. ./MSC/ MSC example project from MDK-Middleware pack. ./CDC1/ CDC1 example project from MDK-Middleware pack. ./Board/B-U585I-IOT02A Board software layer from B-U585I-IOT02A BSP. ./Board/LPC55S69-EVK Board software layer from LPC55S69-EVK BSP. Header File Structure The interfaces between the software layers are defined in header files. Thus, is it possible to reuse the various software blocks with other build systems that are not CMSIS aware. The following diagram shows the overall header file structure. The Reference Application has no direct access to hardware. Therefore, it does not use the CMSIS_device_header provided by the CMSIS-Core that defines the registers and interrupt mapping. To access target hardware, these header files are used by the Reference Application : Standardized Driver API header files are used for communication with device peripherals. Header files of CMSIS-Drivers are provided by the CMSIS base software pack . The configuration of the driver interfaces is defined by the CMSIS_target_header . This header therefore specifies the available resources of the target hardware that can be used by the Reference Application . The Header File Example shows a typical structure of the CMSIS_target_header . When a shield is applied to an evaluation board, the CMSIS_shield_header extends the resource configuration of the CMSIS_target_header . Note The driver implementation of the hardware abstraction might use shim layer as shown on the right side of above diagram. For example, the driver implementation for STM32 devices uses the STM32 HAL. Application Program Start A Reference Application starts with the C function app_main as shown below. #include CMSIS_target_header // board resource definitions // reference application of a middleware component int app_main (void) { }; The application may use an RTOS kernel or run a simple while loop. Additional software components such as CMSIS-View , CMSIS-DSP , or MbedTLS are added directly to the Reference Application . In general, the connections: that are consumed should be minimized, allowing the example to be run on many different target boards. Board Layer The board layer provides system startup, board/device hardware initialization, and transfers control to the application. It also exposes various drivers and interfaces. Typical Features: System startup, including clock and memory configuration. Device/Board hardware initialization. Calls the application startup function. Drivers for board peripherals [optional]. Interfaces to LEDs and switches [optional]. STDIO re-targeting to debug interfaces [optional]. Shield setup and drivers for Arduino interfaces [optional]. Heap and Stack configuration [optional]. Files: CMSIS startup and system file for device initialization. main.c source module that implements the function main . Optional drivers and interfaces (CMSIS-Drivers, GPIO, STDIO). Files that relate to the device and/or board configuration (i.e. generated by MCUXpresso or STM32CubeMX) Linker script definition for boards that require specific memory configurations. The configuration parameters of the available APIs are defined in CMSIS_target_header . Generator Usage: The board-specific software layer is used in many different projects. When a board configuration is generated by tools, such as MCUXpresso or STM32CubeMX, for example, configure the generator output directory and import file using the generators: node in the *.clayer.yml file as shown below: layer: generators: options: - generator: CubeMX path: ./CubeMX name: Board Shield Layer A shield layer adds support for additional hardware via plugin shields (i.e. Arduino Uno). Arduino shields consume connections with the prefix ARDUINO_UNO_ . In the future, other shields may be supported as well. Shields may feature various hardware modules such as WiFi chips or MEMS sensors. Frequently, the shield's software layer only defines a header file that redirects the Arduino-specific connect: to a chip-specific connect: , which is then used by application software. The shield's software layer is configured from the board software layer, which calls the following function: extern int32_t shield_setup (void); Connections Connections are only used to identify compatible software layers. Since there are no strict rules for the connect Name , it is possible to extend it with additional namespacing, i.e., prefixing with ST_ to denote ST-specific interfaces. There are also no strict rules on how the different software layers consume or provide the connect names. However, guidelines will be developed once reference applications mature. Currently, the following connect names are used. connect name Value Description . . Arduino Shield Interface ARDUINO_UNO_UART - CMSIS-Driver USART connecting to UART on Arduino pins D0..D1 ARDUINO_UNO_SPI - CMSIS-Driver SPI connecting to SPI on Arduino pins D10..D13 ARDUINO_UNO_I2C - CMSIS-Driver I2C connecting to I2C on Arduino pins D20..D21 ARDUINO_UNO_I2C-Alt - CMSIS-Driver I2C connecting to I2C on Arduino pins D18..D19 ARDUINO_UNO_D0 .. D21 - CMSIS-Driver GPIO connecting to Arduino pins D0..D21 . . CMSIS Driver and RTOS Interfaces CMSIS_ETH - CMSIS-Driver ETH connected to physical board connector CMSIS_MCI - CMSIS-Driver MCI connected to physical board connector CMSIS_USB_Device - CMSIS-Driver USB Device connected to physical board connector CMSIS_USB_Host - CMSIS-Driver USB Host connected to physical board connector CMSIS_VIO - CMSIS-Driver VIO interface for virtual I/O CMSIS-RTOS2 - CMSIS-RTOS2 compliant RTOS . . mikroBUS socket Interface MIKROBUS_AN - CMSIS-Driver GPIO connecting to mikroBUS AN MIKROBUS_INT - CMSIS-Driver GPIO connecting to mikroBUS INT MIKROBUS_PWM - CMSIS-Driver GPIO connecting to mikroBUS PWM MIKROBUS_I2C - CMSIS-Driver I2C connecting to mikroBUS I2C MIKROBUS_SPI - CMSIS-Driver SPI connecting to mikroBUS SPI MIKROBUS_UART - CMSIS-Driver USART connecting to mikroBUS UART . . I/O Retargeting STDERR - Standard Error output STDIN - Standard Input STDOUT - Standard Output . . Memory allocation Heap Heap Size Memory heap configuration ToDo: what features of CMSIS-RTOS2 are typically used by board layers? more information about Heap. How is it configured? Which existing Reference Applications are using it? FreeRTOS has its own heap management; is it really required? ARDUINO_UNO_UART Connects to a CMSIS-Driver USART Interface configured in asynchronous UART mode with no modem lines. CMSIS_target_header contains the driver instance number with this definition: #define ARDUINO_UNO_UART 3 // CMSIS-Driver USART instance number ARDUINO_UNO_I2C ARDUINO_UNO_I2C or ARDUINO_UNO_I2C-Alt connects to a CMSIS-Driver I2C Interface configured in controller mode. CMSIS_target_header contains the driver instance number with this definition: #define ARDUINO_UNO_I2C 0 // CMSIS-Driver I2C instance number ARDUINO_UNO_SPI Connects to a CMSIS-Driver SPI Interface configured in controller mode and CPOL/CPHA frame format (no TI or Microwire). The Target Select (SS) pin (typically on ARDUINO_UNO_D10) is not handled by CMSIS-Driver SPI interface; it is driven by the GPIO interface. CMSIS_target_header contains the driver instance number with this definition: #define ARDUINO_UNO_SPI 1 // CMSIS-Driver SPI instance number ARDUINO_UNO_Dx The ARDUINO_UNO_D0 .. ARDUINO_UNO_D21 connects to a CMSIS-Driver GPIO Interface . CMSIS_target_header contains the pin mapping to the physical driver. #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */ CMSIS_ETH Connects to a CMSIS-Driver Ethernet Interface that offers a physical Ethernet connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_ETH 0 // CMSIS-Driver Ethernet instance number CMSIS_MCI Connects to a CMSIS-Driver MCI Interface that offers a physical memory card connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_MCI 0 // CMSIS-Driver MCI instance number CMSIS_USB_Device Connects to a CMSIS-Driver USB Device Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBD 0 // CMSIS-Driver USB Device instance number CMSIS_USB_Host Connects to a CMSIS-Driver USB Host Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBH 0 // CMSIS-Driver USB Host instance number CMSIS_VIO Connects to a CMSIS-Driver VIO Interface , a virtual I/O interface that connects on physical boards to LEDs and switches. MIKROBUS_AN/_INT/_PWM The MIKROBUS_AN, MIKROBUS_INT and MIKROBUS_PWM connect to a CMSIS-Driver GPIO Interface . CMSIS_target_header contains the pin mapping to the physical driver. #define MIKROBUS_AN GPIO_PORTD(0U) #define MIKROBUS_INT GPIO_PORTD(1U) #define MIKROBUS_PWM GPIO_PORTD(2U) MIKROBUS_I2C Connects to a CMSIS-Driver I2C Interface configured in controller mode. CMSIS_target_header contains the driver instance number with this definition: #define MIKROBUS_I2C 0 // CMSIS-Driver I2C instance number MIKROBUS_SPI Connects to a CMSIS-Driver SPI Interface configured in controller mode and CPOL/CPHA frame format (no TI or Microwire). The Chip Select (CS) pin may be handled by CMSIS-Driver SPI interface or driven by the GPIO interface. CMSIS_target_header contains the driver instance number with this definition: #define MIKROBUS_SPI 0 // CMSIS-Driver SPI instance number MIKROBUS_UART Connects to a CMSIS-Driver USART Interface configured in asynchronous UART mode with no modem lines. CMSIS_target_header contains the driver instance number with this definition: #define MIKROBUS_UART 0 // CMSIS-Driver USART instance number STDIO The STDIN , STDOUT , and STDERR describe the I/O redirection via the CMSIS-Compiler software component. Typically, the redirect is to a UART dedicated to debugging. Arduino Shield The software layers Board and Shield are currently based on Arduino UNO connectors. To combine different boards and shields a consistent pin naming is required. The standardized mapping is shown in the diagram below. mikroBUS Header Header File Example Two header files contain I/O configuration settings for the application program: CMSIS_target_header defines the resources available by the evaluation board. CMSIS_shield_header extends this CMSIS_target_header with resources of a shield that is applied to an evaluation board. Refer to Header File Structure for more information. CMSIS_target_header #ifndef B_U585I_IOT02A_H_ #define B_U585I_IOT02A_H_ #include \"stm32u5xx_hal.h\" #include \"GPIO_STM32U5xx.h\" #include \"Driver_I2C.h\" #include \"Driver_SPI.h\" #include \"Driver_USART.h\" // B-U585I-IOT02A Arduino Connector Pin Definitions #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */ // CMSIS Driver instances on Arduino connector #define ARDUINO_UNO_I2C 1 #define ARDUINO_UNO_SPI 1 #define ARDUINO_UNO_UART 3 // CMSIS Driver instances of Board peripherals #define CMSIS_DRIVER_USBD 0 // instance of CMSIS-Driver USB Device // CMSIS Drivers extern ARM_DRIVER_I2C Driver_I2C1; extern ARM_DRIVER_SPI Driver_SPI1; extern ARM_DRIVER_USART Driver_USART1; extern ARM_DRIVER_USART Driver_USART3; #ifdef CMSIS_shield_header #include CMSIS_shield_header #endif #endif /* B_U585I_IOT02A_H_ */ CMSIS_shield_header #ifndef _FRDM_STBC_AGM01_SHIELD_H_ #define _FRDM_STBC_AGM01_SHIELD_H_ // FRDM-STBC-AGM01 Shield Reset #define RESET_GPIO ARDUINO_UNO_D17 #define SHIELD_MULTIB 0 #define SHIELD_NONE 1 #define SHIELD_AGM01 2 #define SHIELD_AGM02 3 #define SHIELD_AGMP03 4 #define SHIELD_AGM04 5 #define THIS_SHIELD SHIELD_AGM01 // Shield Setup (default configuration) extern int32_t shield_setup (void); #endif /* _FRDM_STBC_AGM01_SHIELD_H_ */","title":"Reference Applications"},{"location":"ReferenceApplications/#reference-applications","text":"This chapter explains how to work with Reference Applications that can run on several evaluation boards.","title":"Reference Applications"},{"location":"ReferenceApplications/#introduction","text":"The CMSIS-Pack format supports different types of project examples: Template Projects are stub projects that help getting started. Some software packs may contain device-specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These project examples show the usage of middleware components and require additional software layers with API drivers for the specific target hardware, typically an evaluation board. The following sections explain the usage, structure, and creation of Reference Applications that can target many different evaluation boards. Refer to Pack Creation s\u00bb Project Examples for information on how to publish project examples as part of software packs.","title":"Introduction"},{"location":"ReferenceApplications/#types-of-reference-applications","text":"Reference Applications may show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Such software uses application programming interfaces (APIs) to interface with hardware interfaces or other software components.","title":"Types of Reference Applications"},{"location":"ReferenceApplications/#mdk-middleware-reference-applications","text":"The MDK-Middleware provides software components for IPv4/IPv6 networking, USB Host/Device communication, and a variety of file systems for data storage. The MDK-Middleware software pack contains Reference Applications that show how to use these software components. These examples are hardware agnostic; adding a board layer that provides the required APIs allows running the example project on specific target hardware. The picture above shows how a USB HID example connects to a board-specific software layer. The Reference Application does not specify a target hardware. For execution on target hardware, a software layer is required that provides the hardware-specific APIs. These board-specific layers are provided in BSP packs, which allows the example to run on many different hardware targets. The Reference example uses connections: to list the consumed (required) APIs. The board layer in the BSP pack provides these connections: and may offer several additional connections: , making the layer suitable for a wide range of Reference Applications. As the Reference Application is not hardware-specific, it does not define a target type. Also, it does not add the board-specific software layer. It requires two steps to configure the *.csolution.yml file of such an example for an evaluation board. Refer to the Usage section for more information. Reference Application *.csolution.yml file solution: cdefault: compiler: AC6 : packs: # Step 1: Specify DFP and BSP for the device and board, for example with: # - pack: Keil::STM32U5xx_DFP # - pack: Keil::B-U585I-IOT02A_BSP target-types: # Step 1: Specify your board, for example with: # - type: STM32U585 # board: B-U585I-IOT02A # Step 2: Run `cbuild setup` and use cbuild-idx.yml to identify variables, for example: # variables: # - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml","title":"MDK-Middleware Reference Applications"},{"location":"ReferenceApplications/#sensor-reference-applications","text":"The overall concept of Reference Applications and the same board-specific software layers can be used for a wide range of software stacks. For example, a sensor SDK pack may provide Reference Applications that show the usage of a MEMS sensor. This MEMS sensor is additional hardware that could be provided by a widely supported Arduino UNO shield. The sensor SDK with the related Arduino shield can be structured to work with a wide range of evaluation boards that offer a compatible board-specific software layer. The overall structure of a sensor example project is shown in the picture below. It is composed of: The Reference Application with sensor-specific middleware that shows the usage of a MEMS sensor. Layer type: Board contains the hardware-specific setup of an evaluation board with a Cortex-M processor along with drivers, i.e. for SPI or I2C that connect to the pins of the Arduino shield. Layer type: Shield defines the pin routing of the Arduino UNO shield, which adds the MEMS sensor to the evaluation board. Note As the connections: for the MEMS sensor are specific to the sensor itself, the same Reference Application also works with an evaluation board that integrates the MEMS sensor (and, therefore, requires no Shield layer). In this case, the board-specific software layer adds the sensor-specific connections: .","title":"Sensor Reference Applications"},{"location":"ReferenceApplications/#targeting-custom-hardware","text":"A Reference Application may serve as a starting point for user applications that target custom hardware. It is required to provide: A software layer with a compatible set of APIs ( connections: ) consumed by the Reference Application . This software layer can be added along with the target type (in the *.csolution.yml file) that defines the custom hardware. Note It is not required to define connections: as this information is only used to identify compatible layers. A header file that replaces the CMSIS_target_header . Refer to Header File Structure for more information. Example *.csolution.yml file for custom hardware solution: cdefault: compiler: AC6 : target-types: - type: MyHardware device: STM32U585AIIx # custom hardware uses only a device definition variables: - Board-Layer: $SolutionDir()$/MyTarget/MyHardware.clayer.yml Example MyHardware.clayer.yml You may use a *.clayer.yml file for implementing the HAL drivers for the application and define the CMSIS_target_header as shown below: layer: : define: - CMSIS_target_header: \"\\\"MyHardware.h\\\"\"","title":"Targeting Custom Hardware"},{"location":"ReferenceApplications/#usage","text":"A Reference Application is an incomplete *.csolution.yml project file that requires additional intervention. The following steps explain how to compile the project:","title":"Usage"},{"location":"ReferenceApplications/#step-1-add-dfp-and-bsp","text":"In the *.csolution.yml file under the packs: node, add the DFP (for the device) and the BSP (for the board). Under target-types: , add your board. solution: cdefault: : packs: - pack: Keil::STM32U5xx_DFP - pack: Keil::B-U585I-IOT02A_BSP target-types: - type: MyBoard board: B-U585I-IOT02A # name of a target board","title":"Step 1: Add DFP and BSP"},{"location":"ReferenceApplications/#step-2-run-cbuild-setup","text":"Run cbuild setup with the *.csolution.yml file. This identifies compatible layers that are part of the software packs listed in the *.csolution.yml file with an output similar to: >cbuild setup xxx.csolution.yml error csolution: undefined variables in xxx.csolution.yml: - $Board-Layer$ To resolve undefined variables, copy the settings from cbuild-idx.yml to csolution.yml The related *.cbuild-idx.yml should contain information similar to this: build-idx: generated-by: csolution version 2.4.0 cdefault: cdefault.yml csolution: xxx.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml description: B-U585I-IOT02A Board setup for IoT path: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT file: Board.clayer.yml copy-to: .Board/U585 As a user, you have now two choices to work with the identified software layer:","title":"Step 2: Run cbuild setup"},{"location":"ReferenceApplications/#refer-layers-in-cmsis_pack_root","text":"This is useful when there is no plan to modify the software layer, for example, in the early phase of adoption. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT/Board.clayer.yml","title":"Refer layers in ${CMSIS_PACK_ROOT}"},{"location":"ReferenceApplications/#copy-layers-to-csolution-project","text":"This allows the modification of the layer, for example, adding or removing drivers or changing device settings. It requires these steps: Copy all files from path , i.e. ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/Layers/IoT to the local csolution project directory. If set, remove the R/O attribute from the copied files. Under variables: , add the path to the *.clayer.yml file. Use $SolutionDir() as base path to make the project portable. solution: cdefault: : target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A # name of a target board variables: - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml Note The copy step is executed for you by some IDEs during the Create New Project workflow.","title":"Copy layers to csolution project"},{"location":"ReferenceApplications/#structure","text":"The following section describes the overall file structure of Reference Applications .","title":"Structure"},{"location":"ReferenceApplications/#project-files","text":"A *.csolution.yml project file containing software layers for two different evaluation boards should look like the one shown below. This project contains three examples that show the different features of USB device middleware. The actual example project (HID, MSC, or CDC1) is selected using a context set ; the compiler is selected using the --toolchain option. To translate the completed Reference Applications use: cbuild USB_Device.csolution.yml --context-set --toolchain AC6 Example USB_Device.csolution.yml file for two boards with three projects solution: created-for: CMSIS-Toolbox@2.4.0 cdefault: target-types: - type: B-U585I-IOT02A board: B-U585I-IOT02A variables: - Board-Layer: $SolutionDir()$\\Board\\B-U585I-IOT02A\\Board.clayer.yml - type: LPC55S69-EVK # type name identical with board name? board: LPC55S69-EVK variables: - Board-Layer: $SolutionDir()$\\Board\\LPC55S69-EVK\\Board.clayer.yml build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: HID/HID.cproject.yml - project: MSC/MassStorage.cproject.yml - project: CDC1/VirtualCOM.cproject.yml","title":"Project Files"},{"location":"ReferenceApplications/#typical-directory-structure","text":"The table below shows the typical directory structure of the above example from the programmer's point of view. The software layer in the directory ./Board is copied from the BSP of the related board. Directory Content Content USB_Device.csolution.yml Overall CMSIS solution project file. ./HID/ HID example project from MDK-Middleware pack. ./MSC/ MSC example project from MDK-Middleware pack. ./CDC1/ CDC1 example project from MDK-Middleware pack. ./Board/B-U585I-IOT02A Board software layer from B-U585I-IOT02A BSP. ./Board/LPC55S69-EVK Board software layer from LPC55S69-EVK BSP.","title":"Typical Directory Structure"},{"location":"ReferenceApplications/#header-file-structure","text":"The interfaces between the software layers are defined in header files. Thus, is it possible to reuse the various software blocks with other build systems that are not CMSIS aware. The following diagram shows the overall header file structure. The Reference Application has no direct access to hardware. Therefore, it does not use the CMSIS_device_header provided by the CMSIS-Core that defines the registers and interrupt mapping. To access target hardware, these header files are used by the Reference Application : Standardized Driver API header files are used for communication with device peripherals. Header files of CMSIS-Drivers are provided by the CMSIS base software pack . The configuration of the driver interfaces is defined by the CMSIS_target_header . This header therefore specifies the available resources of the target hardware that can be used by the Reference Application . The Header File Example shows a typical structure of the CMSIS_target_header . When a shield is applied to an evaluation board, the CMSIS_shield_header extends the resource configuration of the CMSIS_target_header . Note The driver implementation of the hardware abstraction might use shim layer as shown on the right side of above diagram. For example, the driver implementation for STM32 devices uses the STM32 HAL.","title":"Header File Structure"},{"location":"ReferenceApplications/#application-program-start","text":"A Reference Application starts with the C function app_main as shown below. #include CMSIS_target_header // board resource definitions // reference application of a middleware component int app_main (void) { }; The application may use an RTOS kernel or run a simple while loop. Additional software components such as CMSIS-View , CMSIS-DSP , or MbedTLS are added directly to the Reference Application . In general, the connections: that are consumed should be minimized, allowing the example to be run on many different target boards.","title":"Application Program Start"},{"location":"ReferenceApplications/#board-layer","text":"The board layer provides system startup, board/device hardware initialization, and transfers control to the application. It also exposes various drivers and interfaces. Typical Features: System startup, including clock and memory configuration. Device/Board hardware initialization. Calls the application startup function. Drivers for board peripherals [optional]. Interfaces to LEDs and switches [optional]. STDIO re-targeting to debug interfaces [optional]. Shield setup and drivers for Arduino interfaces [optional]. Heap and Stack configuration [optional]. Files: CMSIS startup and system file for device initialization. main.c source module that implements the function main . Optional drivers and interfaces (CMSIS-Drivers, GPIO, STDIO). Files that relate to the device and/or board configuration (i.e. generated by MCUXpresso or STM32CubeMX) Linker script definition for boards that require specific memory configurations. The configuration parameters of the available APIs are defined in CMSIS_target_header . Generator Usage: The board-specific software layer is used in many different projects. When a board configuration is generated by tools, such as MCUXpresso or STM32CubeMX, for example, configure the generator output directory and import file using the generators: node in the *.clayer.yml file as shown below: layer: generators: options: - generator: CubeMX path: ./CubeMX name: Board","title":"Board Layer"},{"location":"ReferenceApplications/#shield-layer","text":"A shield layer adds support for additional hardware via plugin shields (i.e. Arduino Uno). Arduino shields consume connections with the prefix ARDUINO_UNO_ . In the future, other shields may be supported as well. Shields may feature various hardware modules such as WiFi chips or MEMS sensors. Frequently, the shield's software layer only defines a header file that redirects the Arduino-specific connect: to a chip-specific connect: , which is then used by application software. The shield's software layer is configured from the board software layer, which calls the following function: extern int32_t shield_setup (void);","title":"Shield Layer"},{"location":"ReferenceApplications/#connections","text":"Connections are only used to identify compatible software layers. Since there are no strict rules for the connect Name , it is possible to extend it with additional namespacing, i.e., prefixing with ST_ to denote ST-specific interfaces. There are also no strict rules on how the different software layers consume or provide the connect names. However, guidelines will be developed once reference applications mature. Currently, the following connect names are used. connect name Value Description . . Arduino Shield Interface ARDUINO_UNO_UART - CMSIS-Driver USART connecting to UART on Arduino pins D0..D1 ARDUINO_UNO_SPI - CMSIS-Driver SPI connecting to SPI on Arduino pins D10..D13 ARDUINO_UNO_I2C - CMSIS-Driver I2C connecting to I2C on Arduino pins D20..D21 ARDUINO_UNO_I2C-Alt - CMSIS-Driver I2C connecting to I2C on Arduino pins D18..D19 ARDUINO_UNO_D0 .. D21 - CMSIS-Driver GPIO connecting to Arduino pins D0..D21 . . CMSIS Driver and RTOS Interfaces CMSIS_ETH - CMSIS-Driver ETH connected to physical board connector CMSIS_MCI - CMSIS-Driver MCI connected to physical board connector CMSIS_USB_Device - CMSIS-Driver USB Device connected to physical board connector CMSIS_USB_Host - CMSIS-Driver USB Host connected to physical board connector CMSIS_VIO - CMSIS-Driver VIO interface for virtual I/O CMSIS-RTOS2 - CMSIS-RTOS2 compliant RTOS . . mikroBUS socket Interface MIKROBUS_AN - CMSIS-Driver GPIO connecting to mikroBUS AN MIKROBUS_INT - CMSIS-Driver GPIO connecting to mikroBUS INT MIKROBUS_PWM - CMSIS-Driver GPIO connecting to mikroBUS PWM MIKROBUS_I2C - CMSIS-Driver I2C connecting to mikroBUS I2C MIKROBUS_SPI - CMSIS-Driver SPI connecting to mikroBUS SPI MIKROBUS_UART - CMSIS-Driver USART connecting to mikroBUS UART . . I/O Retargeting STDERR - Standard Error output STDIN - Standard Input STDOUT - Standard Output . . Memory allocation Heap Heap Size Memory heap configuration ToDo: what features of CMSIS-RTOS2 are typically used by board layers? more information about Heap. How is it configured? Which existing Reference Applications are using it? FreeRTOS has its own heap management; is it really required?","title":"Connections"},{"location":"ReferenceApplications/#arduino_uno_uart","text":"Connects to a CMSIS-Driver USART Interface configured in asynchronous UART mode with no modem lines. CMSIS_target_header contains the driver instance number with this definition: #define ARDUINO_UNO_UART 3 // CMSIS-Driver USART instance number","title":"ARDUINO_UNO_UART"},{"location":"ReferenceApplications/#arduino_uno_i2c","text":"ARDUINO_UNO_I2C or ARDUINO_UNO_I2C-Alt connects to a CMSIS-Driver I2C Interface configured in controller mode. CMSIS_target_header contains the driver instance number with this definition: #define ARDUINO_UNO_I2C 0 // CMSIS-Driver I2C instance number","title":"ARDUINO_UNO_I2C"},{"location":"ReferenceApplications/#arduino_uno_spi","text":"Connects to a CMSIS-Driver SPI Interface configured in controller mode and CPOL/CPHA frame format (no TI or Microwire). The Target Select (SS) pin (typically on ARDUINO_UNO_D10) is not handled by CMSIS-Driver SPI interface; it is driven by the GPIO interface. CMSIS_target_header contains the driver instance number with this definition: #define ARDUINO_UNO_SPI 1 // CMSIS-Driver SPI instance number","title":"ARDUINO_UNO_SPI"},{"location":"ReferenceApplications/#arduino_uno_dx","text":"The ARDUINO_UNO_D0 .. ARDUINO_UNO_D21 connects to a CMSIS-Driver GPIO Interface . CMSIS_target_header contains the pin mapping to the physical driver. #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */","title":"ARDUINO_UNO_Dx"},{"location":"ReferenceApplications/#cmsis_eth","text":"Connects to a CMSIS-Driver Ethernet Interface that offers a physical Ethernet connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_ETH 0 // CMSIS-Driver Ethernet instance number","title":"CMSIS_ETH"},{"location":"ReferenceApplications/#cmsis_mci","text":"Connects to a CMSIS-Driver MCI Interface that offers a physical memory card connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_MCI 0 // CMSIS-Driver MCI instance number","title":"CMSIS_MCI"},{"location":"ReferenceApplications/#cmsis_usb_device","text":"Connects to a CMSIS-Driver USB Device Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBD 0 // CMSIS-Driver USB Device instance number","title":"CMSIS_USB_Device"},{"location":"ReferenceApplications/#cmsis_usb_host","text":"Connects to a CMSIS-Driver USB Host Interface that offers a physical USB connector on the evaluation board. CMSIS_target_header contains the pin mapping to the physical driver. #define CMSIS_DRIVER_USBH 0 // CMSIS-Driver USB Host instance number","title":"CMSIS_USB_Host"},{"location":"ReferenceApplications/#cmsis_vio","text":"Connects to a CMSIS-Driver VIO Interface , a virtual I/O interface that connects on physical boards to LEDs and switches.","title":"CMSIS_VIO"},{"location":"ReferenceApplications/#mikrobus_an_int_pwm","text":"The MIKROBUS_AN, MIKROBUS_INT and MIKROBUS_PWM connect to a CMSIS-Driver GPIO Interface . CMSIS_target_header contains the pin mapping to the physical driver. #define MIKROBUS_AN GPIO_PORTD(0U) #define MIKROBUS_INT GPIO_PORTD(1U) #define MIKROBUS_PWM GPIO_PORTD(2U)","title":"MIKROBUS_AN/_INT/_PWM"},{"location":"ReferenceApplications/#mikrobus_i2c","text":"Connects to a CMSIS-Driver I2C Interface configured in controller mode. CMSIS_target_header contains the driver instance number with this definition: #define MIKROBUS_I2C 0 // CMSIS-Driver I2C instance number","title":"MIKROBUS_I2C"},{"location":"ReferenceApplications/#mikrobus_spi","text":"Connects to a CMSIS-Driver SPI Interface configured in controller mode and CPOL/CPHA frame format (no TI or Microwire). The Chip Select (CS) pin may be handled by CMSIS-Driver SPI interface or driven by the GPIO interface. CMSIS_target_header contains the driver instance number with this definition: #define MIKROBUS_SPI 0 // CMSIS-Driver SPI instance number","title":"MIKROBUS_SPI"},{"location":"ReferenceApplications/#mikrobus_uart","text":"Connects to a CMSIS-Driver USART Interface configured in asynchronous UART mode with no modem lines. CMSIS_target_header contains the driver instance number with this definition: #define MIKROBUS_UART 0 // CMSIS-Driver USART instance number","title":"MIKROBUS_UART"},{"location":"ReferenceApplications/#stdio","text":"The STDIN , STDOUT , and STDERR describe the I/O redirection via the CMSIS-Compiler software component. Typically, the redirect is to a UART dedicated to debugging.","title":"STDIO"},{"location":"ReferenceApplications/#arduino-shield","text":"The software layers Board and Shield are currently based on Arduino UNO connectors. To combine different boards and shields a consistent pin naming is required. The standardized mapping is shown in the diagram below.","title":"Arduino Shield"},{"location":"ReferenceApplications/#mikrobus-header","text":"","title":"mikroBUS Header"},{"location":"ReferenceApplications/#header-file-example","text":"Two header files contain I/O configuration settings for the application program: CMSIS_target_header defines the resources available by the evaluation board. CMSIS_shield_header extends this CMSIS_target_header with resources of a shield that is applied to an evaluation board. Refer to Header File Structure for more information. CMSIS_target_header #ifndef B_U585I_IOT02A_H_ #define B_U585I_IOT02A_H_ #include \"stm32u5xx_hal.h\" #include \"GPIO_STM32U5xx.h\" #include \"Driver_I2C.h\" #include \"Driver_SPI.h\" #include \"Driver_USART.h\" // B-U585I-IOT02A Arduino Connector Pin Definitions #define ARDUINO_UNO_D0 GPIO_PORTD(9U) /* USART3: RX */ #define ARDUINO_UNO_D1 GPIO_PORTD(8U) /* USART3: TX */ #define ARDUINO_UNO_D2 GPIO_PORTD(15U) #define ARDUINO_UNO_D3 GPIO_PORTB(2U) #define ARDUINO_UNO_D4 GPIO_PORTE(7U) #define ARDUINO_UNO_D5 GPIO_PORTE(0U) #define ARDUINO_UNO_D6 GPIO_PORTB(6U) #define ARDUINO_UNO_D7 GPIO_PORTF(13U) #define ARDUINO_UNO_D8 GPIO_PORTC(1U) #define ARDUINO_UNO_D9 GPIO_PORTA(8U) #define ARDUINO_UNO_D10 GPIO_PORTE(12U) #define ARDUINO_UNO_D11 GPIO_PORTE(15U) /* SPI1: MOSI */ #define ARDUINO_UNO_D12 GPIO_PORTE(14U) /* SPI1: MISO */ #define ARDUINO_UNO_D13 GPIO_PORTE(13U) /* SPI1: SCK */ #define ARDUINO_UNO_D14 GPIO_PORTC(0U) #define ARDUINO_UNO_D15 GPIO_PORTC(2U) #define ARDUINO_UNO_D16 GPIO_PORTC(4U) #define ARDUINO_UNO_D17 GPIO_PORTC(5U) #define ARDUINO_UNO_D18 GPIO_PORTA(7U) #define ARDUINO_UNO_D19 GPIO_PORTB(0U) #define ARDUINO_UNO_D20 GPIO_PORTB(8U) /* I2C1: SDA */ #define ARDUINO_UNO_D21 GPIO_PORTB(9U) /* I2C1: SCL */ // CMSIS Driver instances on Arduino connector #define ARDUINO_UNO_I2C 1 #define ARDUINO_UNO_SPI 1 #define ARDUINO_UNO_UART 3 // CMSIS Driver instances of Board peripherals #define CMSIS_DRIVER_USBD 0 // instance of CMSIS-Driver USB Device // CMSIS Drivers extern ARM_DRIVER_I2C Driver_I2C1; extern ARM_DRIVER_SPI Driver_SPI1; extern ARM_DRIVER_USART Driver_USART1; extern ARM_DRIVER_USART Driver_USART3; #ifdef CMSIS_shield_header #include CMSIS_shield_header #endif #endif /* B_U585I_IOT02A_H_ */ CMSIS_shield_header #ifndef _FRDM_STBC_AGM01_SHIELD_H_ #define _FRDM_STBC_AGM01_SHIELD_H_ // FRDM-STBC-AGM01 Shield Reset #define RESET_GPIO ARDUINO_UNO_D17 #define SHIELD_MULTIB 0 #define SHIELD_NONE 1 #define SHIELD_AGM01 2 #define SHIELD_AGM02 3 #define SHIELD_AGMP03 4 #define SHIELD_AGM04 5 #define THIS_SHIELD SHIELD_AGM01 // Shield Setup (default configuration) extern int32_t shield_setup (void); #endif /* _FRDM_STBC_AGM01_SHIELD_H_ */","title":"Header File Example"},{"location":"Troubleshooting/","text":"Troubleshooting Missing Dependencies for Build Files added using the GNU assembler syntax .incbin or .include directives, or armasm syntax INCBIN , INCLUDE , or GET directives, are not included in the file dependency list. As such, the CMake/Ninja build system cannot trigger automatically a build when an file changes that is included with such directives. Using execute in the related cproject.yml file overcomes this issue. In this example the file image.bin is included using assembler syntax. The touch command changes the time stamp of the related assembler file which triggers a rebuild. executes: - execute: image_dep run: ${CMAKE_COMMAND} -E touch $output$ input: - image.bin output: - asm.s Tip Use the images: node to add the output of external builds. Common Linker Problems The following section explains how to fix common linker problems. Error: L6236E: No section matches selector - no section to be FIRST/LAST Some devices (for example, the NXP RT1064) use custom (non-CMSIS) assembly startup code. This is not compatible with the default linker script that assumes C Startup code with standard CMSIS definitions. This problem can be solved by: Using the linker script provided by the device vendor. Change the linker script source file ac6_linker_script.sct.src that is local in your project, for example, as shown below: ER_ROM0 __ROM0_BASE __ROM0_SIZE { *(.isr_vector, +First) *(InRoot$$Sections) *(+RO +XO) } Using RAM1 .. RAM3 Areas Currently, there is a problem with the default AC6 linker script template. It does not use, by default, the RAM1 .. RAM3 area. A potential solution is discussed under issue #1778 . The investigation is currently ongoing. Duplicate Heap definition in Assembler startup file When using memory allocation functions (i.e. malloc ), the application ends in a hard fault handler. This is typically caused by different methods of stack and heap definitions. The Arm Compiler offers three ways to configure stack and heap . Only one of the following methods should be used: Use a linker scatter file to define ARM_LIB_STACKHEAP , ARM_LIB_STACK , or ARM_LIB_HEAP regions. Use the symbols __initial_sp , __heap_base , and __heap_limit . Implement __user_setup_stackheap() or __user_initial_stackheap() . The C startup code recommended by CMSIS Version 6 uses the linker scatter file for stack and heap definition. The C startup code is generic and works across all toolchains that are supported by the CMSIS-Toolbox. However, some assembler startup files define stack and heap with other methods, for example, by using the symbols __initial_sp , __heap_base , and __heap_limit . There are two options to solve the problem. Remove the stack and heap definition in the assembler startup code. Disable in the Regions Header File the stack and heap definition by setting __STACK_SIZE and __HEAP_SIZE to 0 as shown below. This removes the definition in the linker scatter file. // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000000 #define __HEAP_SIZE 0x00000000 // </h> GNU loader issues with Arm Compiler 6 The GNU loader that is used in some GDB Server implementations has issues with *.axf files that are generated by the Arm Compiler 6. Specify DWARF5 Format With DWARF-4 format, the GNU loader may issue warnings such as: warning: (Internal error: pc 0x8000914 in read in CU, but not in symtab.) To solve this problem, change to DWARF-5 format. The format is typically specified in the cdefault.yml file. You may create a local copy of this file in the same directory as the *.csolution.yml file. default: misc: - for-compiler: AC6 C-CPP: : - -gdwarf-5 ASM: - -masm=auto - -gdwarf-5 Generate HEX file While AC6 generates valid ELF files, GDB may be incorrectly load the content. To bypass this problem, generate also an type: hex file using the output: node in the *.cproject.yml file and use this HEX file to load the content. Example: project: : : output: type: - elf - hex # create HEX file to bypass GDB loader problem with AC6 - map # create MAP file (optional) When a type: hex file is generated for AC6, the CMSIS-Toolbox configures this file in the *.cbuild-run.yml file with load: image and the type: elf file with load: symbols . This bypasses the GDB loader issue. Note The HEX file should be generated using the Arm Compiler 6 fromelf tool during the build process of the application. Using a HEX conversation tool for a different toolchain may generate unpredictable results. Layer Search Fails The cbuild setup command does not find compatible layers. >cbuild setup xxx.csolution.yml error csolution: undefined variables in xxx.csolution.yml: - $SDS-Layer$ The layer search of cbuild setup requires that the packs are defined in the xxx.csolution.yml file. Ensure that the packs that define compatible layers are part of the software packs list, for example: solution: # This is a CMSIS-Toolbox Reference Application that requires a compatible board layer # Refer to https://open-cmsis-pack.github.io/cmsis-toolbox/ReferenceApplications/ for more information packs: - pack: ARM::SDS # search SDS pack for layers","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Troubleshooting/#missing-dependencies-for-build","text":"Files added using the GNU assembler syntax .incbin or .include directives, or armasm syntax INCBIN , INCLUDE , or GET directives, are not included in the file dependency list. As such, the CMake/Ninja build system cannot trigger automatically a build when an file changes that is included with such directives. Using execute in the related cproject.yml file overcomes this issue. In this example the file image.bin is included using assembler syntax. The touch command changes the time stamp of the related assembler file which triggers a rebuild. executes: - execute: image_dep run: ${CMAKE_COMMAND} -E touch $output$ input: - image.bin output: - asm.s Tip Use the images: node to add the output of external builds.","title":"Missing Dependencies for Build"},{"location":"Troubleshooting/#common-linker-problems","text":"The following section explains how to fix common linker problems. Error: L6236E: No section matches selector - no section to be FIRST/LAST Some devices (for example, the NXP RT1064) use custom (non-CMSIS) assembly startup code. This is not compatible with the default linker script that assumes C Startup code with standard CMSIS definitions. This problem can be solved by: Using the linker script provided by the device vendor. Change the linker script source file ac6_linker_script.sct.src that is local in your project, for example, as shown below: ER_ROM0 __ROM0_BASE __ROM0_SIZE { *(.isr_vector, +First) *(InRoot$$Sections) *(+RO +XO) } Using RAM1 .. RAM3 Areas Currently, there is a problem with the default AC6 linker script template. It does not use, by default, the RAM1 .. RAM3 area. A potential solution is discussed under issue #1778 . The investigation is currently ongoing. Duplicate Heap definition in Assembler startup file When using memory allocation functions (i.e. malloc ), the application ends in a hard fault handler. This is typically caused by different methods of stack and heap definitions. The Arm Compiler offers three ways to configure stack and heap . Only one of the following methods should be used: Use a linker scatter file to define ARM_LIB_STACKHEAP , ARM_LIB_STACK , or ARM_LIB_HEAP regions. Use the symbols __initial_sp , __heap_base , and __heap_limit . Implement __user_setup_stackheap() or __user_initial_stackheap() . The C startup code recommended by CMSIS Version 6 uses the linker scatter file for stack and heap definition. The C startup code is generic and works across all toolchains that are supported by the CMSIS-Toolbox. However, some assembler startup files define stack and heap with other methods, for example, by using the symbols __initial_sp , __heap_base , and __heap_limit . There are two options to solve the problem. Remove the stack and heap definition in the assembler startup code. Disable in the Regions Header File the stack and heap definition by setting __STACK_SIZE and __HEAP_SIZE to 0 as shown below. This removes the definition in the linker scatter file. // <h> Stack / Heap Configuration // <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8> // <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8> #define __STACK_SIZE 0x00000000 #define __HEAP_SIZE 0x00000000 // </h>","title":"Common Linker Problems"},{"location":"Troubleshooting/#gnu-loader-issues-with-arm-compiler-6","text":"The GNU loader that is used in some GDB Server implementations has issues with *.axf files that are generated by the Arm Compiler 6.","title":"GNU loader issues with Arm Compiler 6"},{"location":"Troubleshooting/#specify-dwarf5-format","text":"With DWARF-4 format, the GNU loader may issue warnings such as: warning: (Internal error: pc 0x8000914 in read in CU, but not in symtab.) To solve this problem, change to DWARF-5 format. The format is typically specified in the cdefault.yml file. You may create a local copy of this file in the same directory as the *.csolution.yml file. default: misc: - for-compiler: AC6 C-CPP: : - -gdwarf-5 ASM: - -masm=auto - -gdwarf-5","title":"Specify DWARF5 Format"},{"location":"Troubleshooting/#generate-hex-file","text":"While AC6 generates valid ELF files, GDB may be incorrectly load the content. To bypass this problem, generate also an type: hex file using the output: node in the *.cproject.yml file and use this HEX file to load the content. Example: project: : : output: type: - elf - hex # create HEX file to bypass GDB loader problem with AC6 - map # create MAP file (optional) When a type: hex file is generated for AC6, the CMSIS-Toolbox configures this file in the *.cbuild-run.yml file with load: image and the type: elf file with load: symbols . This bypasses the GDB loader issue. Note The HEX file should be generated using the Arm Compiler 6 fromelf tool during the build process of the application. Using a HEX conversation tool for a different toolchain may generate unpredictable results.","title":"Generate HEX file"},{"location":"Troubleshooting/#layer-search-fails","text":"The cbuild setup command does not find compatible layers. >cbuild setup xxx.csolution.yml error csolution: undefined variables in xxx.csolution.yml: - $SDS-Layer$ The layer search of cbuild setup requires that the packs are defined in the xxx.csolution.yml file. Ensure that the packs that define compatible layers are part of the software packs list, for example: solution: # This is a CMSIS-Toolbox Reference Application that requires a compatible board layer # Refer to https://open-cmsis-pack.github.io/cmsis-toolbox/ReferenceApplications/ for more information packs: - pack: ARM::SDS # search SDS pack for layers","title":"Layer Search Fails"},{"location":"YML-CBuild-Format/","text":"Build Information Files The following chapter explains the output files generated by the csolution tool. Depending on options, the files *.cbuild-pack.yml and *.cbuild-set.yml are also used as input files. The build information files are used for: generate CMake input files via the cbuild2cmake tool. provide details for the graphical user interface in VS Code extension Arm CMSIS Solution . obtain a list of licenses used in a project. File Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.yml Build description of a single *.cproject.yml input file; contains all information for the build step for a specific context including references to the content used from software packs. *.cbuild-pack.yml Software packs recorded for all input files ( *.csolution.yml , cproject.yml , and .clayer.yml ); used as input file to ensure reproducible builds that use the same software packs and pack versions. *.cbuild-set.yml Context selection for the build process, enabled with option --context-set: . *.cbuild-run.yml Contains the information required to download and debug a csolution project to a target. !!! Note CMSIS-Toolbox 2.11 creates the *.cbuild.yml and *.cbuild-run.yml files in the out directory along with the related output files. Directory Structure The csolution based projects are portable across different host computers and use, therefore relative file references . All file references use relative paths to the base directory of the related *.yml file. Files that are within the file structure of the csolution base directory are also referenced using relative paths, i.e. ../layers/layer1/source-file1.c . Files that are located in the CMSIS-Pack root directory are prefixed with ${CMSIS_PACK_ROOT} . Note All file references to user source code should be relative paths. The prefixes ${CMSIS_PACK_ROOT} and ${CMSIS_COMPILER_ROOT} are used to refer to base directories of files that relate to software packs and compiler-specific files. These base directories can also be on different filesystem drives. Files outside of the directory structure of a csolution based application use absolute paths. If absolute paths are used, a warning is issued in the *.cbuild-idx.yml file. A typical directory structure of a csolution based application that uses common layers source files are shown below. \ud83d\udce6 # csolution base directory \u2523 myapp.csolution.yml \u2523 myapp.cbuild-idx.yml \u2523 myapp.cbuild-pack.yml \u2523 myapp.cbuild-set.yml \u2523 \ud83d\udcc2 project1 \u2503 \u2523 mypro1.cproject.yml # file references are relative to directory project1 \u2523 \ud83d\udcc2 project2 \u2503 \u2523 mypro2.cproject.yml # file references are relative to directory project \u2523 \ud83d\udcc2 layer \u2503 \u2523 mylayer.clayer.yml # file references are relative to directory layer \u2523 \ud83d\udcc2 out \u2503 \u2523 myapp+Target.cbuild-run.yml # file references are relative to directory out \u2523 \u2523 \ud83d\udcc2 mypro1\\Target\\Debug \u2523 \u2523 \u2523 mypro1.cbuild.Debug+Target.yml # file references are relative to directory out\\mypro1\\Target\\Debug \u2523 \u2523 \ud83d\udcc2 mypro2\\Target\\Debug \u2523 \u2523 \u2523 mypro2.cbuild.Debug+Target.yml # file references are relative to directory out\\mypro2\\Target\\Debug Lock Pack Versions A csolution project refers to packs in different files ( *.csolution.yml , *.cproject.yml or *.clayer.yml ). To ensure consistent pack usage during application development (for example when new target-types or build-types are introduced), the *.cbuild-pack.yml file records the exact pack versions. The required packs can be specified in csolution project files in the following ways: exactly, e.g. ARM::CMSIS@5.9.0 with range, e.g. ARM::CMSIS@>=5.8.0 without version, e.g. ARM::CMSIS with wildcards on the pack name, e.g. ARM::CMSI* without pack name, e.g. ARM The required packs are resolved to an exact pack version that is recorded in the *.cbuild-pack.yml file as shown below: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by-pack: - ARM - ARM::CMSI* - ARM::CMSIS - ARM::CMSIS@>=5.8.0 - ARM::CMSIS@5.9.0 If csolution project files are modified, the selected-by-pack information ensures that consistent pack versions are used. If a required pack is no longer used in present in the csolution project , the relevant entry resolved-pack: in the *.cbuild-pack.yml file is removed. The *.cbuild-pack.yml file is located in the same directory as the *.csolution.yml file and is used by the csolution for every command that uses a *.csolution.yml file. Examples are: csolution convert - uses and updates the *.cbuild-pack.yml file. csolution list ... - uses the *.cbuild-pack.yml file csolution run - uses the *.cbuild-pack.yml file. csolution update-rte - uses and updates the *.cbuild-pack.yml file. The operation of the csolution command is as follows: Load the csolution project files ( *.csolution.yml , *.cproject.yml or *.clayer.yml ). Initially there is no *.cbuild-pack.yml file. If it exists, the *.cbuild-pack.yml file is loaded. The packs are aligned with the resolved-pack: information of the *.cbuild-pack.yml file in these steps: PopulateContexts : Add resolved-pack: information to the solution data model . AddPackRequirements : Pack version ranges and pack wildcards are matched to fully qualified versions of the solution data model . Pack wildcards are expanded to fully qualified packs using cbuild-pack.yml. Pack wildcards are kept for further expansion in the solution data model . Execute the csolution command, for example convert , list , run , or update-rte . Update the *.cbuild-pack.yml file (only if the content changes): GenerateCbuildPack : Generate the resolved-pack: list of packs required by all contexts . The original pack: specification is stored under selected-by-pack: . With the subsequent csolution command, the information of the *.cbuild-pack.yml file is used to load the appropriate fully qualified pack versions, matching previously used packs. File Format The following sections describe the format of the build information files . Many nodes are identical with the CSolution Project Format , but optional information is fully expanded. The nodes that are different are explained below under: Nodes for Project Management Nodes for File Management Nodes for License Information *.cbuild-idx.yml The <solution-name>.cbuild-idx.yml file is generated for the csolution project and refers all contexts that are generated. It is structured as outlined below. build-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. description: Brief description text copied from the *.csolution.yml input file used to generate this application. cdefault: Relative path and name of the *.cdefault.yml input file used to generate this application. csolution: Relative path and name of the *.csolution.yml input file used to generate this application. configurations: For reference applications with undefined layers: list of potential project configurations for a reference application with undefined layers cprojects: List of *.cproject.yml and *.clayer.yml input files used to generate this application. cbuilds: List of *.cbuild.yml output files that are generated by *.cproject.yml files for this application. select-compiler: For projects with unspecified compiler: list of available compilers for selection Example: build-idx: generated-by: csolution version 2.3.0 description: USB application examples sharing board layers. cdefault: cdefault.yml csolution: USB.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml cprojects: - cproject: Device/HID/HID.cproject.yml clayers: - clayer: $Board-Layer$ - cproject: Device/MassStorage/MassStorage.cproject.yml clayers: - clayer: $Board-Layer$ cbuilds: - cbuild: out/HID/B-U585I-IOT02A/Debug/HID.Debug+B-U585I-IOT02A.cbuild.yml project: HID configuration: .Debug+B-U585I-IOT02A - cbuild: out/MassStorage/B-U585I-IOT02A/Release/MassStorage.Release+B-U585I-IOT02A.cbuild.yml project: MassStorage configuration: .Release+B-U585I-IOT02A - cbuild: out/hello_world/B-U585I-IOT02A/Release/hello_world.Release+B-U585I-IOT02A.cbuild.yml west: true project: hello_world configuration: .Release+B-U585I-IOT02A errors: true # indicates error packs-missing: # lists missing packs - pack: ARM::CMSIS-RTX # with unspecified version - pack: ARM::CMSIS@6.0.0 # with specified version *.cbuild.yml The <project-name>.<build-type>+<target-type>.cbuild.yml file contains all information for one context . It is structured as outlined below. build: Content generated-by: Reference to csolution tool along with version information used to generate this application. context: Project context of this build description. compiler: Compiler toolchain used for code generation. board: Board name used for this context. board-pack: BSP that is defining the Board name used for this context. board-books: List board documentation as defined in the PDSC element <board> . device: Device name with processor core selection used in this project context. device-pack: DFP that is defining the Device name with processor core selection used in this project context. device-books: List device documentation as defined in the PDSC element <device> . processor: List of processor attributes used in this project context. packs: List of software packs along with path information used to generate this project context. optimize: Generic optimize level for code generation. link-time-optimize: Enable optimization at linker level . debug: Global control the generation of debug information. warnings: Global control warning level for compiler diagnostics. misc: Global control of miscellaneous literal tool-specific controls. define: List of global define symbol settings. add-path: List of global include path settings. output-type: Select the output type (exe or lib) for this project context. output-dirs: Specifies the directories used to generate the output files. linker: Specifies the linker script processing used to generate the output files. components: List of software components used. apis: List of API interfaces used. groups: List of source file groups along with source files. constructed-files: List of files that are generated by RTE management of the csolution tool. licenses: List of licenses used by the various software components of this project context. Example: build: context: HelloWorld_cm0plus.Debug+FRDM-K32L3A6 compiler: AC6 device: K32L3A60VPJ1A:cm0plus processor: fpu: off endian: little trustzone: non-secure packs: - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 - pack: NXP::K32L3A60_DFP@15.0.0 path: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 optimize: none debug: on misc: C: - -std=c99 - -fno-builtin CPP: - -fno-builtin Link: - --diag_suppress 6314 - --entry=Reset_Handler define: - CPU_K32L3A60VPJ1A_cm0plus - MCMGR_HANDLE_EXCEPTIONS=1 : - _RTE_ add-path: - ../middleware/multicore/mcmgr/src - RTE/Board_Support/K32L3A60VPJ1A_cm0plus - RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6 - ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0/CMSIS/Core/Include - ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 : output-type: exe output-dirs: gendir: generated intdir: ../tmp/HelloWorld_cm0plus/FRDM-K32L3A6/Debug outdir: ../out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug rtedir: RTE components: - component: ARM::CMSIS:CORE@5.6.0 condition: ARMv6_7_8-M Device from-pack: ARM::CMSIS@5.9.0 selected-by: ARM::CMSIS:CORE - component: NXP::Device:CMSIS:K32L3A60_system@1.0.0 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:CMSIS:K32L3A60_system files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/system_K32L3A60_cm0plus.c category: sourceC - component: NXP::Device:SDK Drivers:clock@2.2.1 condition: device.K32L3A60_AND_driver.common from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:clock files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_clock.c category: sourceC - component: NXP::Device:SDK Drivers:common@2.3.2 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS_AND_driver.clock from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:common files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common.c category: sourceC - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common_arm.c category: sourceC : groups: - group: Application files: - file: ./hello_world_core1.c category: sourceC - file: ./RTE/Device/K32L3A60VPJ1A_cm0plus/K32L3A60xxx_cm0plus_flash.scf category: linkerScript - group: Middleware files: - file: ../middleware/multicore/mcmgr/src/mcmgr.c category: sourceC : constructed-files: - file: RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6/RTE_Components.h category: header *.cbuild-pack.yml The <solution-name>.cbuild-pack.yml file contains the pack information for the csolution project . It is structured as outlined below. cbuild-pack: Content resolved-packs: List of packs used to create the project contexts. resolved-packs: Content - resolved-pack: pack name used. selected-by-pack: List of components included from the pack. Example: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by: - ARM::CMSIS - resolved-pack: ARM::V2M_MPS3_SSE_300_BSP@1.2.0 selected-by: - ARM::V2M_MPS3_SSE_300_BSP@1.2.0 - resolved-pack: Keil::ARM_Compiler@1.7.2 selected-by: - Keil::ARM_Compiler *.cbuild-set.yml The <solution-name>.cbuild-set.yml file selects the context set for the csolution project . The structure is outlined below. cbuild-set: Content generated-by: Reference to tool along with version information that generated this file. contexts: List of context names for the context-set: option. Example: cbuild-set: generated-by: csolution version 2.2.0 contexts: - context: CM33_s.Release+AVH - context: CM33_ns.Debug+AVH Nodes for Project Management configurations: The configurations: node lists possible configurations for reference applications that have undefined variable settings. configurations: Content - target-type: Name of target-type for which configurations are listed. target-configurations: List of possible configurations for the target-type. - configuration: Possible configuration for the reference application. - variables: List of variable names with configuration information. <layer-name>: Layer name with a value that is the path to the clayer.yml file. description: Brief description text taken from *.clayer.yml . settings: Usage instructions for this layer. - set: Value of set and info taken from connect: in *.clayer.yml . path: Path to the directory that contains the layer (from *.PDSC file). file: Name of the *.clayer.yml file (optional with a relative path to the directory specified with path) (from *.PDSC file). copy-to: Proposed directory for the layer in the csolution project (from *.PDSC file). Example: configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml description: \"Configuration including FXLS8962 sensor\" - target-type: MyBoard - configuration: - variables: - Board-Layer: ./layer/board/frdmk22f/frdmk22f.clayer.yml description: \"Configuration: Ethernet, UART, and WiFi\" settings: - set: set1.select1 (connect A - set 1 select 1) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f - Shield-Layer: ./layer/shield/agmp03/agmp03.clayer.yml description: \"Shield with FXLS8962 and FXAS21002\" settings: - set: Bus.SPI (FXLS8962 SPI Bus - Jumper configuration: I2C/SPI=SPI) - set: Bus.SPI (FXAS21002 SPI Bus - Jumper configuration: I2C/SPI=SPI) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f cprojects: The cprojects: node lists all *.cproject.yml input files along with *.clayer.yml files that are used to compose the application. cprojects: Content - cproject: Relative path and name of a *.cproject.yml input file. clayers: List of *.clayer.yml input files used by this *.cproject.yml file. Example: cprojects: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml clayers: - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/FreeRTOS+TCP/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/WiFi/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/VSocket/Socket.clayer.yml : cbuilds: The cbuilds: node lists all project context configurations that are generated with this build. cbuilds: Content - cbuild: Build description file of a single context for a *.cproject.yml input file. project: Project name. configuration: Context configuration for this build description file. errors: Error indication. packs-missing: List of missing packs. packs-unused: List of unused packs. messages: List of errors: , warnings: , or info: messages. Example: cbuilds: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml project: Demo configuration: .Debug+AVH errors: true messages: errors: - no compatible software layer found. Review the required connections of the project info: - test.cbuild-set.yml - file is already up-to-date select-compiler: If no compiler is specified in the csolution project , the cbuild setup command lists the available compilers based on the compiler registration and select-compiler: node in the file *.csolution.yml or cdefault.yml . select-compiler: Content - compiler: Name (optionally with version) of the compiler toolchain; copied from the select-compiler: node in the csolution project . packs: The packs: node is the start of a pack list that is used for the project context. packs: Content - pack: Explicit pack specification with exact version information used. path: Path name that stores the software pack (see note). Note Packs that are located in the CMSIS-Pack root directory are prefixed with %CMSIS_PACK_ROOT% . Example: packs: - pack: ARM::CMSIS-FreeRTOS@10.4.6 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS-FreeRTOS/10.4.6 - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 : - pack: MDK-Packs::IoT_Socket@1.3.1 path: ../IoT_Socket generators: The generators: node contains information for calling a generator. generators: Content - generator: Section for a specific generator. path: Path name for storing the files generated. gdpsc: File name of the *.GDPSC file that stores the information in path: . command: Section for invoking the generator on different Host operating systems. Example: generators: - generator: STM32CubeMX path: RTE/Device gpdsc: RTE/Device/STM32L475VGTx/FrameworkCubeMX.gpdsc command: win: file: ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1/MDK/CubeMX/STM32CubeMxLauncher.exe arguments: - STM32L475VGTx - ../../Release+STM32L4.cprj - ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1 generator: generator: Content - id: Generator identifier used for this component path: File name and path to the *.cgen.yml file that is generated. Nodes for File Management Keyword Description groups: Start of a list that adds source groups and files. components: Start of a list that adds software components. linker: linker: Content - regions: Path and file name of regions_<device_or_board>.h , used to generate a Linker Script via pre-processor. - script: Path and file name of the pre-processed Linker Script template. - define: Define symbol settings for the linker script file preprocessor. groups: groups: Content - group: Name of the group. optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. groups: Start a nested list of groups. files: List of files that belong to a group files: of a group files: Content - file: Name of the file. category: File category according Open-CMSIS-Pack specification optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. apis: apis: Content - api: Name of the API. condition: Reference to the condition ID of the software pack that triggered the inclusion of this API. from-pack: Pack that defines this API. implemented-by: Refers to the software componeent that implements the API. files: List of files that belong to this API. components: components: Content - component: Name of the software component. condition: Reference to the condition ID of the software pack that triggered the inclusion of this component. from-pack: Pack that defines this component. selected-by: The original component name used in cproject/clayer.YML . optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. instances: Number of component instances configured. maxInstances: Maximum number component instances that can be configured. generator: Generator information for components that are configurable via a generator. implements: Refers to the API that the component is based on. files: List of files that belong to this component. files: of a component files: Content - file: Name and path to the file. category: File category according to Open-CMSIS-Pack specification attr: File category according to Open-CMSIS-Pack specification; api refers to header files that define the api of a component. condition: Reference to the condition ID of the software pack that triggered the inclusion of this file. select: Selection text for user code template files and api header files. version: For files that belong to components the version specified in the PDSC file. base: Unmodified configuration file (base file from the software pack ) that is currently in use. update: New configuration file from an updated software pack . status: Action for configuration file update: suggested, recommended, required. constructed-files: A list of files that are generated by the RTE management of the csolution tool. constructed-files: Content - file: Name and path to the file. category: File category according Open-CMSIS-Pack specification. Nodes for License Information The *.cbuild.<build-type>+<target-type>.yml files contain license information about each software component that is included in software packs. licenses: Each different license that is used in a project context has a separate section. licenses: Content - license: License identifier or short description. lisense-agreement: File category according Open-CMSIS-Pack specification packs: List of software packs used to generate this project context. components: List of software components used to generate this project context. Example: licenses: - license: <proprietary> END USER LICENSE AGREEMENT FOR ARM SOFTWARE DEVELOPMENT TOOLS license-agreement: ${CMSIS_PACK_ROOT}/Keil/MDK-Middleware/8.0.0/license_terms/license_agreement.txt packs: - pack: Keil::MDK-Middleware@8.0.0 components: - component: Keil::USB&MDK:CORE@8.0.0 - component: Keil::USB&MDK:Device:HID@8.0.0 - component: Keil::USB&MDK:Device@8.0.0 - license: Apache-2.0 packs: - pack: ARM::CMSIS-Compiler@2.1.0 - pack: ARM::CMSIS-Driver_STM32@1.0.0 - pack: ARM::CMSIS-RTX@5.9.0 : components: - component: CMSIS Driver:GPIO(API) - component: CMSIS Driver:I2C(API) - component: CMSIS Driver:SPI(API) : - component: ARM::CMSIS-Compiler:CORE@1.1.0 - component: ARM::CMSIS-Compiler:STDERR:Custom@1.1.0 - component: ARM::CMSIS-Compiler:STDIN:Custom@1.1.0 : west: For each west build context a node west: is created in *.cbuild.yml west: Content app-path: Required Path to the application source directory. project-id: Required Project identifier board: Required Board name used for west build invocation. device: Optional Specify the processor core for execution of the generated image (used in *.cbuild-run.yml ). west-defs: Optional Defines in CMake format. The west-defs: from build and target-type are added. west-opt: Optional Options for the west tool (default: empty). Example: west: project-id: hello_world app-path: ../../../../hello_world board: stm32h7b3i_dk west-defs: - CONFIG_BUILD_OUTPUT_HEX=y Generator Information Files The csolution run command generates the following build information files in the intdir: of the related context . These files are the input to a generator and provide information about the csolution project to the generator. The files are generated in the tmp directory of the project and contain absolute paths. File Description *.cbuild-gen-idx.yml Index file of all *.cbuild-gen.yml build descriptions; contains also overall information for the application. *.cbuild-gen.yml Build description of a single *.cproject.yml input file. The format is identical with the *.cbuild.yml file. File Structure of *.cbuild-gen-idx.yml build-gen-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. generators: List of generators that are called with the run command. generators: Content - id: generator identifier specified with the option --generator in the csolution run command. output: Specifies the directory for generated files. board: Board name used for the generator. device: Device name used for the generator. project-type: Describes the project type \"single-core\", \"multi-core\", \"trustzone\". cbuild-gens: List of *.cbuild-gen.yml files with options that are generated for the generator run. cbuild-gens: Content - cbuild-gen: Build information file with name <context>.cbuild-gen.yml ; structure identical with *.cbuild.yml . project: Project name (used as a name for *.cgen.yml when name: is not specified). configuration: Specifies .build-type+target-type of this context. name: Explicit name for the *.cgen.yml generator import file specified by generator options . map: Mapping to a generator-specific run-time context name specified by generator options . Example: build-gen-idx: generated-by: csolution version 2.3.0 generators: - id: CubeMX output: C:/w/csolution-examples/CubeMX/STM32CubeMX/MyBoard # output directory device: STM32U585AIIx board: B-U585I-IOT02A project-type: single-core cbuild-gens: - cbuild-gen: C:/w/csolution-examples/CubeMX/tmp/CubeMX/MyBoard/Debug/CubeMX.Debug+MyBoard.cbuild-gen.yml project: CubeMX # user selected name of the project configuration: .Debug+MyBoard name: BoardLayer # create BoardLayer.cgen.yml in output directory (new in CMSIS-Toolbox 2.4.0) map: Boot # map to STM32CubeMX run-time context (new in CMSIS-Toolbox 2.4.0) Generator Import File The *.cgen.yml file lists the generated csolution project part and starts with the node generator-import: . It is defined similarly to a Software Layer additional parameters, files, and components that are included in the project. File Structure of *.cgen.yml generator-import: Content generated-by: Tool name that generated this file for-device: Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Board information, used for consistency check (board selection is in *.csolution.yml ). packs: Defines packs that are required for this layer. define: Define symbol settings for code generation. undefine: Remove define symbol settings for code generation. add-path: Additional include file paths. del-path: Remove specific include file paths. groups: List of source file groups along with source files. components: List of software components used. Run and Debug Management The CMSIS-Toolbox build system manages software packs that contain information about device, board, and software components. It controls the build output (typically ELF/DWARF files), and has provisions for HEX, BIN and post-processing. The target-set: node configures the application images and the debugger for a target-type . The software packs contain information that is the basis for debug and run settings: Flash algorithms of device memory (in DFP) and board memory (in BSP). On-board debug adapter (a default programming/debug channel) including features. Available memory of device and board. Device parameters such as processor core(s) and clock speed. Debug Access Sequences and System Description Files that support more complex Cortex-A/R/M configurations. Debug Configuration files ( *.dbgconf ) that configure device properties such as trace pins. CMSIS-SVD System View Description (SVD) files for viewing device peripherals. CMSIS-View Software Component Viewer Description (SCVD) files for analysis of software components (RTOS, Middleware). The user may add the following information in the *.csolution.yml file: Additional memory with flash algorithms for external memory in custom hardware using the memory: node. Additional images that should be programmed or loaded using the images: node. Debugger configuration provided by packs can be adjusted using the debugger: node. Note The information may be defined at various places. The *.csolution.yml file overrules the information from the BSP. The BSP overrules the information from the DFP. The file *.cbuild-run.yml contains for a single target-type of a csolution project the relevant information for run and debug. The information is collected by the CMSIS-Toolbox and the file name has the format <solution-name>+<target-type>.cbuild-run.yml file. It is used by programmers and debuggers in command line or IDE workflows. The information is portable, i.e. from a cloud-hosted CI system to a desktop test system. The <solution-name>+<target-type>.cbuild-run.yml file represents a single target-type of a csolution project . Example: cbuild-run: generated-by: csolution version 2.7.0 solution: CubeMX.csolution.yml target-type: MyBoard_ROM compiler: AC6 device: STMicroelectronics::STM32U585AIIx device-pack: Keil::STM32U5xx_DFP@3.0.0 board: STMicroelectronics::B-U585I-IOT02A:Rev.C board-pack: Keil::B-U585I-IOT02A_BSP@2.0.0 programming: - algorithm: ${CMSIS_PACK_ROOT}/Keil/STM32U5xx_DFP/3.0.0/CMSIS/Flash/STM32U5xx_2M_0800.FLM start: 0x08000000 size: 0x00200000 ram-start: 0x20000000 ram-size: 0x00008000 - algorithm: ${CMSIS_PACK_ROOT}/Keil/STM32U5xx_DFP/3.0.0/CMSIS/Flash/STM32U5xx_2M_0C00.FLM : system-descriptions: - file: ${CMSIS_PACK_ROOT}/Keil/STM32U5xx_DFP/3.0.0/CMSIS/SVD/STM32U585.svd type: svd output: - file: out/CubeMX/MyBoard_ROM/Debug/CubeMX.axf type: elf system-resources: memory: : debugger: - name: pyOCD@CMSIS-DAP : debug-vars: : debug-sequences: : debug-topology: : File Structure of *.cbuild-run.yml The following describes the overall structure of the *.cbuild-run.yml file. While the content of this file is generated using the cbuild command, it is also posssible to manually generate this file or modify content. cbuild-run: Content generated-by: Optional Tool name that generated this file. solution: Optional Name of the *.csolution.yml file. target-type: Optional Name of the target-type that was selected. target-set: Optional Name of the target-set that was selected (format <target-type>[@<set>] ). compiler: Optional Compiler toolchain used for code generation. board: Optional Board name used for this target. board-pack: Optional BSP that is defining the Board name used for this target. device: Optional Device name used in this target. device-pack: Optional DFP that is defining the Device used in this target. output: Required List of the image (ELF, HEX, BIN) files generated. system-resources: Optional List of the system resources available in target. system-descriptions: Optional List of description files for peripherals and software components. debugger: Required Configuration information for the debug connection. debug-sequences: Optional Tool actions for debugging, tracing, or programming. programming: Optional Algorithms for flash download. debug-topology: Optional Properties of the system hardware for debug functionality. output: This node contains information about the images that should be loaded. The images that are generated by the csolution project are typically configured using a target-set . The output: node includes also image files that are generated with a West Build specification. The output: node also contains other required files that are added with images: in the *.csolution.yml file. output: Content - file: Required Specifies the file name. type: Required Specifies the file type. info: Optional Brief description of the file. load: Required Load mode of the image file for programmers and debug tools. load-offset: Optional Offset applied in *.csolution.yml when loading the image file. pname: Optional Image belongs to processor in a multi-core system. load: mode For image: files that are added using the images: node of the *.csolution.yml file but have no load: mode specified, the CMSIS-Toolbox adds an load: mode depending on the file type. Files with type: elf get load: image+symbols . Files with type: lib get load: none . All other file types get load: image . For files that are the output of a cproject.yml project, the output: node lists all files that are generated. The CMSIS-Toolbox adds an load: mode depending on the compiler used and the file types that are generated to indicate how these files should be used by programmers and debug tools. For compiler: AC6 : When only a file with type: elf is generated, the file gets load: image+symbols . When a file with type: elf and a file with type: hex is generated, the type: elf file gets load: symbols and the type: hex file gets load: image . This allows to bypass GNU loader issues with Arm Compiler 6 . All other file types get load: none . For any other compiler: Files with type: elf get load: image+symbols . All other file types get load: none . Note info: generate by <context> indicates that an image is generated by a context of the csolution project . system-resources: The system-resources: node lists the resources of a target system. It includes memory from the DFP, BSP, and memory: definitions from the csolution.yml file. system-resources: Content memory: Optional Identifies the section for memory. memory: Content - name: Required Name of the memory region (when PDSC contains id, it uses the id as name). access: Required Access attribute string for the memory (see table below). start: Required Base address of the memory. size: Required Size of the memory. pname: Optional Only accessible by a specific processor. alias: Optional Name of identical memory exposed at different address. from-pack: Optional Pack that defines this memory. The table lists the letters and their meaning for use in the access attribute string. access: Description r Readable w Writable x eXecutable p Peripheral area. Details described in SVD file. s Secure attribute n Non-secure attribute c non-secure Callable attribute Example: system-resources: memory: - name: ITCM_Flash access: rx start: 0x00200000 size: 0x00100000 from-pack: Keil::STM32U5xx_DFP@3.0.0 - name: Ext-Flash access: rx start: 0x40000000 size: 0x200000 system-descriptions: List of the description files for peripherals and software components used in this project target. system-descriptions: Value Use Content - file: string Required Specifies the file name including the path. type: string Required Specifies the file type (see table below). info: string Optional Brief description of the file. pname: string Optional File is used only for a specific processor; default is for all processors. type: Description svd System View Description ( *.svd ) file specified in the DFP . scvd Software Component Viewer Description ( *.scvd ) file for CMSIS-View . debugger: This node contains connection information for a debugger with inital settings coming from the board support pack (BSP) or device family pack (DFP). debugger: Content name: Required Identifies the debug configuration. info: Optional Brief description from target-set. protocol: Optional Selected debug protocol (jtag or swd). clock: Optional Selected debug clock speed in Hz. dbgconf: Optional Debugger configuration file (pinout, trace). start-pname: Optional Debugger connects at start to this processor. gdbserver: Optional Information for GDB server option of debugger. terminal: Future Terminal port of the debugger. trace: Future Trace port of the debugger. *: Optional Other debugger specific options specified under target-set . !!! Note: - protocol: and clock: are required by pyOCD but optional for other debug adapters. The file ./etc/debug-adatpers.yml allows to specify default values for required options. - start-pname: is mandatory for multi-processor targets. If start-pname: is not configured using the debugger: node in the *.csolution.yml file, the pname: of the first *.cproject.yml file is used. The information for the debugger: node may be configured using the debugger: node in the *.csolution.yml file. If not present the values from BSP are used; if not present DFP values. The values in the *.csolution.yml file overwrites values from BSP or DFP as shown in the table below. *.cbuild-run.yml *.csolution.yml BSP DFP debugger: debugger: <boards><board><debugProbe ... <device><debugconfig ... protocol: protocol: debugLink default clock: clock: debugClock clock If no input ( *.csolution.yml , BSP or DFP) provides debugger option values, the CMSIS-Toolbox uses the values under defaults: from the file .\\ect\\debug-adapters.yml . Example: debugger: name: CMSIS-DAP info: On-Board debugger of MCB4300 protocol: jtag clock: 10000000 dbgconf: /.cmsis/MySolution+lpc4300.dbgconf gdbserver: These are options for the pyOCD GDB server configuration (could be optionally used by other debuggers as well). Note The gdbserver: node is only generated when the file .\\ect\\debug-adapters.yml contains gdbserver: for the selected debug adatper. gdbserver: Content - port: Required Port number of processor pname: Optional Processor name of the processor (only required for multi-core systems) punit: Future Identifies the procssor core in a SMP system. Example: debugger: name: CMSIS-DAP protocol: swd clock: 10000000 dbgconf: /.cmsis/MySolution+MCXN9XX.dbgconf gdbserver: - port: 3333 pname: cm33_core1 - port: 3334 pname: cm33_core0 debug-vars: This node contains the default value from the DFP for the variables used in debug-sequences: . This initial values are overwritten by explicit settings in the *.dbgconf file that is provided in the debugger: node. debug-vars: Content vars: Optional Initial values for variables used in debug-sequences: . Example: debug-vars: vars: | // Default values for variables in debug sequences. Are configured with a *.dbgconf file in the user project __var SWO_Pin = 0; // Serial Wire Output pin: 0 = PIO0_10, 1 = PIO0_8 __var Dbg_CR = 0x00000000; // DBG_CR __var BootTime = 10000; // 10 milliseconds debug-sequences: This node contains the debug sequences from the DFP for the target. Debug sequences define the activities of development tools to connect to a device using the debug channel for debugging, tracing, or flash programming. The sequence name is also used to overwrite a default sequence. A sequence that contains no blocks disables the default sequence. debug-sequences: Content - name: Required Name of the sequence. info: Optional Descriptive text to display for example for error diagnostics. blocks: Optional A list of command blocks in order of execution. pname: Optional Executes sequence only for a specific processor; default is for all processors. blocks: Content - info: Optional Descriptive text to display for example for error diagnostics. blocks: Optional A list of command blocks in the order of execution. execute: Optional Commands for execution. atomic: Optional Atomic execution of commands; cannot be used with blocks: . if: Optional Only executed when expression is true. while: Optional Executed in loop until while expression is true. timeout: Optional Timeout value (integer) in milliseconds for while loop. Note When atomic: is applied, sequences execute with no interrupts as fast as possible using CMSIS-DAP Atomic Commands . It has therefore restrictions and cannot be combined with blocks: . A blocks: node can either contain execute: or blocks: but not both. Example: DebugPortSetup debug-sequences: - name: DebugPortSetup blocks: - execute: | __var isSWJ = ((__protocol &amp; 0x00010000) != 0); __var hasDormant = __protocol &amp; 0x00020000; __var protType = __protocol &amp; 0x0000FFFF; - if: protType == 1 blocks: - if: isSWJ blocks: - if: hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Select Dormant State (from SWD) DAP_SWJ_Sequence(16, 0xE3BC); // At least 8 cycles SWDIO/TMS HIGH DAP_SWJ_Sequence(8, 0xFF); // Alert Sequence Bits 0.. 63 DAP_SWJ_Sequence(64, 0x86852D956209F392); // Alert Sequence Bits 64..127 DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9); // 4 cycles SWDIO/TMS LOW + 8-Bit JTAG Activation Code (0x0A) DAP_SWJ_Sequence(12, 0x0A0); // Ensure JTAG interface is reset DAP_SWJ_Sequence(6, 0x3F); - if: !hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C) // Change if SWJ-DP uses deprecated switch code (0xAEAE) DAP_SWJ_Sequence(16, 0xE73C); // Ensure JTAG interface is reset DAP_SWJ_Sequence(6, 0x3F); - atomic: execute: | // JTAG \"Soft\" Reset DAP_JTAG_Sequence(6, 1, 0x3F); DAP_JTAG_Sequence(1, 0, 0x01); - if: protType == 2 blocks: - if: isSWJ blocks: - if: hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Select Dormant State (from JTAG) DAP_SWJ_Sequence(31, 0x33BBBBBA); // At least 8 cycles SWDIO/TMS HIGH DAP_SWJ_Sequence(8, 0xFF); // Alert Sequence Bits 0.. 63 DAP_SWJ_Sequence(64, 0x86852D956209F392); // Alert Sequence Bits 64..127 DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9); // 4 cycles SWDIO/TMS LOW + 8-Bit SWD Activation Code (0x1A) DAP_SWJ_Sequence(12, 0x1A0); // Enter SWD Line Reset State DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // &gt; 50 cycles SWDIO/TMS High DAP_SWJ_Sequence(3, 0x00); // At least 2 idle cycles (SWDIO/TMS Low) - if: !hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E) // Change if SWJ-DP uses deprecated switch code (0xEDB6) DAP_SWJ_Sequence(16, 0xE79E); // Enter SWD Line Reset State DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // &gt; 50 cycles SWDIO/TMS High DAP_SWJ_Sequence(3, 0x00); // At least 2 idle cycles (SWDIO/TMS Low) // Enter SWD Line Reset State DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // &gt; 50 cycles SWDIO/TMS High DAP_SWJ_Sequence(3, 0x00); // At least 2 idle cycles (SWDIO/TMS Low) - execute: | // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2) ReadDP(0x0); programming: The programming: node collects the flash algorithms of device memory (specified in DFP) and board memory (specified in BSP), and memory: specified the *.csolution.yml file. The algorithm in the DFP and BSP must have the attribute default=\"1\" set. If it specifies a style , only the styles \"Keil\" and \"CMSIS\" are added. Other algorithms may be add using the memory: node in the *.csolution.yml file. programming: Content - algorithm: Required Programming algorithm file including the path. start: Required Start address of memory covered by the programming algorithm. size: Required Size of memory covered by the programming algorithm. ram-start: Required Start address of RAM where the algorithm will be executed from. ram-size: Required Maximum size of RAM available for executing the programming algorithm. pname: Optional Specifies the processor for the execution of the algorithm. Note When pname: is specified the memory can only be programmed using the specified processor. Otherwise any processor in a multi-processor system can execute the programming algorithm. debug-topology: The debug-topology: node describes the properties of the system hardware for debug functionality. The information for this node is taken from the DFP. The following default values for debug-topology: are used: debug-topology: dormant: false swj: true debugports: - dpid: 0 jtag: tapindex: 0 swd: targetsel: 0 accessports: - apid: 0 index: 0 debug-topology: Content debugports: Optional Describes the CoreSight debug ports of the device and its capabilities. processors: Optional Map of pname identifiers to access port IDs (mandatory for multi-processor devices). swj: Optional Device allows switching between Serial Wire Debug (SWD) and JTAG protocols ( true or false ). dormant: Optional Device requires the dormant state to switch debug protocols ( true or false ). sdf: Optional System Description File ( *.sdf ) specified in the DFP . debugports: Content - dpid: Required Unique ID of this debug port. jtag: Optional Describes JTAG Test Access Port (TAP) properties of this debug port. tapindex: Optional TAP index in the JTAG scan chain of this device from TDI to TDO (default 0 ). swd: Optional Describes CoreSight Serial Wire Debug Port (SW-DP) properties of this debug port. targetsel: Optional SWD multi-drop target selection. accessports: Optional List of CoreSight access ports (APv1/APv2) (mandatory for multi-processor devices). accessports: Content - apid: Required Unique ID of this access port. If only apid is provided, access port (APv1) with index 0 will be implicitly used. index: Optional Index to select this access port (APv1) for a target access. address: Optional Address to select this access port (APv2) in its parent's address space for a target access. HPROT: Optional Value for HPROT (AHB Protection Control) bits. SPROT: Optional Value for SPROT (Secure Protection Control) bit. datapatch: Optional List of patch values a debugger shall apply when reading from the device. accessports: Optional Nested CoreSight access ports (APv2). Note index: and address: cannot be specified at the same time. processors: Content - pname: Required Processor identifier (mandatory for multi-processor devices). punits: Optional Specifies processor units in a symmetric multi-processor core (MPCore) (mandatory when more than one CPU debug block is accessible). apid: Optional Access port ID to use for this processor. reset-sequence: Optional Name of debug sequence for reset operation (default: ResetSystem sequence). datapatch: Content - address: Required Address for which to apply the patch. value: Required Value to overwrite from device (for example in a ROM table). mask: Optional The bits to patch. Default: complete value is replaced. type: Optional Type of data access to patch (see table below). Default is Mem . info: Optional Descriptive text for diagnostics messages. The table lists the allowed values for data patch access types. type Data patch access type AP CoreSight Access Port register access. Mem Memory access (default when type is not specified) punits: Content - punit: Required Specifies a specific processor unit of a symmetric MPCore. address: Required Specifies the base address of the CPU debug block. Note The nodes in italic are specified for future expansion, but currently not implemented. Usage The *.cbuild-run.yml file provides all information about the application project for run and debug. It can be used with tools such as pyOCD as shown below. Start gdbserver for debug connection: >pyocd gdbserver --cbuild-run out\\MyProject+TargetHW.cbuild-run.yml Program flash with application images: >pyocd load --cbuild-run out\\MyProject+TargetHW.cbuild-run.yml","title":"Build Information Files"},{"location":"YML-CBuild-Format/#build-information-files","text":"The following chapter explains the output files generated by the csolution tool. Depending on options, the files *.cbuild-pack.yml and *.cbuild-set.yml are also used as input files. The build information files are used for: generate CMake input files via the cbuild2cmake tool. provide details for the graphical user interface in VS Code extension Arm CMSIS Solution . obtain a list of licenses used in a project. File Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.yml Build description of a single *.cproject.yml input file; contains all information for the build step for a specific context including references to the content used from software packs. *.cbuild-pack.yml Software packs recorded for all input files ( *.csolution.yml , cproject.yml , and .clayer.yml ); used as input file to ensure reproducible builds that use the same software packs and pack versions. *.cbuild-set.yml Context selection for the build process, enabled with option --context-set: . *.cbuild-run.yml Contains the information required to download and debug a csolution project to a target. !!! Note CMSIS-Toolbox 2.11 creates the *.cbuild.yml and *.cbuild-run.yml files in the out directory along with the related output files.","title":"Build Information Files"},{"location":"YML-CBuild-Format/#directory-structure","text":"The csolution based projects are portable across different host computers and use, therefore relative file references . All file references use relative paths to the base directory of the related *.yml file. Files that are within the file structure of the csolution base directory are also referenced using relative paths, i.e. ../layers/layer1/source-file1.c . Files that are located in the CMSIS-Pack root directory are prefixed with ${CMSIS_PACK_ROOT} . Note All file references to user source code should be relative paths. The prefixes ${CMSIS_PACK_ROOT} and ${CMSIS_COMPILER_ROOT} are used to refer to base directories of files that relate to software packs and compiler-specific files. These base directories can also be on different filesystem drives. Files outside of the directory structure of a csolution based application use absolute paths. If absolute paths are used, a warning is issued in the *.cbuild-idx.yml file. A typical directory structure of a csolution based application that uses common layers source files are shown below. \ud83d\udce6 # csolution base directory \u2523 myapp.csolution.yml \u2523 myapp.cbuild-idx.yml \u2523 myapp.cbuild-pack.yml \u2523 myapp.cbuild-set.yml \u2523 \ud83d\udcc2 project1 \u2503 \u2523 mypro1.cproject.yml # file references are relative to directory project1 \u2523 \ud83d\udcc2 project2 \u2503 \u2523 mypro2.cproject.yml # file references are relative to directory project \u2523 \ud83d\udcc2 layer \u2503 \u2523 mylayer.clayer.yml # file references are relative to directory layer \u2523 \ud83d\udcc2 out \u2503 \u2523 myapp+Target.cbuild-run.yml # file references are relative to directory out \u2523 \u2523 \ud83d\udcc2 mypro1\\Target\\Debug \u2523 \u2523 \u2523 mypro1.cbuild.Debug+Target.yml # file references are relative to directory out\\mypro1\\Target\\Debug \u2523 \u2523 \ud83d\udcc2 mypro2\\Target\\Debug \u2523 \u2523 \u2523 mypro2.cbuild.Debug+Target.yml # file references are relative to directory out\\mypro2\\Target\\Debug","title":"Directory Structure"},{"location":"YML-CBuild-Format/#lock-pack-versions","text":"A csolution project refers to packs in different files ( *.csolution.yml , *.cproject.yml or *.clayer.yml ). To ensure consistent pack usage during application development (for example when new target-types or build-types are introduced), the *.cbuild-pack.yml file records the exact pack versions. The required packs can be specified in csolution project files in the following ways: exactly, e.g. ARM::CMSIS@5.9.0 with range, e.g. ARM::CMSIS@>=5.8.0 without version, e.g. ARM::CMSIS with wildcards on the pack name, e.g. ARM::CMSI* without pack name, e.g. ARM The required packs are resolved to an exact pack version that is recorded in the *.cbuild-pack.yml file as shown below: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by-pack: - ARM - ARM::CMSI* - ARM::CMSIS - ARM::CMSIS@>=5.8.0 - ARM::CMSIS@5.9.0 If csolution project files are modified, the selected-by-pack information ensures that consistent pack versions are used. If a required pack is no longer used in present in the csolution project , the relevant entry resolved-pack: in the *.cbuild-pack.yml file is removed. The *.cbuild-pack.yml file is located in the same directory as the *.csolution.yml file and is used by the csolution for every command that uses a *.csolution.yml file. Examples are: csolution convert - uses and updates the *.cbuild-pack.yml file. csolution list ... - uses the *.cbuild-pack.yml file csolution run - uses the *.cbuild-pack.yml file. csolution update-rte - uses and updates the *.cbuild-pack.yml file. The operation of the csolution command is as follows: Load the csolution project files ( *.csolution.yml , *.cproject.yml or *.clayer.yml ). Initially there is no *.cbuild-pack.yml file. If it exists, the *.cbuild-pack.yml file is loaded. The packs are aligned with the resolved-pack: information of the *.cbuild-pack.yml file in these steps: PopulateContexts : Add resolved-pack: information to the solution data model . AddPackRequirements : Pack version ranges and pack wildcards are matched to fully qualified versions of the solution data model . Pack wildcards are expanded to fully qualified packs using cbuild-pack.yml. Pack wildcards are kept for further expansion in the solution data model . Execute the csolution command, for example convert , list , run , or update-rte . Update the *.cbuild-pack.yml file (only if the content changes): GenerateCbuildPack : Generate the resolved-pack: list of packs required by all contexts . The original pack: specification is stored under selected-by-pack: . With the subsequent csolution command, the information of the *.cbuild-pack.yml file is used to load the appropriate fully qualified pack versions, matching previously used packs.","title":"Lock Pack Versions"},{"location":"YML-CBuild-Format/#file-format","text":"The following sections describe the format of the build information files . Many nodes are identical with the CSolution Project Format , but optional information is fully expanded. The nodes that are different are explained below under: Nodes for Project Management Nodes for File Management Nodes for License Information","title":"File Format"},{"location":"YML-CBuild-Format/#cbuild-idxyml","text":"The <solution-name>.cbuild-idx.yml file is generated for the csolution project and refers all contexts that are generated. It is structured as outlined below. build-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. description: Brief description text copied from the *.csolution.yml input file used to generate this application. cdefault: Relative path and name of the *.cdefault.yml input file used to generate this application. csolution: Relative path and name of the *.csolution.yml input file used to generate this application. configurations: For reference applications with undefined layers: list of potential project configurations for a reference application with undefined layers cprojects: List of *.cproject.yml and *.clayer.yml input files used to generate this application. cbuilds: List of *.cbuild.yml output files that are generated by *.cproject.yml files for this application. select-compiler: For projects with unspecified compiler: list of available compilers for selection Example: build-idx: generated-by: csolution version 2.3.0 description: USB application examples sharing board layers. cdefault: cdefault.yml csolution: USB.csolution.yml configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml cprojects: - cproject: Device/HID/HID.cproject.yml clayers: - clayer: $Board-Layer$ - cproject: Device/MassStorage/MassStorage.cproject.yml clayers: - clayer: $Board-Layer$ cbuilds: - cbuild: out/HID/B-U585I-IOT02A/Debug/HID.Debug+B-U585I-IOT02A.cbuild.yml project: HID configuration: .Debug+B-U585I-IOT02A - cbuild: out/MassStorage/B-U585I-IOT02A/Release/MassStorage.Release+B-U585I-IOT02A.cbuild.yml project: MassStorage configuration: .Release+B-U585I-IOT02A - cbuild: out/hello_world/B-U585I-IOT02A/Release/hello_world.Release+B-U585I-IOT02A.cbuild.yml west: true project: hello_world configuration: .Release+B-U585I-IOT02A errors: true # indicates error packs-missing: # lists missing packs - pack: ARM::CMSIS-RTX # with unspecified version - pack: ARM::CMSIS@6.0.0 # with specified version","title":"*.cbuild-idx.yml"},{"location":"YML-CBuild-Format/#cbuildyml","text":"The <project-name>.<build-type>+<target-type>.cbuild.yml file contains all information for one context . It is structured as outlined below. build: Content generated-by: Reference to csolution tool along with version information used to generate this application. context: Project context of this build description. compiler: Compiler toolchain used for code generation. board: Board name used for this context. board-pack: BSP that is defining the Board name used for this context. board-books: List board documentation as defined in the PDSC element <board> . device: Device name with processor core selection used in this project context. device-pack: DFP that is defining the Device name with processor core selection used in this project context. device-books: List device documentation as defined in the PDSC element <device> . processor: List of processor attributes used in this project context. packs: List of software packs along with path information used to generate this project context. optimize: Generic optimize level for code generation. link-time-optimize: Enable optimization at linker level . debug: Global control the generation of debug information. warnings: Global control warning level for compiler diagnostics. misc: Global control of miscellaneous literal tool-specific controls. define: List of global define symbol settings. add-path: List of global include path settings. output-type: Select the output type (exe or lib) for this project context. output-dirs: Specifies the directories used to generate the output files. linker: Specifies the linker script processing used to generate the output files. components: List of software components used. apis: List of API interfaces used. groups: List of source file groups along with source files. constructed-files: List of files that are generated by RTE management of the csolution tool. licenses: List of licenses used by the various software components of this project context. Example: build: context: HelloWorld_cm0plus.Debug+FRDM-K32L3A6 compiler: AC6 device: K32L3A60VPJ1A:cm0plus processor: fpu: off endian: little trustzone: non-secure packs: - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 - pack: NXP::K32L3A60_DFP@15.0.0 path: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 optimize: none debug: on misc: C: - -std=c99 - -fno-builtin CPP: - -fno-builtin Link: - --diag_suppress 6314 - --entry=Reset_Handler define: - CPU_K32L3A60VPJ1A_cm0plus - MCMGR_HANDLE_EXCEPTIONS=1 : - _RTE_ add-path: - ../middleware/multicore/mcmgr/src - RTE/Board_Support/K32L3A60VPJ1A_cm0plus - RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6 - ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0/CMSIS/Core/Include - ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0 : output-type: exe output-dirs: gendir: generated intdir: ../tmp/HelloWorld_cm0plus/FRDM-K32L3A6/Debug outdir: ../out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug rtedir: RTE components: - component: ARM::CMSIS:CORE@5.6.0 condition: ARMv6_7_8-M Device from-pack: ARM::CMSIS@5.9.0 selected-by: ARM::CMSIS:CORE - component: NXP::Device:CMSIS:K32L3A60_system@1.0.0 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:CMSIS:K32L3A60_system files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/system_K32L3A60_cm0plus.c category: sourceC - component: NXP::Device:SDK Drivers:clock@2.2.1 condition: device.K32L3A60_AND_driver.common from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:clock files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_clock.c category: sourceC - component: NXP::Device:SDK Drivers:common@2.3.2 condition: device.K32L3A60_AND_device.K32L3A60_CMSIS_AND_driver.clock from-pack: NXP::K32L3A60_DFP@15.0.0 selected-by: NXP::Device:SDK Drivers:common files: - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common.c category: sourceC - file: ${CMSIS_PACK_ROOT}/NXP/K32L3A60_DFP/15.0.0/drivers/fsl_common_arm.c category: sourceC : groups: - group: Application files: - file: ./hello_world_core1.c category: sourceC - file: ./RTE/Device/K32L3A60VPJ1A_cm0plus/K32L3A60xxx_cm0plus_flash.scf category: linkerScript - group: Middleware files: - file: ../middleware/multicore/mcmgr/src/mcmgr.c category: sourceC : constructed-files: - file: RTE/_HelloWorld_cm0plus.Debug_FRDM-K32L3A6/RTE_Components.h category: header","title":"*.cbuild.yml"},{"location":"YML-CBuild-Format/#cbuild-packyml","text":"The <solution-name>.cbuild-pack.yml file contains the pack information for the csolution project . It is structured as outlined below. cbuild-pack: Content resolved-packs: List of packs used to create the project contexts. resolved-packs: Content - resolved-pack: pack name used. selected-by-pack: List of components included from the pack. Example: cbuild-pack: resolved-packs: - resolved-pack: ARM::CMSIS@5.9.0 selected-by: - ARM::CMSIS - resolved-pack: ARM::V2M_MPS3_SSE_300_BSP@1.2.0 selected-by: - ARM::V2M_MPS3_SSE_300_BSP@1.2.0 - resolved-pack: Keil::ARM_Compiler@1.7.2 selected-by: - Keil::ARM_Compiler","title":"*.cbuild-pack.yml"},{"location":"YML-CBuild-Format/#cbuild-setyml","text":"The <solution-name>.cbuild-set.yml file selects the context set for the csolution project . The structure is outlined below. cbuild-set: Content generated-by: Reference to tool along with version information that generated this file. contexts: List of context names for the context-set: option. Example: cbuild-set: generated-by: csolution version 2.2.0 contexts: - context: CM33_s.Release+AVH - context: CM33_ns.Debug+AVH","title":"*.cbuild-set.yml"},{"location":"YML-CBuild-Format/#nodes-for-project-management","text":"","title":"Nodes for Project Management"},{"location":"YML-CBuild-Format/#configurations","text":"The configurations: node lists possible configurations for reference applications that have undefined variable settings. configurations: Content - target-type: Name of target-type for which configurations are listed. target-configurations: List of possible configurations for the target-type. - configuration: Possible configuration for the reference application. - variables: List of variable names with configuration information. <layer-name>: Layer name with a value that is the path to the clayer.yml file. description: Brief description text taken from *.clayer.yml . settings: Usage instructions for this layer. - set: Value of set and info taken from connect: in *.clayer.yml . path: Path to the directory that contains the layer (from *.PDSC file). file: Name of the *.clayer.yml file (optional with a relative path to the directory specified with path) (from *.PDSC file). copy-to: Proposed directory for the layer in the csolution project (from *.PDSC file). Example: configurations: - target-type: B-U585I-IOT02A target-configurations: - configuration: - variables: - Board-Layer: /Users/.../Arm/Packs/Keil/B-U585I-IOT02A_BSP/2.0.0-dev0/Layers/IoT/Board.clayer.yml description: \"Configuration including FXLS8962 sensor\" - target-type: MyBoard - configuration: - variables: - Board-Layer: ./layer/board/frdmk22f/frdmk22f.clayer.yml description: \"Configuration: Ethernet, UART, and WiFi\" settings: - set: set1.select1 (connect A - set 1 select 1) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f - Shield-Layer: ./layer/shield/agmp03/agmp03.clayer.yml description: \"Shield with FXLS8962 and FXAS21002\" settings: - set: Bus.SPI (FXLS8962 SPI Bus - Jumper configuration: I2C/SPI=SPI) - set: Bus.SPI (FXAS21002 SPI Bus - Jumper configuration: I2C/SPI=SPI) path: ./layer/board/frdmk22f file: frdmk22f.clayer.yml copy-to: board/frdmk22f","title":"configurations:"},{"location":"YML-CBuild-Format/#cprojects","text":"The cprojects: node lists all *.cproject.yml input files along with *.clayer.yml files that are used to compose the application. cprojects: Content - cproject: Relative path and name of a *.cproject.yml input file. clayers: List of *.clayer.yml input files used by this *.cproject.yml file. Example: cprojects: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml clayers: - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/FreeRTOS+TCP/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/WiFi/Socket.clayer.yml - clayer: AWS_MQTT_MutualAuth_SW_Framework/Socket/VSocket/Socket.clayer.yml :","title":"cprojects:"},{"location":"YML-CBuild-Format/#cbuilds","text":"The cbuilds: node lists all project context configurations that are generated with this build. cbuilds: Content - cbuild: Build description file of a single context for a *.cproject.yml input file. project: Project name. configuration: Context configuration for this build description file. errors: Error indication. packs-missing: List of missing packs. packs-unused: List of unused packs. messages: List of errors: , warnings: , or info: messages. Example: cbuilds: - cproject: AWS_MQTT_MutualAuth_SW_Framework/Demo.cproject.yml project: Demo configuration: .Debug+AVH errors: true messages: errors: - no compatible software layer found. Review the required connections of the project info: - test.cbuild-set.yml - file is already up-to-date","title":"cbuilds:"},{"location":"YML-CBuild-Format/#select-compiler","text":"If no compiler is specified in the csolution project , the cbuild setup command lists the available compilers based on the compiler registration and select-compiler: node in the file *.csolution.yml or cdefault.yml . select-compiler: Content - compiler: Name (optionally with version) of the compiler toolchain; copied from the select-compiler: node in the csolution project .","title":"select-compiler:"},{"location":"YML-CBuild-Format/#packs","text":"The packs: node is the start of a pack list that is used for the project context. packs: Content - pack: Explicit pack specification with exact version information used. path: Path name that stores the software pack (see note). Note Packs that are located in the CMSIS-Pack root directory are prefixed with %CMSIS_PACK_ROOT% . Example: packs: - pack: ARM::CMSIS-FreeRTOS@10.4.6 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS-FreeRTOS/10.4.6 - pack: ARM::CMSIS@5.9.0 path: ${CMSIS_PACK_ROOT}/ARM/CMSIS/5.9.0 : - pack: MDK-Packs::IoT_Socket@1.3.1 path: ../IoT_Socket","title":"packs:"},{"location":"YML-CBuild-Format/#generators","text":"The generators: node contains information for calling a generator. generators: Content - generator: Section for a specific generator. path: Path name for storing the files generated. gdpsc: File name of the *.GDPSC file that stores the information in path: . command: Section for invoking the generator on different Host operating systems. Example: generators: - generator: STM32CubeMX path: RTE/Device gpdsc: RTE/Device/STM32L475VGTx/FrameworkCubeMX.gpdsc command: win: file: ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1/MDK/CubeMX/STM32CubeMxLauncher.exe arguments: - STM32L475VGTx - ../../Release+STM32L4.cprj - ${CMSIS_PACK_ROOT}/Keil/STM32L4xx_DFP/2.6.1","title":"generators:"},{"location":"YML-CBuild-Format/#generator","text":"generator: Content - id: Generator identifier used for this component path: File name and path to the *.cgen.yml file that is generated.","title":"generator:"},{"location":"YML-CBuild-Format/#nodes-for-file-management","text":"Keyword Description groups: Start of a list that adds source groups and files. components: Start of a list that adds software components.","title":"Nodes for File Management"},{"location":"YML-CBuild-Format/#linker","text":"linker: Content - regions: Path and file name of regions_<device_or_board>.h , used to generate a Linker Script via pre-processor. - script: Path and file name of the pre-processed Linker Script template. - define: Define symbol settings for the linker script file preprocessor.","title":"linker:"},{"location":"YML-CBuild-Format/#groups","text":"groups: Content - group: Name of the group. optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. groups: Start a nested list of groups. files: List of files that belong to a group","title":"groups:"},{"location":"YML-CBuild-Format/#files-of-a-group","text":"files: Content - file: Name of the file. category: File category according Open-CMSIS-Pack specification optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls.","title":"files: of a group"},{"location":"YML-CBuild-Format/#apis","text":"apis: Content - api: Name of the API. condition: Reference to the condition ID of the software pack that triggered the inclusion of this API. from-pack: Pack that defines this API. implemented-by: Refers to the software componeent that implements the API. files: List of files that belong to this API.","title":"apis:"},{"location":"YML-CBuild-Format/#components","text":"components: Content - component: Name of the software component. condition: Reference to the condition ID of the software pack that triggered the inclusion of this component. from-pack: Pack that defines this component. selected-by: The original component name used in cproject/clayer.YML . optimize: Optimize level for code generation. debug: Generation of debug information. warnings: Control generation of compiler diagnostics. define: Define symbol settings for code generation. add-path: Additional include file paths. misc: Literal tool-specific controls. instances: Number of component instances configured. maxInstances: Maximum number component instances that can be configured. generator: Generator information for components that are configurable via a generator. implements: Refers to the API that the component is based on. files: List of files that belong to this component.","title":"components:"},{"location":"YML-CBuild-Format/#files-of-a-component","text":"files: Content - file: Name and path to the file. category: File category according to Open-CMSIS-Pack specification attr: File category according to Open-CMSIS-Pack specification; api refers to header files that define the api of a component. condition: Reference to the condition ID of the software pack that triggered the inclusion of this file. select: Selection text for user code template files and api header files. version: For files that belong to components the version specified in the PDSC file. base: Unmodified configuration file (base file from the software pack ) that is currently in use. update: New configuration file from an updated software pack . status: Action for configuration file update: suggested, recommended, required.","title":"files: of a component"},{"location":"YML-CBuild-Format/#constructed-files","text":"A list of files that are generated by the RTE management of the csolution tool. constructed-files: Content - file: Name and path to the file. category: File category according Open-CMSIS-Pack specification.","title":"constructed-files:"},{"location":"YML-CBuild-Format/#nodes-for-license-information","text":"The *.cbuild.<build-type>+<target-type>.yml files contain license information about each software component that is included in software packs.","title":"Nodes for License Information"},{"location":"YML-CBuild-Format/#licenses","text":"Each different license that is used in a project context has a separate section. licenses: Content - license: License identifier or short description. lisense-agreement: File category according Open-CMSIS-Pack specification packs: List of software packs used to generate this project context. components: List of software components used to generate this project context. Example: licenses: - license: <proprietary> END USER LICENSE AGREEMENT FOR ARM SOFTWARE DEVELOPMENT TOOLS license-agreement: ${CMSIS_PACK_ROOT}/Keil/MDK-Middleware/8.0.0/license_terms/license_agreement.txt packs: - pack: Keil::MDK-Middleware@8.0.0 components: - component: Keil::USB&MDK:CORE@8.0.0 - component: Keil::USB&MDK:Device:HID@8.0.0 - component: Keil::USB&MDK:Device@8.0.0 - license: Apache-2.0 packs: - pack: ARM::CMSIS-Compiler@2.1.0 - pack: ARM::CMSIS-Driver_STM32@1.0.0 - pack: ARM::CMSIS-RTX@5.9.0 : components: - component: CMSIS Driver:GPIO(API) - component: CMSIS Driver:I2C(API) - component: CMSIS Driver:SPI(API) : - component: ARM::CMSIS-Compiler:CORE@1.1.0 - component: ARM::CMSIS-Compiler:STDERR:Custom@1.1.0 - component: ARM::CMSIS-Compiler:STDIN:Custom@1.1.0 :","title":"licenses:"},{"location":"YML-CBuild-Format/#west","text":"For each west build context a node west: is created in *.cbuild.yml west: Content app-path: Required Path to the application source directory. project-id: Required Project identifier board: Required Board name used for west build invocation. device: Optional Specify the processor core for execution of the generated image (used in *.cbuild-run.yml ). west-defs: Optional Defines in CMake format. The west-defs: from build and target-type are added. west-opt: Optional Options for the west tool (default: empty). Example: west: project-id: hello_world app-path: ../../../../hello_world board: stm32h7b3i_dk west-defs: - CONFIG_BUILD_OUTPUT_HEX=y","title":"west:"},{"location":"YML-CBuild-Format/#generator-information-files","text":"The csolution run command generates the following build information files in the intdir: of the related context . These files are the input to a generator and provide information about the csolution project to the generator. The files are generated in the tmp directory of the project and contain absolute paths. File Description *.cbuild-gen-idx.yml Index file of all *.cbuild-gen.yml build descriptions; contains also overall information for the application. *.cbuild-gen.yml Build description of a single *.cproject.yml input file. The format is identical with the *.cbuild.yml file.","title":"Generator Information Files"},{"location":"YML-CBuild-Format/#file-structure-of-cbuild-gen-idxyml","text":"build-gen-idx: Content generated-by: Reference to csolution tool along with version information used to generate this application. generators: List of generators that are called with the run command. generators: Content - id: generator identifier specified with the option --generator in the csolution run command. output: Specifies the directory for generated files. board: Board name used for the generator. device: Device name used for the generator. project-type: Describes the project type \"single-core\", \"multi-core\", \"trustzone\". cbuild-gens: List of *.cbuild-gen.yml files with options that are generated for the generator run. cbuild-gens: Content - cbuild-gen: Build information file with name <context>.cbuild-gen.yml ; structure identical with *.cbuild.yml . project: Project name (used as a name for *.cgen.yml when name: is not specified). configuration: Specifies .build-type+target-type of this context. name: Explicit name for the *.cgen.yml generator import file specified by generator options . map: Mapping to a generator-specific run-time context name specified by generator options . Example: build-gen-idx: generated-by: csolution version 2.3.0 generators: - id: CubeMX output: C:/w/csolution-examples/CubeMX/STM32CubeMX/MyBoard # output directory device: STM32U585AIIx board: B-U585I-IOT02A project-type: single-core cbuild-gens: - cbuild-gen: C:/w/csolution-examples/CubeMX/tmp/CubeMX/MyBoard/Debug/CubeMX.Debug+MyBoard.cbuild-gen.yml project: CubeMX # user selected name of the project configuration: .Debug+MyBoard name: BoardLayer # create BoardLayer.cgen.yml in output directory (new in CMSIS-Toolbox 2.4.0) map: Boot # map to STM32CubeMX run-time context (new in CMSIS-Toolbox 2.4.0)","title":"File Structure of *.cbuild-gen-idx.yml"},{"location":"YML-CBuild-Format/#generator-import-file","text":"The *.cgen.yml file lists the generated csolution project part and starts with the node generator-import: . It is defined similarly to a Software Layer additional parameters, files, and components that are included in the project.","title":"Generator Import File"},{"location":"YML-CBuild-Format/#file-structure-of-cgenyml","text":"generator-import: Content generated-by: Tool name that generated this file for-device: Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Board information, used for consistency check (board selection is in *.csolution.yml ). packs: Defines packs that are required for this layer. define: Define symbol settings for code generation. undefine: Remove define symbol settings for code generation. add-path: Additional include file paths. del-path: Remove specific include file paths. groups: List of source file groups along with source files. components: List of software components used.","title":"File Structure of *.cgen.yml"},{"location":"YML-CBuild-Format/#run-and-debug-management","text":"The CMSIS-Toolbox build system manages software packs that contain information about device, board, and software components. It controls the build output (typically ELF/DWARF files), and has provisions for HEX, BIN and post-processing. The target-set: node configures the application images and the debugger for a target-type . The software packs contain information that is the basis for debug and run settings: Flash algorithms of device memory (in DFP) and board memory (in BSP). On-board debug adapter (a default programming/debug channel) including features. Available memory of device and board. Device parameters such as processor core(s) and clock speed. Debug Access Sequences and System Description Files that support more complex Cortex-A/R/M configurations. Debug Configuration files ( *.dbgconf ) that configure device properties such as trace pins. CMSIS-SVD System View Description (SVD) files for viewing device peripherals. CMSIS-View Software Component Viewer Description (SCVD) files for analysis of software components (RTOS, Middleware). The user may add the following information in the *.csolution.yml file: Additional memory with flash algorithms for external memory in custom hardware using the memory: node. Additional images that should be programmed or loaded using the images: node. Debugger configuration provided by packs can be adjusted using the debugger: node. Note The information may be defined at various places. The *.csolution.yml file overrules the information from the BSP. The BSP overrules the information from the DFP. The file *.cbuild-run.yml contains for a single target-type of a csolution project the relevant information for run and debug. The information is collected by the CMSIS-Toolbox and the file name has the format <solution-name>+<target-type>.cbuild-run.yml file. It is used by programmers and debuggers in command line or IDE workflows. The information is portable, i.e. from a cloud-hosted CI system to a desktop test system. The <solution-name>+<target-type>.cbuild-run.yml file represents a single target-type of a csolution project . Example: cbuild-run: generated-by: csolution version 2.7.0 solution: CubeMX.csolution.yml target-type: MyBoard_ROM compiler: AC6 device: STMicroelectronics::STM32U585AIIx device-pack: Keil::STM32U5xx_DFP@3.0.0 board: STMicroelectronics::B-U585I-IOT02A:Rev.C board-pack: Keil::B-U585I-IOT02A_BSP@2.0.0 programming: - algorithm: ${CMSIS_PACK_ROOT}/Keil/STM32U5xx_DFP/3.0.0/CMSIS/Flash/STM32U5xx_2M_0800.FLM start: 0x08000000 size: 0x00200000 ram-start: 0x20000000 ram-size: 0x00008000 - algorithm: ${CMSIS_PACK_ROOT}/Keil/STM32U5xx_DFP/3.0.0/CMSIS/Flash/STM32U5xx_2M_0C00.FLM : system-descriptions: - file: ${CMSIS_PACK_ROOT}/Keil/STM32U5xx_DFP/3.0.0/CMSIS/SVD/STM32U585.svd type: svd output: - file: out/CubeMX/MyBoard_ROM/Debug/CubeMX.axf type: elf system-resources: memory: : debugger: - name: pyOCD@CMSIS-DAP : debug-vars: : debug-sequences: : debug-topology: :","title":"Run and Debug Management"},{"location":"YML-CBuild-Format/#file-structure-of-cbuild-runyml","text":"The following describes the overall structure of the *.cbuild-run.yml file. While the content of this file is generated using the cbuild command, it is also posssible to manually generate this file or modify content. cbuild-run: Content generated-by: Optional Tool name that generated this file. solution: Optional Name of the *.csolution.yml file. target-type: Optional Name of the target-type that was selected. target-set: Optional Name of the target-set that was selected (format <target-type>[@<set>] ). compiler: Optional Compiler toolchain used for code generation. board: Optional Board name used for this target. board-pack: Optional BSP that is defining the Board name used for this target. device: Optional Device name used in this target. device-pack: Optional DFP that is defining the Device used in this target. output: Required List of the image (ELF, HEX, BIN) files generated. system-resources: Optional List of the system resources available in target. system-descriptions: Optional List of description files for peripherals and software components. debugger: Required Configuration information for the debug connection. debug-sequences: Optional Tool actions for debugging, tracing, or programming. programming: Optional Algorithms for flash download. debug-topology: Optional Properties of the system hardware for debug functionality.","title":"File Structure of *.cbuild-run.yml"},{"location":"YML-CBuild-Format/#output","text":"This node contains information about the images that should be loaded. The images that are generated by the csolution project are typically configured using a target-set . The output: node includes also image files that are generated with a West Build specification. The output: node also contains other required files that are added with images: in the *.csolution.yml file. output: Content - file: Required Specifies the file name. type: Required Specifies the file type. info: Optional Brief description of the file. load: Required Load mode of the image file for programmers and debug tools. load-offset: Optional Offset applied in *.csolution.yml when loading the image file. pname: Optional Image belongs to processor in a multi-core system. load: mode For image: files that are added using the images: node of the *.csolution.yml file but have no load: mode specified, the CMSIS-Toolbox adds an load: mode depending on the file type. Files with type: elf get load: image+symbols . Files with type: lib get load: none . All other file types get load: image . For files that are the output of a cproject.yml project, the output: node lists all files that are generated. The CMSIS-Toolbox adds an load: mode depending on the compiler used and the file types that are generated to indicate how these files should be used by programmers and debug tools. For compiler: AC6 : When only a file with type: elf is generated, the file gets load: image+symbols . When a file with type: elf and a file with type: hex is generated, the type: elf file gets load: symbols and the type: hex file gets load: image . This allows to bypass GNU loader issues with Arm Compiler 6 . All other file types get load: none . For any other compiler: Files with type: elf get load: image+symbols . All other file types get load: none . Note info: generate by <context> indicates that an image is generated by a context of the csolution project .","title":"output:"},{"location":"YML-CBuild-Format/#system-resources","text":"The system-resources: node lists the resources of a target system. It includes memory from the DFP, BSP, and memory: definitions from the csolution.yml file. system-resources: Content memory: Optional Identifies the section for memory. memory: Content - name: Required Name of the memory region (when PDSC contains id, it uses the id as name). access: Required Access attribute string for the memory (see table below). start: Required Base address of the memory. size: Required Size of the memory. pname: Optional Only accessible by a specific processor. alias: Optional Name of identical memory exposed at different address. from-pack: Optional Pack that defines this memory. The table lists the letters and their meaning for use in the access attribute string. access: Description r Readable w Writable x eXecutable p Peripheral area. Details described in SVD file. s Secure attribute n Non-secure attribute c non-secure Callable attribute Example: system-resources: memory: - name: ITCM_Flash access: rx start: 0x00200000 size: 0x00100000 from-pack: Keil::STM32U5xx_DFP@3.0.0 - name: Ext-Flash access: rx start: 0x40000000 size: 0x200000","title":"system-resources:"},{"location":"YML-CBuild-Format/#system-descriptions","text":"List of the description files for peripherals and software components used in this project target. system-descriptions: Value Use Content - file: string Required Specifies the file name including the path. type: string Required Specifies the file type (see table below). info: string Optional Brief description of the file. pname: string Optional File is used only for a specific processor; default is for all processors. type: Description svd System View Description ( *.svd ) file specified in the DFP . scvd Software Component Viewer Description ( *.scvd ) file for CMSIS-View .","title":"system-descriptions:"},{"location":"YML-CBuild-Format/#debugger","text":"This node contains connection information for a debugger with inital settings coming from the board support pack (BSP) or device family pack (DFP). debugger: Content name: Required Identifies the debug configuration. info: Optional Brief description from target-set. protocol: Optional Selected debug protocol (jtag or swd). clock: Optional Selected debug clock speed in Hz. dbgconf: Optional Debugger configuration file (pinout, trace). start-pname: Optional Debugger connects at start to this processor. gdbserver: Optional Information for GDB server option of debugger. terminal: Future Terminal port of the debugger. trace: Future Trace port of the debugger. *: Optional Other debugger specific options specified under target-set . !!! Note: - protocol: and clock: are required by pyOCD but optional for other debug adapters. The file ./etc/debug-adatpers.yml allows to specify default values for required options. - start-pname: is mandatory for multi-processor targets. If start-pname: is not configured using the debugger: node in the *.csolution.yml file, the pname: of the first *.cproject.yml file is used. The information for the debugger: node may be configured using the debugger: node in the *.csolution.yml file. If not present the values from BSP are used; if not present DFP values. The values in the *.csolution.yml file overwrites values from BSP or DFP as shown in the table below. *.cbuild-run.yml *.csolution.yml BSP DFP debugger: debugger: <boards><board><debugProbe ... <device><debugconfig ... protocol: protocol: debugLink default clock: clock: debugClock clock If no input ( *.csolution.yml , BSP or DFP) provides debugger option values, the CMSIS-Toolbox uses the values under defaults: from the file .\\ect\\debug-adapters.yml . Example: debugger: name: CMSIS-DAP info: On-Board debugger of MCB4300 protocol: jtag clock: 10000000 dbgconf: /.cmsis/MySolution+lpc4300.dbgconf","title":"debugger:"},{"location":"YML-CBuild-Format/#gdbserver","text":"These are options for the pyOCD GDB server configuration (could be optionally used by other debuggers as well). Note The gdbserver: node is only generated when the file .\\ect\\debug-adapters.yml contains gdbserver: for the selected debug adatper. gdbserver: Content - port: Required Port number of processor pname: Optional Processor name of the processor (only required for multi-core systems) punit: Future Identifies the procssor core in a SMP system. Example: debugger: name: CMSIS-DAP protocol: swd clock: 10000000 dbgconf: /.cmsis/MySolution+MCXN9XX.dbgconf gdbserver: - port: 3333 pname: cm33_core1 - port: 3334 pname: cm33_core0","title":"gdbserver:"},{"location":"YML-CBuild-Format/#debug-vars","text":"This node contains the default value from the DFP for the variables used in debug-sequences: . This initial values are overwritten by explicit settings in the *.dbgconf file that is provided in the debugger: node. debug-vars: Content vars: Optional Initial values for variables used in debug-sequences: . Example: debug-vars: vars: | // Default values for variables in debug sequences. Are configured with a *.dbgconf file in the user project __var SWO_Pin = 0; // Serial Wire Output pin: 0 = PIO0_10, 1 = PIO0_8 __var Dbg_CR = 0x00000000; // DBG_CR __var BootTime = 10000; // 10 milliseconds","title":"debug-vars:"},{"location":"YML-CBuild-Format/#debug-sequences","text":"This node contains the debug sequences from the DFP for the target. Debug sequences define the activities of development tools to connect to a device using the debug channel for debugging, tracing, or flash programming. The sequence name is also used to overwrite a default sequence. A sequence that contains no blocks disables the default sequence. debug-sequences: Content - name: Required Name of the sequence. info: Optional Descriptive text to display for example for error diagnostics. blocks: Optional A list of command blocks in order of execution. pname: Optional Executes sequence only for a specific processor; default is for all processors. blocks: Content - info: Optional Descriptive text to display for example for error diagnostics. blocks: Optional A list of command blocks in the order of execution. execute: Optional Commands for execution. atomic: Optional Atomic execution of commands; cannot be used with blocks: . if: Optional Only executed when expression is true. while: Optional Executed in loop until while expression is true. timeout: Optional Timeout value (integer) in milliseconds for while loop. Note When atomic: is applied, sequences execute with no interrupts as fast as possible using CMSIS-DAP Atomic Commands . It has therefore restrictions and cannot be combined with blocks: . A blocks: node can either contain execute: or blocks: but not both. Example: DebugPortSetup debug-sequences: - name: DebugPortSetup blocks: - execute: | __var isSWJ = ((__protocol &amp; 0x00010000) != 0); __var hasDormant = __protocol &amp; 0x00020000; __var protType = __protocol &amp; 0x0000FFFF; - if: protType == 1 blocks: - if: isSWJ blocks: - if: hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Select Dormant State (from SWD) DAP_SWJ_Sequence(16, 0xE3BC); // At least 8 cycles SWDIO/TMS HIGH DAP_SWJ_Sequence(8, 0xFF); // Alert Sequence Bits 0.. 63 DAP_SWJ_Sequence(64, 0x86852D956209F392); // Alert Sequence Bits 64..127 DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9); // 4 cycles SWDIO/TMS LOW + 8-Bit JTAG Activation Code (0x0A) DAP_SWJ_Sequence(12, 0x0A0); // Ensure JTAG interface is reset DAP_SWJ_Sequence(6, 0x3F); - if: !hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C) // Change if SWJ-DP uses deprecated switch code (0xAEAE) DAP_SWJ_Sequence(16, 0xE73C); // Ensure JTAG interface is reset DAP_SWJ_Sequence(6, 0x3F); - atomic: execute: | // JTAG \"Soft\" Reset DAP_JTAG_Sequence(6, 1, 0x3F); DAP_JTAG_Sequence(1, 0, 0x01); - if: protType == 2 blocks: - if: isSWJ blocks: - if: hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Select Dormant State (from JTAG) DAP_SWJ_Sequence(31, 0x33BBBBBA); // At least 8 cycles SWDIO/TMS HIGH DAP_SWJ_Sequence(8, 0xFF); // Alert Sequence Bits 0.. 63 DAP_SWJ_Sequence(64, 0x86852D956209F392); // Alert Sequence Bits 64..127 DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9); // 4 cycles SWDIO/TMS LOW + 8-Bit SWD Activation Code (0x1A) DAP_SWJ_Sequence(12, 0x1A0); // Enter SWD Line Reset State DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // &gt; 50 cycles SWDIO/TMS High DAP_SWJ_Sequence(3, 0x00); // At least 2 idle cycles (SWDIO/TMS Low) - if: !hasDormant atomic: execute: | // Ensure current debug interface is in reset state DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E) // Change if SWJ-DP uses deprecated switch code (0xEDB6) DAP_SWJ_Sequence(16, 0xE79E); // Enter SWD Line Reset State DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // &gt; 50 cycles SWDIO/TMS High DAP_SWJ_Sequence(3, 0x00); // At least 2 idle cycles (SWDIO/TMS Low) // Enter SWD Line Reset State DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // &gt; 50 cycles SWDIO/TMS High DAP_SWJ_Sequence(3, 0x00); // At least 2 idle cycles (SWDIO/TMS Low) - execute: | // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2) ReadDP(0x0);","title":"debug-sequences:"},{"location":"YML-CBuild-Format/#programming","text":"The programming: node collects the flash algorithms of device memory (specified in DFP) and board memory (specified in BSP), and memory: specified the *.csolution.yml file. The algorithm in the DFP and BSP must have the attribute default=\"1\" set. If it specifies a style , only the styles \"Keil\" and \"CMSIS\" are added. Other algorithms may be add using the memory: node in the *.csolution.yml file. programming: Content - algorithm: Required Programming algorithm file including the path. start: Required Start address of memory covered by the programming algorithm. size: Required Size of memory covered by the programming algorithm. ram-start: Required Start address of RAM where the algorithm will be executed from. ram-size: Required Maximum size of RAM available for executing the programming algorithm. pname: Optional Specifies the processor for the execution of the algorithm. Note When pname: is specified the memory can only be programmed using the specified processor. Otherwise any processor in a multi-processor system can execute the programming algorithm.","title":"programming:"},{"location":"YML-CBuild-Format/#debug-topology","text":"The debug-topology: node describes the properties of the system hardware for debug functionality. The information for this node is taken from the DFP. The following default values for debug-topology: are used: debug-topology: dormant: false swj: true debugports: - dpid: 0 jtag: tapindex: 0 swd: targetsel: 0 accessports: - apid: 0 index: 0 debug-topology: Content debugports: Optional Describes the CoreSight debug ports of the device and its capabilities. processors: Optional Map of pname identifiers to access port IDs (mandatory for multi-processor devices). swj: Optional Device allows switching between Serial Wire Debug (SWD) and JTAG protocols ( true or false ). dormant: Optional Device requires the dormant state to switch debug protocols ( true or false ). sdf: Optional System Description File ( *.sdf ) specified in the DFP . debugports: Content - dpid: Required Unique ID of this debug port. jtag: Optional Describes JTAG Test Access Port (TAP) properties of this debug port. tapindex: Optional TAP index in the JTAG scan chain of this device from TDI to TDO (default 0 ). swd: Optional Describes CoreSight Serial Wire Debug Port (SW-DP) properties of this debug port. targetsel: Optional SWD multi-drop target selection. accessports: Optional List of CoreSight access ports (APv1/APv2) (mandatory for multi-processor devices). accessports: Content - apid: Required Unique ID of this access port. If only apid is provided, access port (APv1) with index 0 will be implicitly used. index: Optional Index to select this access port (APv1) for a target access. address: Optional Address to select this access port (APv2) in its parent's address space for a target access. HPROT: Optional Value for HPROT (AHB Protection Control) bits. SPROT: Optional Value for SPROT (Secure Protection Control) bit. datapatch: Optional List of patch values a debugger shall apply when reading from the device. accessports: Optional Nested CoreSight access ports (APv2). Note index: and address: cannot be specified at the same time. processors: Content - pname: Required Processor identifier (mandatory for multi-processor devices). punits: Optional Specifies processor units in a symmetric multi-processor core (MPCore) (mandatory when more than one CPU debug block is accessible). apid: Optional Access port ID to use for this processor. reset-sequence: Optional Name of debug sequence for reset operation (default: ResetSystem sequence). datapatch: Content - address: Required Address for which to apply the patch. value: Required Value to overwrite from device (for example in a ROM table). mask: Optional The bits to patch. Default: complete value is replaced. type: Optional Type of data access to patch (see table below). Default is Mem . info: Optional Descriptive text for diagnostics messages. The table lists the allowed values for data patch access types. type Data patch access type AP CoreSight Access Port register access. Mem Memory access (default when type is not specified) punits: Content - punit: Required Specifies a specific processor unit of a symmetric MPCore. address: Required Specifies the base address of the CPU debug block. Note The nodes in italic are specified for future expansion, but currently not implemented.","title":"debug-topology:"},{"location":"YML-CBuild-Format/#usage","text":"The *.cbuild-run.yml file provides all information about the application project for run and debug. It can be used with tools such as pyOCD as shown below. Start gdbserver for debug connection: >pyocd gdbserver --cbuild-run out\\MyProject+TargetHW.cbuild-run.yml Program flash with application images: >pyocd load --cbuild-run out\\MyProject+TargetHW.cbuild-run.yml","title":"Usage"},{"location":"YML-Input-Format/","text":"CSolution Project Format The following chapter explains the CMSIS Solution Project File Format (short form csolution project files ), the YAML files that describe the software of an embedded application. Name Conventions Filename Extensions The csolution Project Manager recognizes the categories of files based on the filename extension in the YAML input files as shown in the table below. File Extension Category Description .c , .C sourceC C source file .cpp , .c++ , .C++ , .cxx , .cc , .CC sourceCpp C++ source file .h , .hpp header Header file .asm , .s , .S sourceAsm Assembly source file .ld , .scf , .sct , .icf linkerScript Linker Script file .a , .lib library Library file .o object Object file .txt , .md , .pdf , .htm , .html doc Documentation .scvd other Software Component View Description for CMSIS-View pack: Name Conventions The csolution Project Manager uses the following syntax to specify the pack: names in the *.yml files. vendor::pack-name # Use the latest version of the pack vendor::pack-name@version # With exact version vendor::pack-name@>=version # With version equal or higher vendor::pack-name@^version # With version equal or higher but the same major version vendor::pack-name@~version # With version equal or higher but the same major and minor version Element Description vendor Required Vendor name of the software pack. pack-name Required Name of the software pack; wildcards (*, ?) can be used. @version Optional Software pack version number must exactly match, i.e. @1.2.3 @>=version Optional Automatically update to any version higher or equal. @^version Optional Automatically update minor/patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 2.0.0 . @~version Optional Automatically update patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 1.3.0 . Notes When no version is specified, the csolution Project Manager only loads the latest installed version of a software pack. This also applies when wildcards are used in the pack-name . Use cpackget to download and install new pack versions. To accept a pre-release version of a pack specify the -pre-release label. Use for example - pack: Keil::MDK-Middleware@^8.0.0-0 to accept any pre-release version that is higher or equal. Examples: - pack: ARM::CMSIS@5.9.0 # 'CMSIS' Pack with version 5.5.0 - pack: Keil::MDK-Middleware@>=7.13.0 # latest version 7.13.0 or higher - pack: Keil::MDK-Middleware@^7.13.0 # latest version 7.13.0 or higher, but lower than 8.0.0 - pack: Keil::TFM # 'TFM' Pack from vendor Keil, latest installed version - pack: AWS # All Software Packs from vendor 'AWS', latest version - pack: Keil::STM* # Software Packs that start with 'STM' from vendor 'Keil' - pack: Keil::MDK-Middleware@>=8.0.0-0 # version 8.0.0 or higher including pre-release versions component: Name Conventions The csolution Project Manager uses the following syntax to specify the component: names in the *.yml files. [Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[>=]Cversion] Components are defined using the Open-CMSIS-Pack - <component> element . Several parts of a component are optional. For example, it is possible to just define a component using the Cclass and Cgroup names. All elements of a component name are summarized in the following table. Element Description Cvendor Optional Name of the component vendor as defined in <components> element or by the package vendor of the software pack. Cclass Required Component class name as defined in <components> element of the software pack. Cbundle Optional Bundle name of the component class as defined in <bundle> element of the software pack. Cgroup Required Component group name as defined in <components> element of the software pack. Csub Optional Component sub-group name as defined in <components> element of the software pack. Cvariant Optional Component sub-group name as defined in <components> element of the software pack. Cversion Optional Version number of the component, with @1.2.3 that must exactly match, or @>=1.2.3 that allows any version higher or equal. Partly defined components A component can be partly defined in csolution project files ( *.cproject.yml , *.clayer.yml , *.genlayer.yml ) by omitting Cvendor , Cvariant , and Cversion , even when this are part of the components element of the software pack. The component select algorithm resolves this to a fully defined component by: when a partly specified component resolves to several possible choices, the tool selects: (a) the default Cvariant of the component as defined in the PDSC file. (b) the component with the higher Cversion value. (c) an error message is issued when two identical components are defined by multiple vendors and Cvendor is not specified. the partly specified component is extended by: version information from the software pack. default variant definition from the software pack. The fully resolved component name is shown in the *.cbuild.yml output file. Note Before CMSIS-Toolbox 2.7, a component that omitted Csub resolved to the first matching component. Installing additional software packs could change therefore component selection. When a component is defined with Csub it is now required to specify. Multiple component definitions are rejected If a component is added more than once in the csolution project files and an error is issued. An attempt to select multiple variants (using Cvariant ) of a component results in an error . Examples: - component: CMSIS:CORE # CMSIS Core component (vendor selected by `csolution` ARM) - component: ARM::CMSIS:CORE # CMSIS Core component from vendor ARM (any version) - component: ARM::CMSIS:CORE@5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0) - component: ARM::CMSIS:CORE@>=5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0 or higher) - component: Device:Startup # Device Startup component from any vendor - component: CMSIS:RTOS2:Keil RTX5 # CMSIS RTOS2 Keil RTX5 component with default variant (any version) - component: ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3 # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3 - component: Keil::USB&MDK-Pro:CORE&Release@6.15.1 # USB CORE component from bundle MDK-Pro in variant 'Release' and version 6.15.1 device: Name Conventions The device specifies multiple attributes about the target that range from the processor architecture to Flash algorithms used for device programming. The following syntax is used to specify a device: value in the *.yml files. [ [ Dvendor:: ] Dname] [:Pname] Element Description Dvendor Optional Name (without enum field) of the device vendor-defined in <devices><family> element of the software pack. Dname Optional Device name (Dname attribute) or, when used, the variant name (Dvariant attribute) as defined in the \\<devices> element. Pname Optional Processor identifier (Pname attribute) as defined in the <devices> element. Note All elements of a device name are optional, which allows to supply of additional information, such as the :Pname at different stages of the project. However, the Dname itself is a mandatory element and must be specified in the context of the various project files. Dvendor:: must be used in combination with the Dname . Examples: device: NXP::LPC1768 # The LPC1788 device from NXP device: LPC1788 # The LPC1788 device (vendor is evaluated from DFP) device: LPC55S69JEV98 # Device name (exact name as defined in the DFP) device: LPC55S69JEV98:cm33_core0 # Device name (exact name as defined in the DFP) with Pname specified device: :cm33_core0 # Pname added to a previously defined device name (or a device derived from a board) board: Name Conventions Evaluation Boards define a device indirectly via the related BSP. The following syntax is used to specify a board: value in the *.yml files. [vendor::] board_name [:revision] Element Description vendor Optional Name of the board vendor-defined in <boards><board> element of the board support pack (BSP). Bname Required Board name (name attribute) as defined in the \\<board> element of the BSP. revision Optional Board revision (revision attribute) as defined in the \\<board> element of the BSP. Note When a board: is specified, the device: specification can be omitted, however it is possible to overwrite the device setting in the BSP with an explicit device: setting. Examples: board: Keil::MCB54110 # The Keil MCB54110 board (with device NXP::LPC54114J256BD64) board: LPCXpresso55S28 # The LPCXpresso55S28 board board: STMicroelectronics::NUCLEO-L476RG:Rev.C # A board with revision specification context: Name Conventions A context: name combines project-name , built-type , and target-type and is used in various places in the CMSIS-Toolbox. The following syntax is used to specify a context: name. [project-name][.build-type][+target-type] Element Description project-name Optional Project name of a project (base name of the *.cproject.yml file). .build-type Optional The build-type name that is currently processed (specified with - type: name ). +target-type Optional The target-type name that is currently processed (specified with - type: name ). Note The .build-type and +target-type names allow letters (A-Z, a-z), digits (0-9), dash ('-'), and underscore ('_'); the maximum length is 32 characters. When project-name is omitted, the project-name is the base name of the *.cproject.yml file. When .build-type is omitted, it matches with any possible .build-type . When +target-type is omitted, it matches with any possible +target-type . By default, the specified - type: name of build-types: and target-types: nodes in the *.csolution.yml file are directly mapped to the context name. Using the context-map: node, it is possible to assign a different .build-type and/or +target-type mapping for a specific project-name . Example: Show the different possible context settings of a *.csolution.yml file. AWS_MQTT_MutualAuth_SW_Framework>csolution list contexts -s Demo.csolution.yml Demo.Debug+AVH Demo.Debug+IP-Stack Demo.Debug+WiFi Demo.Release+AVH Demo.Release+IP-Stack Demo.Release+WiFi The context name is also used in for-context: and not-for-context: nodes that allow to include or exclude items depending on the context . In many cases, the project-name can be omitted as the context name is within a specific *.cproject.yml file or applied to a specific *.cproject.yml file. Access Sequences The access sequences export values from the CMSIS Project Manager for the *.yml file nodes define: , define-asm: , add-path: , misc: , files: , executes: , and variables: . The access sequences can specify a different project and describe, therefore, project dependencies. Note variables: that are defined in the *.csolution.yml file can be accessed also using the $<key>$ notation. Access Sequence Description Target Access to target and build related settings $Bname$ Bname of the selected board as specified in the board: node. $Dname$ Dname of the selected device as specified in the device: node. $Pname$ Pname of the selected device as specified in the device: node. $BuildType$ Build-type name of the currently processed project. $TargetType$ Target-type name of the currently processed project. $Compiler$ Compiler name of the compiler used in this project context as specified in the compiler: node. YML Input Access to YML Input Directories and Files $Solution$ Solution name (base name of the *.csolution.yml file). $SolutionDir()$ Path to the directory of the current processed csolution.yml file. $Project$ Project name of the current processed cproject.yml file. $ProjectDir(context)$ Path to the directory of a related cproject.yml file. Output Access to Output Directories and Files $OutDir(context)$ Path to the output directory of a related project that is defined in the *.csolution.yml file. $bin(context)$ Path and filename of the binary output file generated by the related context. $cmse-lib(context)$ Path and filename of the object file with secure gateways of a TrustZone application generated by the related context. $elf(context)$ Path and filename of the ELF/DWARF output file generated by the related context. $hex(context)$ Path and filename of the HEX output file generated by the related context. $lib(context)$ Path and filename of the library file of the related context. Pack Access to Pack Directories and Files $Bpack$ Path to the pack that defines the selected board (BSP). $Dpack$ Path to the pack that defines the selected device (DFP). $Pack(vendor::name)$ Path to a specific pack. Example: $Pack(NXP::K32L3A60_DFP)$ . For a context , the project-name , .build-type , and +target-type are optional. An access sequence that specifies only project-name uses the context that is currently processed. It is important that the project is part of the selected build variant in the build process. Example: $ProjectDir()$ is the directory of the current processed cproject.yml file. Example: This example uses the following build-type , target-type , and projects definitions. solution: target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q # specifies board target-set: - set: - project-context: TFM.Debug - project-context: MQTT_AWS.Debug - type: Production-HW # target-type: Production-HW device: STM32L5X # specifies device target-set: - set: - project-context: TFM.Release - project-context: MQTT_AWS.Debug build-types: - type: Debug # build-type: Debug optimize: none debug: on - type: Release # build-type: Release optimize: size projects: - project: ./bootloader/Bootloader.cproject.yml # relative path - project: /MyDevelopmentTree/security/TFM.cproject.yml # absolute path - project: ./application/MQTT_AWS.cproject.yml # relative path The project: /application/MQTT_AWS.cproject.yml may use access sequences to reference files or directories in other projects that belong to the same csolution project . For example, these references are possible in the file MQTT_AWS.cproject.yml . files: - file: $cmse-lib(TFM)$ # use symbol output file of TFM Project The example above uses the build-type and target-type of the processed context for the project TFM . With a target-set you may mix different build-types for an application. Note that it is important to build both projects using the same build process, for example by specifying the option --active to select a build variant . cbuild iot-product.csolution.yml --active Production-HW The example below uses from the TFM project always build-type: Debug and the target-type: Production-HW . files: - file: `$cmse-lib(TFM.Release+Production-HW)$` # use symbol output file of TFM Project The example below uses the build-type: Debug and the target-type of the current processed context is used. executes: - execute: GenImage run: gen_image %input% -o %output% input: - $elf(TFM.Debug)$ - $elf(Bootloader.Release)$ output: - $OutDir(TFM.Debug)$ The example below creates a define that uses the device name. groups: - group: \"Main File Group\" define: - $Dname$ # Generate a #define 'device-name' for this file group Order of List Nodes The key / value pairs in a list node can be in any order. The two following list nodes are logically identical. This might be confusing for yml files that are generated by an IDE. build-types: - type: Release # build-type name optimize: size # optimize for size debug: off # generate no debug information for the release build build-types: - debug: off # generate no debug information for the release build optimize: size # optimize for size type: Release # build-type name Project File Structure The table below explains the top-level elements in each of the different *.yml input files that define the overall application. Keyword Description default: Start of cdefault.yml file that is used to setup the compiler along with some compiler-specific controls. solution: Start of *.csolution.yml file that collects related projects along with build-types: and target-types: . project: Start of *.cproject.yml file that defines files, components, and layers which can be independently translated to a binary image or library. layer: Start of *.clayer.yml file that contains pre-configured software components along with source files. cdefault: When cdefault: is specified in the *.csolution.yml file, the csolution Project Manager uses a file with the name cdefault.yml to setup the compiler with specific default controls. The search order for this file is: A cdefault.yml file in the same directory as the <solution-name>.csolution.yml file. A cdefault.yml file in the directory <cmsis-toolbox-installation-dir>/etc . The default: node is the start of a cdefault.yml file and contains the following. default: Content misc: Optional Literal tool-specific controls. Refer to CSolution Project Structure - cdefault.yml for an example. Note The compiler: selection in cdefault.yml has been deprecated in CMSIS-Toolbox 2.6.0. solution: The solution: node is the start of a *.csolution.yml file that collects related projects as described in the section \"Configure Related Projects\" . solution: Content created-by: Optional Identifies the tool that created this solution. created-for: Optional Specifies the tool for building this solution, i.e. CMSIS-Toolbox@2.5.0 description: Optional Brief description text of this solution. select-compiler: Optional Lists the possible compiler selection that this project is tested with. cdefault: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. compiler: Optional Overall toolchain selection for this solution. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. output-dirs: Optional Control the output directories for the build output. generators: Optional Control the directory structure for generator output. packs: Optional Defines local packs and/or scope of packs that are used. target-types: Required List of target-types that define the target system (device or board). build-types: Optional List of build-types (i.e. Release, Debug, Test). projects: Required List of projects that belong to the solution. executes: Optional Additional pre or post build steps using external tools. misc: Optional Literal tool-specific controls. Example: solution: created-for: cmsis-toolbox@2.6 # minimum CMSIS-Toolbox version required for project build cdefault: # use default setup of toolchain-specific controls. compiler: GCC # overwrite compiler definition in 'cdefaults.yml' packs: - pack: ST # add ST packs in 'cdefaults.yml' build-types: # additional build types - type: Test # build-type: Test optimize: none debug: on packs: # with explicit pack specification - pack: ST::TestSW path: ./MyDev/TestSW target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device projects: - project: ./blinky/Bootloader.cproject.yml - project: /security/TFM.cproject.yml - project: /application/MQTT_AWS.cproject.yml project: The project: node is the start of a *.cproject.yml file and can contain the following: project: Content description: Optional Brief description text of this project. output: Optional Configure the generated output files. generators: Optional Control the directory structure for generator output. rte: Optional Control the directory structure for RTE (run-time environment) files. packs: Optional Defines packs that are required for this project. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. linker: Optional Instructions for the linker. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Specify processor core. processor: Optional Processor specific settings. setups: Optional Configurations specific to a compiler, target-type, and/or built-type. groups: Required List of source file groups along with source files. components: Optional List of software components used. layers: Optional List of software layers that belong to the project. connections: Optional List of consumed and provided resources. executes: Optional Additional pre or post build steps using external tools. Example: project: misc: - compiler: AC6 # specify misc controls for Arm Compiler 6 C: [-fshort-enums, -fshort-wchar] # set options for C files add-path: - $OutDir(Secure)$ # add the path to the secure project's output directory components: - component: Startup # Add startup component - component: CMSIS CORE - component: Keil RTX5 Library_NS groups: - group: Non-secure Code # Create group files: - file: main_ns.c # Add files to group - file: $Source(Secure)$interface.h - file: $Output(Secure)$_CMSE_Lib.o layer: The layer: node is the start of a *.clayer.yml file and defines a Software Layer . It can contain the following nodes: layer: Content type: Optional Layer type for combining layers; used to identify compatible layers . description: Optional Brief description text of the layer. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Specify processor core. generators: Optional Control the directory structure for generator output. packs: Optional Defines packs that are required for this layer. for-device: Optional Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Optional Board information, used for consistency check (board selection is in *.csolution.yml ). connections: Optional List of consumed and provided resources. processor: Optional Processor specific settings. linker: Optional Instructions for the linker. groups: Optional List of source file groups along with source files. components: Optional List of software components used. Example: layer: type: Board description: Setup with Ethernet and WiFi interface processor: trustzone: secure # set processor to secure components: - component: Startup - component: CMSIS CORE groups: - group: Secure Code files: - file: main_s.c - group: CMSE files: - file: interface.c - file: interface.h - file: tz_context.c Directory Control The following nodes control the application's directory structure. output-dirs: Allows control of the directory structure for building output files and temporary files. Notes This control is only possible at csolution.yml level. CMake manages the temporary directory of all projects therefore tmpdir: does not support access sequences. output-dirs: Content outdir: Optional Specifies the directory for the build output files (ELF, binary, MAP files). tmpdir: Optional Specifies the directory for the interim temporary files. intdir: Optional Legacy node, applied instead of tmpdir: when using cbuild with option --cbuildgen . The default setting for the output-dirs: are: tmpdir: tmp # All projects use the same temporary directory outdir: $SolutionDir()$/out/$TargetType$/$BuildType$ With the tool option --output an prefix top-level directory can be added. The effective outdir: with the command below is: MyOut/out/$TargetType$/$BuildType$ . cbuild <name>.csolution.yml --output MyOut Example: output-dirs: tmpdir: ./tmp2 # relative path to csolution.yml file outdir: ./out/$Project$/$TargetType$ # $BuildType$ no longer part of the outdir generators: Allows control of the directory structure for generator output files. When no explicit generators: is specified, the csolution Project Manager uses as path: The workingDir defined in the generators element of the PDSC file. When no workingDir is defined the default directory $ProjectDir()$/generated/<generator-id> is used; <generator-id> is defined by the id in the generators element of the PDSC file. The generators: node can be added at various levels of the *.yml input files. The following order is used: Use generators: specification of the *.clayer.yml input file, if not exist: Use generators: specification of the *.cproject.yml input file, if not exist: Use generators: specification of the *.csolution.yml input file. Notes Only relative paths are permitted to support the portability of projects. The location of the *.yml file that contains the generators: node is the reference for relative paths. generators: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/generated . options: Optional Specific generator options; allows explicit directory configuration for a generator. Note The base directory is extended for each generator with /<generator-id> ; <generator-id> is defined by the id in the generator element of the PDSC file. generators: options: options: Content - generator: Optional Identifier of the generator tool, specified with id in the generators element of the PDSC file. path: Optional Specifies the directory for generated files. Relative paths used the location of the *.cproject.yml or *.clayer.yml file as the base directory. name: Optional Specifies the base name of the generator import file (added in CMSIS-Toolbox 2.4.0); typically used for a board layer. map: Optional Mapping of the csolution project to a generator-specific run-time context name (added in CMSIS-Toolbox 2.4.0). Example: generators: base-dir: $SolutionDir()$/MyGenerators # Path for all generators extended by '/<generator-id>' options: - generator: CubeMX # for the generator id `CubeMX` use this path path: ./CubeFiles # relative path to generated files and the generator import file name: MyConf # results in generator import file ./CubeFiles/MyConf.cgen.yml map: Boot # Map this project part to the CubeMX run-time context Boot rte: Allows to control the directory structure for RTE (run-time environment) files. Notes This control is only possible at *.cproject.yml level. Only relative paths are permitted to support the portability of projects. The location of the *.cproject.yml file is the reference for relative paths. rte: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/RTE . rte: base-dir: $TargetType$/RTE # Path extended with target-type, results in `$ProjectDir()$/$TargetType$/RTE` Toolchain Options Toolchain options may be used at various places, such as: solution: level to specify options for a collection of related projects. project: level to specify options for a project. select-compiler: Lists the compilers that this csolution project is tested with. This information is used by the cbuild setup command to determine possible compiler choices. The actual compiler to be used is selected with the compiler: node. Notes select-compiler: is only supported in the *.csolution.yml project file. This control is new in CMSIS-Toolbox 2.5.0 select-compiler: Content - compiler: Required Specifies a supported compiler. Example: solution: created-for: cmsis-toolbox@2.5 # minimum CMSIS-Toolbox version required for project build select-compiler: # list tested compilers that can be selected - compiler: GCC # GCC is supported - compiler: AC6@6.22 # AC6 is supported, version number is a hint on what was tested compiler: Selects the compiler toolchain used for code generation. It can be applied in *.csolution.yml files. Optionally the compiler can have a version number specification. Compiler Name Supported Compiler AC6 Arm Compiler version 6 GCC GCC Compiler IAR IAR Compiler CLANG CLANG Compiler based on LLVM technology Example: compiler: GCC # Select GCC Compiler compiler: AC6@6.18.0 # Select Arm Compiler version 6.18.0 linker: The linker: node specifies an explicit Linker Script and/or memory regions header file. It can be applied in *.cproject.yml and *.clayer.yml files. Refer to Linker Script Management for detailed information. linker: Content - regions: Optional Path and file name of <regions_file>.h , used to generate a Linker Script. script: Optional Explicit file name of the Linker Script, overrules files provided with file: or components. auto: Optional Request automatic Linker Script generation . define: Optional Define symbol settings for the linker script file preprocessor. for-compiler: Optional Include Linker Script for the specified toolchain. for-context: Optional Include Linker Script for a list of build and target type names. not-for-context: Optional Exclude Linker Script for a list of build and target type names. Notes The linker: node must have at least regions: , script: , auto: , or define: . If no script: file is specified, compiler-specific Linker Script template files are used. A Linker Script file is preprocessed when regions: or a define: is or the file extension is *.src . If both auto: and script: is specified, a warning is issued, and automatic Linker Script generation is performed, and the specified script: is ignored. Examples: linker: - script: MyLinker.scf.src # linker script file regions: MyRegions.h # pre-processed using header file linker: - regions: MyRegions.h # Default linker script is used and pre-processed using header file linker: - script: MyLinker.scf.src # linker script file, not pre-processed for-compiler: AC6 # for Arm Compiler 6 - script: MyLinker.ld # linker script file, not pre-processed for-compiler: CLANG # for CLANG LLVM-based compiler linker: - script: MyLinker.scf.src # linker script file for-compiler: AC6 # for Arm Compiler 6 regions: MyRegions.h # pre-processed using header file - script: MyLinker.ld.src # linker script file for-compiler: CLANG # for CLANG LLVM-based compiler regions: MyRegions.h # pre-processed using header file define: # with define setting - Setup: 1 # define with value output: Configure the generated output files. output: Content base-name: Optional Specify a common base name for all output files. type: Optional A list of output types for code generation (see list below). type: Description - lib Library or archive. Note: GCC uses the prefix lib in the base name for archive files. - elf Executable in ELF format. The file extension is toolchain-specific. - hex Intel HEX file in HEX-386 format. - bin Binary image. - map Linker MAP file. The default setting for output: is: output: base-name: $Project$ # used the base name of the `cproject.yml` file. type: elf # Generate executable file. Example: output: type: - elf # Generate executable file. - map # Generate Linker MAP file. output: # configure output files. base-name: MyProject # used for all output files, including linker map file. type: - elf # Generate executable file. - hex # generate a HEX file. - bin # generate a BIN file. Generate a library : output: # configure output files. type: lib # Generate library file. Translation Control The following translation control options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project groups: level to specify options for a specify source file group files: level to specify options for a specify source file Note The keys define: , define-asm: , add-path: , add-path-asm: , del-path: , and misc: are additive. All other keys can only be defined once at the level of solution: , project: , setup: , layer: and build-types: . or target-types: . However, it is possible to overwrite these keys at the level of group: , file: , or component: ; for example it is possible to translate a file group with a different optimize level. language-C: Set the language standard for C source file compilation. Value Select C Language Standard c90 compile C source files as defined in C90 standard (ISO/IEC 9899:1990). gnu90 same as c90 but with additional GNU extensions. c99 (default) compile C source files as defined in C99 standard (ISO/IEC 9899:1999). gnu99 same as c99 but with additional GNU extensions. c11 compile C source files as defined in C11 standard (ISO/IEC 9899:2011). gnu11 same as c11 but with additional GNU extensions. c17 compile C source files as defined in C17 standard (ISO/IEC 9899:2017). Experimental compiler feature new in CMSIS-Toolbox 2.6.0. c23 compile C source files as defined in C23 standard (ISO/IEC 9899:2023). Experimental compiler feature new in CMSIS-Toolbox 2.6.0. language-CPP: Set the language standard for C++ source file compilation. Value Select C++ Language Standard c++98 compile C++ source files as defined in C++98 standard (ISO/IEC 14882:1998). gnu++98 same as c++98 but with additional GNU extensions. c++03 compile C++ source files as defined in C++03 standard (ISO/IEC 14882:2003). gnu++03 same as c++03 but with additional GNU extensions. c++11 compile C++ source files as defined in C++11 standard (ISO/IEC 14882:2011). gnu++11 same as c++11 but with additional GNU extensions. c++14 (default) compile C++ source files as defined in C++14 standard (ISO/IEC 14882:2014). gnu++14 same as c++14 but with additional GNU extensions. c++17 compile C++ source files as defined in C++17 standard (ISO/IEC 14882:2014). gnu++17 same as c++17 but with additional GNU extensions. c++20 compile C++ source files as defined in C++20 standard (ISO/IEC 14882:2020). gnu++20 same as c++20 but with additional GNU extensions. c++23 compile C++ source files as defined in C++23 standard (ISO/IEC 14882:2023). gnu++23 same as c++23 but with additional GNU extensions. optimize: Generic optimize levels for code generation. Value Code Generation balanced Balanced optimization size Optimize for code size speed Optimize for execution speed debug Optimize for debug experience none No optimization Note When optimize: is not specified, the default optimize setting of the compiler is used. Example: groups: - group: \"Main File Group\" optimize: none # optimize this file group for debug illusion files: - file: file1a.c - file: file1b.c link-time-optimize: When applied, the link-time optimization is enabled. It enables global optimizations across multiple translation units at the linker stage which typically further improves performance and reduces code size. Example: groups: - group: \"Main File Group\" optimize: speed # optimize for execution speed link-time-optimize: # enable link-time optimization for this file group files: - file: file1a.c - file: file1b.c Note This feature is not available with the IAR compiler. debug: Control the generation of debug information. Value Code Generation on Generate debug information (default) off Generate no debug information Example: build-types: - type: Release optimize: size # optimize for size debug: off # generate no debug information for the release build warnings: Control warning level for compiler diagnostics. Value Control diagnostic messages (warnings) on Generate warning messages all Enable all compiler warning messages (compiler option -Wall) off No warning messages generated define: Contains a list of symbol #define statements that are passed via the command line to the development tools for C, C++ source files, or the linker script file preprocessor. define: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Note This control only applies to C and C++ source files (or to the linker script preprocessor). For assembler source files use the define-asm: node. Example: define: # Start a list of define statements - TestValue: 12 # add symbol 'TestValue' with value 12 - TestMode # add symbol 'TestMode' define-asm: Contains a list of symbol #define statements that are passed via the command line to the development tools for Assembler source files. define-asm: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Example: define-asm: # Start a list of define statements for Assembler source code - AsmValue: 12 # add symbol 'AsmValue' with value 12 undefine: Remove symbol #define statements from the command line of the development tools. undefine: Content - <symbol-name> Remove #define symbol Examples: groups: - group: \"Main File Group\" undefine: - TestValue # remove define symbol `TestValue` for this file group files: - file: file1a.c undefine: - TestMode # remove define symbol `TestMode` for this file - file: file1b.c add-path: Add include paths to the command line of the development tools for C and C++ source files. add-path: Content - <path-name> Named path to be added Note This control only applies to C and C++ source files. For assembler source files, use the add-path-asm: node. Example: project: misc: - for-compiler: AC6 C: [-fshort-enums, -fshort-wchar] - for-compiler: GCC C: [-fshort-enums, -fshort-wchar] add-path: - $OutDir(Secure)$ # add path to secure the project's output directory add-path-asm: Add include paths to the command line of the development tools for assembly source files. add-path-asm: Content - <path-name> Named path to be added Note This control only applies to assembler source files. For C and C++ source files use the add-path: node. Example: project: add-path-asm: - .\\MyAsmIncludes # add path to assembler include files secure project's output directory del-path: Remove include paths (that are defined at the cproject level) from the command line of the development tools. del-paths: Content - <path-name> Named path to be removed; * for all Example: target-types: - type: CM3 device: ARMCM3 del-paths: - /path/solution/to-be-removed misc: Add miscellaneous literal tool-specific controls that are directly passed to the individual tools depending on the file type. misc: Content - for-compiler: Optional Name of the toolchain that the literal control string applies to. C-CPP: Optional Applies to *.c and *.cpp files (added before C and CPP: ). C: Optional Applies to *.c files only. CPP: Optional Applies to *.cpp files only. ASM: Optional Applies to assembler source files only. Link: Optional Applies to the linker (added before Link-C: or Link-CPP: ). Link-C: Optional Applies to the linker; added when no C++ files are part of the project. Link-CPP: Optional Applies to the linker; added when C++ files are part of the project. Library: Optional Set libraries to the correct position in the linker command line (for GCC). Example: build-types: - type: Debug misc: - for-compiler: AC6 C-CPP: - -O1 - -g - for-compiler: GCC C-CPP: - -Og - type: Release compiler: AC6 misc: - C: - -O3 - type: GCC-LibDebug compiler: GCC misc: - Library: - -lm - -lc - -lgcc - -lnosys Project Setups The setups: node can be used to create setups specific to a compiler, target type, and/or built type. setups: The setups: node collects a list of setup: notes. Only one setup will be selected for each context. The result is a setup: that collects various toolchain options, and that is valid for all files and components in the project. It is, however, possible to change that setup: settings on a group: or file: level. setups: Content - setup: Required Description of the setup for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. output: Optional Configure the generated output files. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. linker: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. processor: Optional Processor configuration. project: setups: - setup: Arm Compiler 6 project setup for-compiler: AC6 linker: - script: my-project.sct define: - test: 12 - setup: GCC project setup for-compiler: GCC linker: - script: my-project.inc define: - test: 11 Pack Selection The packs: node can be specified in the *.csolution.yml file allows you to: Reduce the scope of software packs that are available for projects. Add specific software packs that are optional with version specifications. Provide a path to a local installation of a software pack that is, for example, project-specific or under development. The Pack Name Conventions specify the names of the software packs. The pack: definition may be specific to a context that specifies target-types: and/or build-types: or provides a local path to a development repository of a software pack. Notes By default, the csolution Project Manager only loads the latest version of the installed software packs. It is, however, possible to request specific versions using the - pack: node. An attempt to add two different versions of the same software pack results in an error. packs: The packs: node is the start of a pack selection. packs: Content - pack: Explicit pack specification (additive) pack: The pack: list allows to add specific software packs , optional with a version specification. pack: Content path: Explicit path name that stores the software pack. This can be a relative path to your project workspace. for-context: Include pack for a list of build and target types. not-for-context: Exclude pack for a list of build and target types. Note When an explicit path: to the pack is specified, an explicit pack version cannot be specified as the path directly specifies the pack to include. Example: packs: # start section that specifics software packs - pack: AWS # use packs from AWS - pack: NXP::*K32L* # use packs from NXP relating to K32L series (would match K32L3A60_DFP + FRDM-K32L3A6_BSP) - pack: ARM # use packs from Arm - pack: Keil::Arm_Compiler # add latest version of Keil::Arm_Compiler pack - pack: Keil::MDK-Middleware@7.13.0 # add Keil::MDK-Middleware pack at version 7.13.0 - pack: ARM::CMSIS-FreeRTOS@~10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 10.5.0 - pack: ARM::CMSIS-FreeRTOS@^10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 11.0.0 - pack: NXP::K32L3A60_DFP # add pack for NXP device ftar path: ./local/NXP/K32L3A60_DFP # with path to the pack (local copy, repo, etc.) - pack: AWS::coreHTTP # add pack path: ./development/AWS/coreHTTP # with path to development source directory for-context: +DevTest # pack is only used for target-type \"DevTest\" Target Selection board: Specifies a unique board name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. device: Specifies a unique device name , optionally with the vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. A device: is derived from the board: setting, but an explicit device: setting overrules the board: device. If device: specifies a device with a multi-core processor, and no explicit pname for the processor core selection is specified, the default pname of the device is used. At the level of a cproject.yml file, only the pname can be specified as the device itself is selected at the level of a csolution.yml file. Example: The following assumes that the csolution is based on NXP's K32L3A60VPJ1A which has two pnames : cm4 and cm0plus . Here are the corresponding entries in the *.cproject.yml files: CM4.cproject.yml: project: device: :cm4 CM0Plus.cproject.yml: project: device: :cm0plus Processor Attributes processor: The processor: keyword specifies the processor features used in this project. processor: Content fpu: Select usage of FPU instructions: dp (double precision) | sp (single precision) | off (disabled). dsp: Select usage of SIMD instructions: on (enabled) | off (disabled). mve: Select usage of M-Profile vector extension: fp (floating point and integer instructions) | int (integer instructions) | off (disabled). trustzone: Select TrustZone mode: secure | secure-only | non-secure | off . branch-protection: Select Branch Protection mode: bti (branch target identification) | bti-signret (branch target identification and pointer authentication) | off (disabled). The default setting enables the available features of the device. For example fpu: dp is selected for devices that offer double precision floating point hardware. For trustzone: the possible settings are: trustzone: Description off TrustZone disabled, classic Cortex-M programmers model. Default for devices with configurable TrustZone feature. non-secure Non-secure mode. Default for devices with enabled TrustZone feature. secure Secure mode with veneers for non-secure calls. Related options to generate cmse library are enabled. secure-only Secure mode without veneers for non-secure calls. No cmse library generated (new in CMSIS-Toolbox 2.6.0). Example: project: processor: trustzone: secure fpu: off # do not use FPU instructions mve: off # do not use vector instructions. Context A context is an environment setup for a project that is composed of: project-name that is the base name of the *.cproject.yml file. .build-type that defines typically build-specific settings such as for debug, release, or test. +target-type that defines typically target-specific settings such as device, board, or usage of processor features. Note The context name is used throughout the build process and is reflected in directory names. Even when there is not a fixed limit, keep identifiers short. Recommended is less than 32 characters for the context name. Blank characters (' ') in the context name are not permitted by CMake. The section \"Configure Related Projects\" explains the overall concept of target-types and build-types . These target-types and build-types are defined in the *.csolution.yml that defines the overall application for a system. The settings of the target-types: are processed first, followed by the settings of the build-types: , which potentially overwrite the target-types: settings. target-types: The target-types: node may include toolchain options , target selection , and processor attributes : target-types: Content - type: Required The target-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. board: see Note Board specification. device: see Note Device specification. processor: Optional Processor specific settings. context-map: Optional Use different target-types: for specific projects. variables: Optional Variables that can be used to define project components. memory: Optional Add additional off-chip memory available in target hardware. target-set: Optional One or more target-set configurations for projects, images, and debugger. west-defs: Optional Defines in CMake format for the west build system. Note Either device: or board: is required. build-types: The build-types: node may include toolchain options : build-types: Content - type: Required The build-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. context-map: Optional Use different build-types: for specific projects. variables: Optional Variables that can be used to define project components. west-defs: Optional Defines in CMake format for the west build system. Example: target-types: - type: Board # target-type name, used in context with: +Board board: NUCLEO-L552ZE-Q # board specifies indirectly also the device - type: Production-HW # target-type name, used in context with: +Production-HW device: STM32L552RC # specifies device build-types: - type: Debug # build-type name, used in context with: .Debug optimize: none # specifies code optimization level debug: debug # generates debug information - type: Test # build-type name, used in context with: .Test optimize: size debug: on The board: , device: , and processor: settings are used to configure the code translation for the toolchain. These settings are processed in the following order: board: relates to a BSP software pack that defines board parameters, including the mounted device . If board: is not specified, a device: must be specified. device: defines the target device. If board: is specified, the device: setting can be used to overwrite the device or specify the processor core used. processor: overwrites default settings for code generation, such as endianness, TrustZone mode, or disabling Floating Point code generation. Examples: target-types: - type: Production-HW board: NUCLEO-L552ZE-Q # hardware is similar to a board (to use related software layers) device: STM32L552RC # but uses a slightly different device processor: trustzone: off # TrustZone disabled for this project target-types: - type: Production-HW board: FRDM-K32L3A6 # NXP board with K32L3A6 device device: :cm0plus # use the Cortex-M0+ processor target-set: The target-set: specifies for a target-type: the projects and images to include along with the configuration settings for a debug adapter. It is possible to specify one or more set configurations per target-type . Refer to the section \"Configure Related Projects\" that describes how to combine multiple projects into an application. target-set: Content - set: Required Start of a configuration, optional with name. The default set is unnamed. info: Optional Brief description of the configuration. images: Optional List of images that belong to this set. debugger: Optional Debugger configuration for this set. images: The images: node under target-set: specifies the projects with build-type and optional additional images that belong to this configuration of the target set. images: Content - project-context: Optional Project output or with optional build-type to use. Format: <project_name>[.buid_type] image: Optional Additional image file to load. load: Optional Load mode of the image file for programmers and debug tools. info: Optional Brief description of the image file. type: Optional Specifies an explicit file of the image type. load-offset: Optional Offset applied when loading a image file with type: bin (pyOCD only). device: Optional For image files a pname can be specified to denote the processor that runs the image. Notes Each list node must contain either image: or project-context: (but not both). The type: specification is only accepted for an image: file. The project-context: can also refer to a west project-id: with build type. load: Specifies the load mode for an image file. This information is used by programmers and debug tools. load: Description image+symbols Load both the binary image and the debug symbol information (default for project-context and image with file type elf). symbols Load only the debug symbol information. image Load only the binary image (default image for other file types). none No content is loaded for this image, however it is part of the build process. type: With type: an explicit file type can be specified which is required for unknown file extensions. The explicit file type overwrites the auto-detection of file types based on the file extension. type: Auto-detected Extension Description - lib .lib , .a Library or archive. - elf .axf , .elf Executable in ELF format. - hex .h386 , .hex Intel HEX file in HEX-386 format. - bin .bin Binary image. Example: solution: : target-types: - type: MCXN947 board: FRDM-MCXN947 device: NXP::MCXN947VDF target-set: - set: # without id, <default> set debugger: name: ST-Link images: - project-context: core1.Debug - project-context: core0.Release - set: production # id for this target set images: - project-context: core1.Release device: :core1 # specify the pname that runs the image - project-context: core0.Release device: :core0 # specify the pname that runs the image - type: Custom-HW device: NXP::MCXN947VDF target-set: - set: # without id, <default> set debugger: name: ULINKplus protocol: swd images: - project-context: core1.Debug - project-context: core0.Release - image: Zephry.elf load: image build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./cm33_core1/core1.cproject.yml - project: ./cm33_core0/core0.cproject.yml variables: The variables: node defines key/value pairs in the *.csolution.yml file. Using $<key>$ in *.cproject.yml and *.clayer.yml files expands to the value of the variable. The variable $<key>$ can be used in the following nodes: layers: , define: , define-asm: , add-path: , add-path-asm: , misc: , files: , and executes: . The <key>: name format <type>-Layer is a convention that references layer-type . In this case the copied-from: can be used to describe the orginal source of a layer (typically a path in a software pack). variables: Description <key>: <key>: specifies a variable name with value. copied-from: Descriptive text that documents the source of a layer. Example: With variables that are defined in the *.csolution.yml file, a *.cproject.yml file requires no modifications when new target-types: are introduced. The required layers: could be instead specified in the *.csolution.yml file using a new node variables: . Example.csolution.yml solution: target-types: - type: NXP Board board: IMXRT1050-EVKB variables: - Socket-Layer: $SolutionDir()$/Socket/FreeRTOS+TCP/Socket.clayer.yml - Board-Layer: $SolutionDir()$/Board/IMXRT1050-EVKB/Board.clayer.yml - type: ST Board board: B-U585I-IOT02A variables: - Socket-Layer: $SolutionDir()$/Socket/WiFi/Socket.clayer.yml - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml copied-from: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/CMSIS/Board/ Example.cproject.yml layers: - layer: $Socket-Layer$ type: Socket - layer: $Board-Layer$ # no `*.clayer.yml` specified. Compatible layers are listed type: Board # layer of type `Board` is expected Variable west-board West Build uses a different schema for the board name . However several board names can be mapped to west tool. By default, the variable $west-board$ holds the board_name (converted to lower-case, - replaced by _ ) of the current active target type as default for the west: node. However, as some CMSIS boards names do not map, the variable $west-board$ can be defined as shown below. Example.csolution.yml solution: target-types: - type: Alif Board board: Alif Semiconductor::DevKit-E7 variables: - west-board: alif_e7_dk_rtss_he # explicit west board name - type: ST Board board: STMicroelectronics::STM32H7B3I-DK # $west-board$ set to `stm32h7b3i_dk` context-map: The context-map: node allows for a specific project-name the remapping of target-types: and/or build-types: to a different context: which enables: Integrating an existing *.cproject.yml file in a different *.csolution.yml file that uses different build-types: and/or target-types: for the overall application. Defines how different *.cproject.yml files of a *.csolution.yml are to the binary image of the final target (needs reflection in cbuild-idx.yml). The context-map: node lists a remapping of the context-name for a project-name and specific target-types: and build-types: . context-map: Content - <context-name> Required Specify an alternative context-name for a project. For the context-map: it is required to specify the <project-name> as part of the context-name . This project will use a different .build-type and/or +target-type as applied in the context-name . This remapping of the context applies for the specific type in the build-types: or target-types: list. Example 1: This application combines two projects for a multi-processor device, but the project HelloCM7 requires a different setting for the build-type name Release as this enables different settings within the *.cproject.yml file. target-types: - type: DualCore device: MyDualCoreDevice build-types: - type: Release # When applying build-type name 'release': context-map: - HelloCM7.flex_release # project HelloCM7 uses build-type name \"flex_release\" instead of \"release\" projects: - project: ./CM7/HelloCM7.cproject.yml - project: ./CM4/HelloCM4.cproject.yml Example 2: The following example uses three projects: Demo , TFM , and Boot . The project TFM should always be built using the context TFM.Release+LibMode . For the target-type name Board , the Boot project requires the +Flash target, but any build type could be used. target-types: - type: Board # When applying target-type: 'Board': context-map: - TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode - Boot+Flash # for project Boot use target-type: Flash board: B-U585I-IOT02A - type: AVH # When applying target-type: 'AVH': context-map: - context: TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode device: ARM::SSE-300-MPS3 projects: - project: ./App/Demo.cproject.yml - project: ./Security/TFM.cproject.yml - project: ./Loader/Boot.cproject.yml Conditional Build It is possible to include or exclude items of a list node in the build process. for-compiler: includes items only for a compiler toolchain. for-context: includes items only for a context list. not-for-context: excludes items for a context list. Note for-context: and not-for-context: are mutually exclusive, only one occurrence can be specified for a list node . for-compiler: Depending on a compiler toolchain it is possible to include list nodes in the build process. Examples: for-compiler: AC6@6.16 # add item for Arm Compiler version 6.16 only for-compiler: GCC # for GCC Compiler (any version) for-context: A context list that adds a list-node for specific target-type and/or build-type names. not-for-context: A context list that removes a list-node for specific target-types: and/or build-types: . Context List It is also possible to provide a context list with: - [.build-type][+target-type] - [.build-type][+target-type] Examples: for-context: - .Test # add item for build-type: Test (any target-type) for-context: # add item - .Debug # for build-type: Debug and - .Release+Production-HW # build-type: Release / target-type: Production-HW not-for-context: +Virtual # remove item for target-type: Virtual (any build-type) not-for-context: .Release+Virtual # remove item for build-type: Release with target-type: Virtual Usage The keyword for-context: and not-for-context: can be used for the following list nodes : List Node Description - project: At projects: level it is possible to control inclusion of project. - layer: At layers: level, it is possible to control the inclusion of a software layer. The keyword for-context: , not-for-context: , and for-compiler: can be applied to the following list nodes : List Node Description - component: At components: level, control the inclusion of a software component. - group: At groups: level, control the inclusion of a file group. - setup: At setups: level, define toolchain-specific options that apply to the whole project. - file: At files: level, control the inclusion of a file. The inclusion of a list node is processed with this hierarchy from top to bottom: project --> layer --> component / group --> file In other words, the restrictions specified by for-context: or not-for-context for a list node are applied to it child nodes. Child list nodes inherit the restrictions from their parent. Note With for-context: and not-for-context: the project-name of a context cannot be applied. The context name must, therefore, start with . to refer to the build-type: or + to refer to the target-type: . Regular Expressions With for-context: and not-for-context: a regular expression can be used to refer to multiple context names. When a context name starts with the character \\ the regular expression expansion is enabled. The character \\ itself is not part of the sequence. Example: The following project is only included when the build-type: of a context contains Test . build-types: - Debug-Test: # Debug build with Test functionality : - Test-Release: # Release build with Test functionality : - Debug: : - Release: : project: Test.cproject.yml - for-context: \\.*Test*` Multiple Projects The section \"Configure Related Projects\" describes the organization of multiple projects. The file *.csolution.yml describes the relationship of these projects and may also re-map target-types: and build-types: for projects using context-map: . projects: The YAML structure of the section projects: is: projects: Content - project: Optional Path to the project file. west: Optional Enable West \"build orchestration wrapper\" for Zephyr projects. for-context: Optional Include project for a list of build and target types. not-for-context: Optional Exclude project for a list of build and target types. !!! Notes: project and west nodes are mutually exclusive (ToDo) Examples: This example uses two projects that are built in parallel using the same build-type: and target-type: . Such a setup is typical for multi-processor systems. projects: - project: ./CM0/CM0.cproject.yml # include project for Cortex-M0 processor - project: ./CM4/CM4.cproject.yml # include project for Cortex-M4 processor This example uses multiple projects but with additional controls. projects: - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # build only when 'target-type: CM0-Addon' is selected - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # specify use case - project: ./Debug/Debug.cproject.yml # specify cproject.yml file not-for-context: .Release # generated for any 'build-type:' except 'Release' - west: # enable west build orchestration wrapper app-path: ./blinky # specify a zephyr application path Source File Management Keyword Used in files Description groups: *.cproject.yml , *.clayer.yml Start of a list that adds source groups and files to a project or layer. layers: *.cproject.yml Start of a list that adds software layers to a project. components: *.cproject.yml , *.clayer.yml Start of a list that adds software components to a project or layer. groups: The groups: keyword specifies a list that adds source groups and files to a project or layer: groups: Content - group: Required Name of the group. for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. groups: Optional Start a nested list of groups. files: Optional Start a list of files. Example: See files: section. files: Add source files to a project. files: Content - file: Required Name of the file. for-context: Optional Include file for a list of build and target types. not-for-context: Optional Exclude file for a list of build and target types. for-compiler: Optional Include file for a list of compilers. category: Optional Explicit file category to overwrite filename extension assignment. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. Note It is also possible to specify a Linker Script . Files with the extension .sct , .scf , .ld , and .icf are recognized as Linker Script files. Example: Add source files to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. groups: - group: \"Main File Group\" not-for-context: # includes this group not for the following: - .Release+Virtual # build-type 'Release' and target-type 'Virtual' - .Test-DSP+Virtual # build-type 'Test-DSP' and target-type 'Virtual' - +Board # target-type 'Board' files: - file: file1a.c - file: file1b.c define: - a: 1 undefine: - b optimize: size - group: \"Other File Group\" files: - file: file2a.c for-context: +Virtual # include this file only for target-type 'Virtual' define: - test: 2 - file: file2a.c not-for-context: +Virtual # include this file not for target-type 'Virtual' - file: file2b.c - group: \"Nested Group\" groups: - group: Subgroup1 files: - file: file-sub1-1.c - file: file-sub1-2.c - group: Subgroup2 files: - file: file-sub2-1.c - file: file-sub2-2.c It is also possible to include a file group for a specific compiler using for-compiler: or a specific target-type and/or build-type using for-context: or not-for-context: . groups: - group: \"Main File Group\" for-compiler: AC6 # includes this group only for Arm Compiler 6 files: - file: file1a.c - file: file2a.c - group: \"Main File Group\" for-compiler: GCC # includes this group only for GCC Compiler files: - file: file1b.c - file: file2b.c Using category: allows to specify pre-include files that are project-wide or related only to the group: . A global pre-include file is added to the compiler command line for all modules of the whole project (globally). - group: \"Main File Group\" files: - file: SystemDefinitions.h category: preIncludeGlobal A local pre-include file is added to the compiler command line for all modules of a group (locally). - group: \"Group 2\" files: - file: MyDefinitions.h category: preIncludeLocal layers: Add a software layer to a project. Used in *.cproject.yml files. layers: Content - layer: Optional Path to the *.clayer.yml file that defines the layer. type: Optional Refers to an expected layer type. for-context: Optional Include layer for a list of build and target types. not-for-context: Optional Exclude layer for a list of build and target types. Example: layers: # Socket - layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml for-context: - +IP-Stack - layer: ./Socket/WiFi/Socket.clayer.yml for-context: - +WiFi - layer: ./Socket/VSocket/Socket.clayer.yml for-context: - +AVH # Board - layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml for-context: - +IP-Stack # - +WiFi - layer: ./Board/B-U585I-IOT02A/Board.clayer.yml for-context: - +WiFi - layer: ./Board/AVH_MPS3_Corstone-300/Board.clayer.yml for-context: - +AVH layer: type: The layer: - type: is used in combination with the meta-data of the connections: to check the list of available *.clayer.yml files for matching layers. Instead of an explicit layer: node that specifies a *.clayer.yml file, the type: is used to search for matching layers with the csolution command list layers . Example: layers: - type: Socket # search for matching layers of type `Socket` - type: Board # search for matching layers of type `Board` When combined with variables: it is possible to define the required *.clayer.yml files at the level of the *.csolution.yml file. Refer to variables: for an example. components: Add software components to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. components: Content - component: Required Name of the software component. for-context: Optional Include component for a list of build and target types. not-for-context: Optional Exclude component for a list of build and target types. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. instances: Optional Add multiple instances of component configuration files (default: 1) Example: components: - component: ARM::CMSIS:RTOS2:FreeRTOS&Cortex-M - component: ARM::RTOS&FreeRTOS:Config&CMSIS RTOS2 - component: ARM::RTOS&FreeRTOS:Core&Cortex-M - component: ARM::RTOS&FreeRTOS:Event Groups - component: ARM::RTOS&FreeRTOS:Heap&Heap_5 - component: ARM::RTOS&FreeRTOS:Stream Buffer - component: ARM::RTOS&FreeRTOS:Timers - component: ARM::Security:mbed TLS define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" - component: AWS::FreeRTOS:backoffAlgorithm - component: AWS::FreeRTOS:coreMQTT - component: AWS::FreeRTOS:coreMQTT Agent - component: AWS::FreeRTOS:corePKCS11&Custom define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" Note The name format for a software component is described under Name Conventions - Component Name Conventions . instances: Allows to add multiple instances of a component and actually applies to configuration files. For detailed description refer to Open-CMSIS-Pack specification - Component Instances Example: components: - component: USB:Device instances: 2 If the user selects multiple instances of the same component, all files with the attribute config in the *.PDSC file will be copied multiple times to the project. The name of the component (for example config_mylib.h) will get a postfix _n whereby n is the instance number starting with 0. Instance 0: config_usb_device_0.h Instance 1: config_usb_device_1.h The availability of instances in a project can be made public in the RTE_Components.h file. The existing way to extend the %Instance% with the instance number n . West Build Enable the West build system integration and add Zephyr application images to the csolution project . west: Use the command west build to generate images from application source code specified in the west: node. When the west: node is applied (even with an empty app-path source directory list), the environment variables for the west build system are created based on the compiler: selection. west: Content app-path: Required Path to the application source directory. project-id: Optional Project identifier (default: last sub-dir name of app-path ). board: Optional Board name used for west build invocation (default: variable $west-board$ ). device: Optional Specify the processor core for execution of the generated image (used in *.cbuild-run.yml ). west-defs: Optional Defines in CMake format. The west-defs: from build and target-type are added. west-opt: Optional Options for the west tool (default: empty). west-defs: Defines for the west build commands are specified in CMake format. The west-defs: that are defined under the active target and build type are concatinated as follows: <west-defs> := <west:west-defs> + <target-type:west-defs> + <build-type:west-defs> The information provided with the west: and west-def: nodes are used to generate the command line for the west tool: >west <west-opt> build --board <board> --build-dir $SolutionDir()$/out/<project-id>/$TargetType$ --pristine {auto | always} <app-path> -- <west-defs> Notes The generated image files in the build directory (zephyr/zephyr.elf, zephyr/zephyr.hex) are added to the output: node in *.cbuild-run.yml . The CMSIS build system configures the environment variables for west . The --sysbuild option is not supported as the csolution project manages multiple applications and images. The cbuild orchestration instructs west calls with --pristine auto option. The cbuild option --rebuild cleans temporary files before proceeding with a new build. Examples: ToDo Pre/Post Build Steps The CMSIS-Toolbox supports pre-build and post-build steps that utilize external tools or scripts. Such external commands can be used for various tasks such as: pre-process source files. add checksums to a binary file. combine multiple ELF files into a single image. add a timestamp to an image ( always: ensures execution in every build). sign images for a bootloader. executes: Execute an external command for pre or post-build steps used in the *.csolution.yml and *.cproject.yml files. The input: and output: files are used for dependency checking and scheduling the execution (as a pre-build or post-build step) during the build process of an application (option --context is not used). Other CMake Build scripts may be integrated into the overall build process using the executes: node. Refer to Build Operation - CMake Integration for an example that utilizes a file converter for website images. The structure of the executes: node is: executes: Content - execute: Required The identifier is used as a CMake target name and must not contain spaces and special characters; recommended is less than 32 characters. run: Required Command string with the name of the program or script (optionally with path) along with argument string. always: Optional When present, the build step always runs and bypasses check for outdated output: files. input: Optional A list of input files (may contain Access Sequences ). output: Optional A list of output files (may contain Access Sequences ). for-context: Optional Run command for a list of build and target types (only supported in *.cproject.yml ). not-for-context: Optional Exclude run command for a list of build and target types (only supported in *.cproject.yml ). The run: command string uses these sequences to access input files and output files: run: command file access Description $input$ List of all input files separated by semicolon (;) character. $input(<n>)$ Input file in the list with index <n> ; first item is <n>=0 . $output$ List of all output files separated by semicolon (;) character. $output(<n>)$ Output file in the list with index <n> ; first item is <n>=0 . The run: command string also accepts these access sequences : $Bname$, $Dname$, $Pname$, $BuildType$, $TargetType$, $Compiler$, $Solution$, $Project$. It does not accept access sequences that reference directories or files as this bypasses the project dependency check . Instead use the input: list to pass files or directories. Consider the following: The execute: node is processed by the CMake build system. The order of execution depends on $input$ and $output files and is evaluated by CMake. The execute: node is processed only for an application build when no --context option is specified. The option --context-set can be used. CMake uses Linux-style path names with / characters; it does not accept the Windows-style \\ characters in the run: node to specify the location of an executable tool. CMake provides several builtin command-line tools (copy, checksum, etc.) that run on every Host OS. Consider using these command-line tools instead of Windows or Linux-specific commands. Use CMake -E help to list the available commands. The base directory for execution is not controlled by the CMSIS-Toolbox and is typically the tmp directory. The commands specified by run: should be in the path of the Host OS or the path/tool should be passed using an $input(<n>)$ argument. At the *.csolution.yml level for-context: and not-for-context: is not evaluated. Examples: The tool gen_image combines multiple input images. It is called together with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). solution: # executed as part of a complete solution build : executes: - execute: GenImage # generate final download image run: gen_image $input$ -o $output$ --sign # command string input: - $elf(Application)$ # combine these project parts - $elf(TFM)$ - $elf(Bootloader)$ output: - $SolutionDir()$/$Solution$.out # output file name The Windows batch file KeyGen.bat converts an input file keyfile.txt to a C source file. combines multiple input images. It is called together with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). project: # executed as part of a project build executes: - execute: GenerateEncryptionKeys run: $input(1)$ $input(0)$ -o $output$ always: # always generate the keyfile.c as it has a timestamp input: - $ProjectDir()$/keyfile.txt # contains the key in text format - $SolutionDir()$/KeyGen.bat output: - $ProjectDir()$/keyfile.c # output as C source file that is part of this project The built-in CMake command-line tool copy is used to copy the ELF output file. project: # executed as part of a project build executes: - execute: copy-elf run: ${CMAKE_COMMAND} -E copy $input$ $output$ input: - $elf()$ output: - $OutDir()$/Project.out for-context: .Release For examples of integrating CMake scripts, refer to Build Operation\u2014CMake Integration . Auto-select Layers To find compatible layers in software packs, projects and layers can be annotated. The command csolution list layers lists compatible layers. This enables reference applications that work across a range of different hardware targets where: The *.cproject.yml file of the reference application lists with the connections: node the required functionality with consumes: . The *.clayer.yml project part lists with the connections: node the implemented functionality with provides: . Example projects that use connections: for layer selection: MDK-Middleware examples use board layers to run on different hardware boards. Sensor SDK Example shows how board layers and shield layers may be used to run different sensor shields on many boards. [AWS_MQTT_Demo}(https://github.com/Arm-Examples/AWS_MQTT_Demo) combines the board layer and communication socket layer. Optionally a shield layer can be used to connect WiFi drivers. connections: The connections: node contains meta-data that describes the compatibility of the *.cproject.yml and *.clayer.yml project parts. The connections: node lists functionality (drivers, pins, and other software or hardware resources). The node consumes: lists required functionality; the node provides: is the implemented functionality of that project part. This works across multiple levels, which means that a *.clayer.yml file could also require other functionality using consumes: . The connections: node is used to identify compatible software layers. These software layers could be stored in CMSIS software packs using the following structure: A reference application described in a *.cproject.yml file could be provided in a git repository. This reference application uses software layers that are provided in CMSIS software packs. A CMSIS Board Support Pack (BSP) contains a configured board layer described in a *.clayer.yml file. This software layer is pre-configured for a range of use cases and provides drivers for I2C and SPI interfaces, along with pin definitions and provisions for an Arduino shield. For a sensor, a CMSIS software pack contains the sensor middleware and software layer ( *.clayer.yml ) that describes the hardware of the Arduino sensor shield. This shield can be applied to many different hardware boards that provide an Arduino shield connector. This connections: node enables therefore software reuse in multiple ways: The board layer can be used by many different reference applications, as the provided: functionality enables a wide range of use cases. The sensor hardware shield and middleware can be used across many different boards that provide an Ardunio shield connector and board layer support. The structure of the connections: node is: connections: Description - connect: Required Lists specific functionality with a brief verbal description connect: The connect: node describes one or more functionalities that belong together. connect: Description set: Optional Specifies a config-id . select value that identifies a configuration option info: Optional Verbal description displayed when this connect is selected provides: Optional List of functionality ( key / value pairs) that are provided consumes: Optional List of functionality ( key / value pairs) that are required The behaviour of the connect: node depends on the usage in csolution project files. In a cproject.yml file the connect: node is always active. In a clayer.yml file the connect: node is only active if one or more key listed under provides: is listed under consumes: in other active connect: nodes. It is also active by default if the connect: node has no provides: node. Example: In the example below the connect for: Sensor Communication Interface is only active when the SENSOR_I2C is in the consumes: list of other active connect nodes. Sensor Interrupt is only active when the SENSOR_INT is in the consumes: list of other active connect nodes. Core Functionality is always active as it does not have a provides: list. layer: type: Shield connections: - connect: Sensor Communication Interface provides: - SENSOR_I2C consumes: - ARDUINO_UNO_I2C - connect: Sensor Interrupt provides: - SENSOR_INT consumes: - ARDUINO_UNO_D2 - connect: Core Functionality consumes: - CMSIS-RTOS2 set: Some hardware boards have configuration settings (DIP switch or jumper) that configure interfaces. These settings have an impact on the functionality (for example, hardware interfaces). With set: config-id . select , the possible configuration options are considered when evaluating compatible *.cproject.yml and *.clayer.yml project parts. The csolution Project Manager iterates the connect: node with a set: config-id . select as described below: For each config-id only one connect: node with a select value is active at a time. Each possible select value is checked for a matching configuration. When project parts have a matching configuration, the set: value along with the info: is shown to the user. This allows the user to enable the correct hardware options. Refer to Example: Sensor Shield for a usage example. provides: A user-defined key / value pair list of functionality that is implemented or provided by a project: or layer: . The csolution Project Manager combines all the key / value pairs that are listed under provides: and matches them with the key / value pairs that are listed under consumes: . For key / value pairs listed under provides: the following rules exist for a match with consumes: key / value pair: It is possible to omit the value . It matches with an identical key listed in consumes: A value is interpreted as a number. Depending on the value prefix, this number must be: when consumes: value is a plain number identical to this value. when consumes: value is prefixed with + , higher or equal then this value or the sum of all values in multiple consumes: nodes. consumes: A user-defined key / value pair list of functionality that is required or consumed by a project: or layer: . For key / value pairs listed under consumed: the following rules exist: When no value is specified, it matches with any value of an identical key listed under provides: . A value is interpreted as a number. This number must be identical in the provides: value pair. A value that is prefixed with + is interpreted as a number that is added together in case that the same key is listed multiple times under consumes: . The sum of this value must be lower or equal to the value upper limit of the provides: key . Example: Board This connections: node of a board layer describes the available interfaces. The WiFi interface requires a CMSIS-RTOS2 function. connections: # describes the functionality of a board layer - connect: WiFi interface provides: - CMSIS-Driver WiFi: requires: - CMSIS-RTOS2: - connect: SPI and UART interface provides: - CMSIS-Driver SPI: - CMSIS-Driver UART: Example: Simple Project This shows the connections: node of a complete application project composed of two software layers. MyProject.cproject.yml connections: - connect: all resources provides: - RTOS2: # implements RTOS2 API interface consumes: - IoT_Socket: # requires IoT_Socket interface - STDOUT: # requires STDOUT interface - Heap: +30000 # requires an additional 30000 bytes memory heap : layers: - layer: MySocket.clayer.yml - layer: MyBoard.clayer.yml MySocket.clayer.yml connections: - connect: consumes: - RTOS2: # requires RTOS2 API interface - VSocket: # requires VSocket interface - Heap: +20000 # requires an additional 20000 bytes memory heap provides: - IoT_Socket: # provides IoT_Socket interface MyBoard.clayer.yml connections: - connect: consumes: - RTOS2: provides: - VSocket: - STDOUT: - Heap: 65536 Example: Sensor Shield This sensor shield layer provides a set of interfaces that are configurable. connections: - connect: I2C Interface 'Std' set: comm.I2C-Std info: JP1=Off JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C: - connect: I2C Interface 'Alt' set: comm.I2C-Alt info: JP1=On JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C-Alt: - connect: SPI Interface 'Alt' set: comm.SPI info: JP2=On provides: - Sensor_SPI: consumes: - Ardunio_Uno_SPI: - connect: Sensor Interrupt INT0 set: SensorIRQ.0 info: JP3=Off provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D2: - connect: Sensor Interrupt INT1 set: SensorIRQ.1 info: JP3=On provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D3: Debugger Configuration The debugger: node specified under the target-set: in the csolution project configures the debugger. Notes Packs may provide a default configuration for a debugger connection to a device or board. Serveral settings are optional and the default settings are specific to the selected debug adapter. The complete debugger settings including default values are listed in debugger: node of the *.cbuild-run.yml file . debugger: debugger: Content name: Required Identifies the debug adapter. *: Optional Other debugger specific options can be used as documented below. The command csolution list debuggers outputs the name: of the supported debug adatpers; using the option --verbose extends the list with alias names that are also accepted as name: There are five different debug adapter categories: Debug Adapter name: Description <adapter>@pyOCD Debug Adapters that interface via pyOCD ( CMSIS-DAP and ST-Link). <adapter>@Arm-Debugger Debug Adapters that interface via the Arm-Debugger. Arm-FVP FVP simulation models that represent processor sub-systems. Keil uVision uVision Debugger that is integrated in the Keil uVision IDE. J-Link Server Segger J-Link debug probes that connect using the J-Link Server. The Arm CMSIS Solution VS Code extension uses the debugger: node to create entries in the files .vscode/tasks.json and .vscode/launch.json for running and debugging using the specified debug adapter. pyOCD supports a command-line mode that uses the *.cbuild-run.yml file which is created by the CMSIS-Toolbox. The following sections describe the options available for the different debug adapter types. pyOCD This section lists the options that are specific to pyOCD that connects to CMSIS-DAP and ST-Link debug adapters. CMSIS-DAP is a standardized protocol used by many different debug adapters. All CMSIS-DAP enabled debug adapters can be accessed with name: CMSIS-DAP@pyOCD . A specific debug adapter name such as name: ULINKplus@pyOCD provides tailored default settings and a custom configuration dialog in the Arm CMSIS Solution VS Code extension. Extended options are required for rare use cases and further tailor the behaviour of pyOCD. debugger: for pyOCD debugger: Description name: Required Identifies the debug adapter with <adapter>@pyOCD . clock: Optional Debug clock speed in Hz. protocol: Optional Debug portocol (jtag or swd). dbgconf: Optional Configuration file for device settings such as trace pins and option bytes. start-pname: Optional Debugger connects at start to this processor. telnet: Optional Telnet service configuration. trace: Optional Extended Option: Trace configuration. connect: Optional Extended Option: Connect mode to hardware. reset: Optional Extended Option: Reset type configuration for various cores. load-setup: Optional Extended Option: Reset type and Halt configuration for Load command. Examples: debugger: name: CMSIS-DAP@pyOCD protocol: swd clock: 20000000 # 20 MHz debugger: name: ULINKplus protocol: jtag clock: 10000000 # 10 MHz dbgconf: MyHardware.dbgconf telnet: for pyOCD Note The telnet: feature will be implemented until Dec 2025. This section is only a preview. pyOCD allows to configure for each processor that runs a independent application an Telnet service that connects to character I/O funtions. Character I/O is supported via Semihosting or Segger RTT channel 0. The telnet: node configures: Telnet port for connecting remote tools, for example the Serial Monitor VS Code extension . Redirect the output to a file , console , port , or monitor . The setting monitor connects a telnet port to the Serial Monitor in VS Code. The default output file and location is derived from the cbuild-run.yml file and uses the extension <pname>.txt , format: <solution-name>+<target-type>.<pname>.out telnet: Description - mode: Required Redirect output: off , server , file , console , monitor . pname: Optional Identifies the processor (not requried for single core system). port: Optional Set TCP/IP port number of Telnet Server (default: 4444, 4445, ... incremented for each processor). file-in: Optional Explicit path and name of the telnet input file. Default: ./out/\\<solution-name>+\\<target-type>.\\<pname>.in file-out: Optional Explicit path and name of the telnet output file. Default: ./out/\\<solution-name>+\\<target-type>.\\<pname>.out Telnet Mode Description server Serial I/O to Telnet server port file Serial I/O to text files. Default: ./out/\\<solution-name\\>+\\<target-type\\>.\\<pname\\>.{in \\| out} console Serial output to console (Debug console in VS Code). monitor Serial I/O via TCP/IP port to VS Code Serial Monitor. off Serial I/O disabled. Note When no telnet node is applied Serial I/O to all processors is disabled. Examples: Enable Telnet service or a single core system. debugger: name: CMSIS-DAP@pyOCD protocol: swd telnet: mode: monitor # Output via TCP/IP port to VS Code Serial Monitor Enable Telnet service or a single core system. debugger: name: CMSIS-DAP@pyOCD protocol: swd telnet: mode: server debugger: name: CMSIS-DAP@pyOCD protocol: swd telnet: - pname: Core0 # enable Telnet service with default settings port: 4444 - pname: Core1 mode: console # route Telnet input/output to console - pname: Core2 mode: file # route Telnet input/output to files Arm Debugger This section lists options that are specific for the Arm Debugger. debugger: Description name: Required Identifies the debug adapter with <adapter>@Arm-Debugger . clock-armdbg Optional Debug clock speed. Possible values: auto (default), 50MHz, 33MHz, 25MHz, 20MHz, 10MHz, 5MHz, 2MHz, 1MHz, 500kHz, 200kHz, 100kHz, 50kHz, 20kHz, 10kHz, 5kHz protocol-armdbg Optional Debug protocol. Possible values: auto (default), JTAG, SWD Example: debugger: name: CMSIS-DAP@Arm-Debugger protocol-armdbg: SWD clock-armdbg: 5MHz Arm-FVP This section lists options that are specific to the FVP simulation models. FVPs are configureable simulation models that are designed for software validation. An FVP represents one or more Arm processors. debugger: for Arm-FVP debugger: Description name: Required Identifies the debug adapter with Arm-FVP . model: Optional Filename (optionally with path) of the FVP executable. Default: FVP_MPS2_Cortex-M3 . config-file: Optional Path and filename of the FVP configuration file . args: Optional Miscellaneous command line arguments . The following model: executables are installed from the Arm Tools Artifactory . You should use these models in combination with a pack: and device: as listed under \"CMSIS-based projects for AVH FVPs\" . The PATH environment variable of your system can define the path to the FVP executable (then only the model: name from the list below is required. Optionally an explicit path can be specified in the model: node. model: Simulation Model Represents FVP_Corstone 300 Arm Corstone 300 Reference Platform with Cortex-M55 FVP_Corstone_SSE-300_Ethos-U55 Arm Corstone 300 Reference Platform with Cortex-M55 and Ethos-U55 FVP_Corstone_SSE-300_Ethos-U65 Arm Corstone 300 Reference Platform with Cortex-M55 and Ethos-U65 FVP_Corstone 310 Arm Corstone 310 Reference Platform with Cortex-M85 and Ethos-U55. FVP_Corstone_SSE-310_Ethos-U65 Arm Corstone 310 Reference Platform with Cortex-M85 and Ethos-U65. FVP_Corstone 315 Arm Corstone 315 Reference Platform with Cortex-M85, Ethos-U65, and Mali-C55. FVP_Corstone 320 Arm Corstone 320 Reference Platform with Cortex-M85, Ethos-U85, and Mali-C55. FVP_MPS2_Cortex-M0 Arm Microcontroller Prototyping System with Cortex-M0 FVP_MPS2_Cortex-M0plus Arm Microcontroller Prototyping System with Cortex-M0+ FVP_MPS2_Cortex-M3 Arm Microcontroller Prototyping System with Cortex-M3 FVP_MPS2_Cortex-M4 Arm Microcontroller Prototyping System with Cortex-M4 FVP_MPS2_Cortex-M7 Arm Microcontroller Prototyping System with Cortex-M7 FVP_MPS2_Cortex-M23 Arm Microcontroller Prototyping System with Cortex-M23 FVP_MPS2_Cortex-M33 Arm Microcontroller Prototyping System with Cortex-M33 FVP_MPS2_Cortex-M35P Arm Microcontroller Prototyping System with Cortex-M35P FVP_MPS2_Cortex-M52 Arm Microcontroller Prototyping System with Cortex-M52 FVP_MPS2_Cortex-M55 Arm Microcontroller Prototyping System with Cortex-M55 FVP_MPS2_Cortex-M85 Arm Microcontroller Prototyping System with Cortex-M85 Example: debugger: name: CMSIS-DAP@Arm-Debugger model: FVP_Corstone_SSE-320 config-file: ./FVP_Config.txt args: --simlimit 600 # stop simulation after 600 seconds Keil uVision This section lists options that are specific for the uVision Debugger. debugger: for Keil uVision debugger: Description name: Required Identifies the debug adapter with Keil uVision . uv4: Optional Path to the uVision executable; default: C:/Keil_v5/UV4/UV4.exe . debugger: name: Keil uVision J-Link Server This section lists options that are specific for the Segger J-Link debug probes. Extended options are required for rare use cases and further tailor the behaviour of J-Link Server. debugger: for J-Link Server debugger: Description name: Required Identifies the debug adapter with <adapter>@pyOCD . clock: Optional Debug clock speed in Hz. protocol: Optional Debug portocol (jtag or swd). telnet: Optional Telnet service configuration. trace: Optional Trace configuration. connect: Optional Extended Option: Connect mode to hardware. reset: Optional Extended Option: Reset type configuration for various cores. Examples: debugger: name: J-Link Server clock: 4000000 # 4000 kHz protocol: swd telnet: for J-Link Server Note The telnet: feature will be implemented until Dec 2025. This section is only a preview. J-Link supports a Telnet service that connects to character I/O funtions. Character I/O is supported via Semihosting (or Segger RTT channel 0). Currently only semihosting is configured for the primary core. telnet: Description - mode: Required Redirect output: server , console , monitor , off (default). pname: Optional Identifies the processor (not requried for single core system). port: Optional Set TCP/IP port number of Telnet Server (default: 4444, 4445, ... incremented for each processor). Telnet Mode Description server Serial I/O to Telnet server port console Serial output to console (Debug console in VS Code). monitor Serial I/O via TCP/IP port to VS Code Serial Monitor. off Serial I/O disabled. Note The Telnet service is always enabled for the J-Link GDB Server. The mode off turns off the data source (semihosting, Segger RTT). When no telnet node is added then Serial I/O to all processors is set to mode off . trace: for J-Link Server Note The trace: feature is Work-In-Progress and will be completed in Q1'26. J-Link supports SWO Trace. trace: Description clock: Required Trace clock frequency in Hz. mode: Optional Set Trace Port transport mode. Currently only SWO-UART is accepted. port: Optional Set TCP/IP port number of Trace output (default: 4444). Add Memory Hardware targets may have additional off-chip memory. The memory: node that can be added as additional information to a target type. This information is used for the Run and Debug Management and the Automatic Linker Script generation . memory: memory: Content - name: Required Identifier of the memory. access: Required Access attribute string for the memory (see table below). start: Required Base address of the memory. size: Required Size of the memory. pname: Optional Only accessible by the specified processor. algorithm: Optional Programming algorithm for download. The table lists the letters and their meaning for use in the access attribute string. access: Description r Readable w Writable x eXecutable s Secure attribute n Non-secure attribute c non-secure Callable attribute Example: solution: : target-types: - type: MyHardware device: STMicroelectronics::STM32F746NGHx memory: # Additional memory available in MyHardware - name: Ext-Flash # Identifier access: rx # access permission start: 0x40000000 size: 0x200000 algorithm: Flash/Ext-Flash.flm # Programming algorithm","title":"CSolution Project Format"},{"location":"YML-Input-Format/#csolution-project-format","text":"The following chapter explains the CMSIS Solution Project File Format (short form csolution project files ), the YAML files that describe the software of an embedded application.","title":"CSolution Project Format"},{"location":"YML-Input-Format/#name-conventions","text":"","title":"Name Conventions"},{"location":"YML-Input-Format/#filename-extensions","text":"The csolution Project Manager recognizes the categories of files based on the filename extension in the YAML input files as shown in the table below. File Extension Category Description .c , .C sourceC C source file .cpp , .c++ , .C++ , .cxx , .cc , .CC sourceCpp C++ source file .h , .hpp header Header file .asm , .s , .S sourceAsm Assembly source file .ld , .scf , .sct , .icf linkerScript Linker Script file .a , .lib library Library file .o object Object file .txt , .md , .pdf , .htm , .html doc Documentation .scvd other Software Component View Description for CMSIS-View","title":"Filename Extensions"},{"location":"YML-Input-Format/#pack-name-conventions","text":"The csolution Project Manager uses the following syntax to specify the pack: names in the *.yml files. vendor::pack-name # Use the latest version of the pack vendor::pack-name@version # With exact version vendor::pack-name@>=version # With version equal or higher vendor::pack-name@^version # With version equal or higher but the same major version vendor::pack-name@~version # With version equal or higher but the same major and minor version Element Description vendor Required Vendor name of the software pack. pack-name Required Name of the software pack; wildcards (*, ?) can be used. @version Optional Software pack version number must exactly match, i.e. @1.2.3 @>=version Optional Automatically update to any version higher or equal. @^version Optional Automatically update minor/patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 2.0.0 . @~version Optional Automatically update patch version, i.e. @^1.2.3 uses releases from 1.2.3 to < 1.3.0 . Notes When no version is specified, the csolution Project Manager only loads the latest installed version of a software pack. This also applies when wildcards are used in the pack-name . Use cpackget to download and install new pack versions. To accept a pre-release version of a pack specify the -pre-release label. Use for example - pack: Keil::MDK-Middleware@^8.0.0-0 to accept any pre-release version that is higher or equal. Examples: - pack: ARM::CMSIS@5.9.0 # 'CMSIS' Pack with version 5.5.0 - pack: Keil::MDK-Middleware@>=7.13.0 # latest version 7.13.0 or higher - pack: Keil::MDK-Middleware@^7.13.0 # latest version 7.13.0 or higher, but lower than 8.0.0 - pack: Keil::TFM # 'TFM' Pack from vendor Keil, latest installed version - pack: AWS # All Software Packs from vendor 'AWS', latest version - pack: Keil::STM* # Software Packs that start with 'STM' from vendor 'Keil' - pack: Keil::MDK-Middleware@>=8.0.0-0 # version 8.0.0 or higher including pre-release versions","title":"pack: Name Conventions"},{"location":"YML-Input-Format/#component-name-conventions","text":"The csolution Project Manager uses the following syntax to specify the component: names in the *.yml files. [Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[>=]Cversion] Components are defined using the Open-CMSIS-Pack - <component> element . Several parts of a component are optional. For example, it is possible to just define a component using the Cclass and Cgroup names. All elements of a component name are summarized in the following table. Element Description Cvendor Optional Name of the component vendor as defined in <components> element or by the package vendor of the software pack. Cclass Required Component class name as defined in <components> element of the software pack. Cbundle Optional Bundle name of the component class as defined in <bundle> element of the software pack. Cgroup Required Component group name as defined in <components> element of the software pack. Csub Optional Component sub-group name as defined in <components> element of the software pack. Cvariant Optional Component sub-group name as defined in <components> element of the software pack. Cversion Optional Version number of the component, with @1.2.3 that must exactly match, or @>=1.2.3 that allows any version higher or equal. Partly defined components A component can be partly defined in csolution project files ( *.cproject.yml , *.clayer.yml , *.genlayer.yml ) by omitting Cvendor , Cvariant , and Cversion , even when this are part of the components element of the software pack. The component select algorithm resolves this to a fully defined component by: when a partly specified component resolves to several possible choices, the tool selects: (a) the default Cvariant of the component as defined in the PDSC file. (b) the component with the higher Cversion value. (c) an error message is issued when two identical components are defined by multiple vendors and Cvendor is not specified. the partly specified component is extended by: version information from the software pack. default variant definition from the software pack. The fully resolved component name is shown in the *.cbuild.yml output file. Note Before CMSIS-Toolbox 2.7, a component that omitted Csub resolved to the first matching component. Installing additional software packs could change therefore component selection. When a component is defined with Csub it is now required to specify. Multiple component definitions are rejected If a component is added more than once in the csolution project files and an error is issued. An attempt to select multiple variants (using Cvariant ) of a component results in an error . Examples: - component: CMSIS:CORE # CMSIS Core component (vendor selected by `csolution` ARM) - component: ARM::CMSIS:CORE # CMSIS Core component from vendor ARM (any version) - component: ARM::CMSIS:CORE@5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0) - component: ARM::CMSIS:CORE@>=5.5.0 # CMSIS Core component from vendor ARM (with version 5.5.0 or higher) - component: Device:Startup # Device Startup component from any vendor - component: CMSIS:RTOS2:Keil RTX5 # CMSIS RTOS2 Keil RTX5 component with default variant (any version) - component: ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3 # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3 - component: Keil::USB&MDK-Pro:CORE&Release@6.15.1 # USB CORE component from bundle MDK-Pro in variant 'Release' and version 6.15.1","title":"component: Name Conventions"},{"location":"YML-Input-Format/#device-name-conventions","text":"The device specifies multiple attributes about the target that range from the processor architecture to Flash algorithms used for device programming. The following syntax is used to specify a device: value in the *.yml files. [ [ Dvendor:: ] Dname] [:Pname] Element Description Dvendor Optional Name (without enum field) of the device vendor-defined in <devices><family> element of the software pack. Dname Optional Device name (Dname attribute) or, when used, the variant name (Dvariant attribute) as defined in the \\<devices> element. Pname Optional Processor identifier (Pname attribute) as defined in the <devices> element. Note All elements of a device name are optional, which allows to supply of additional information, such as the :Pname at different stages of the project. However, the Dname itself is a mandatory element and must be specified in the context of the various project files. Dvendor:: must be used in combination with the Dname . Examples: device: NXP::LPC1768 # The LPC1788 device from NXP device: LPC1788 # The LPC1788 device (vendor is evaluated from DFP) device: LPC55S69JEV98 # Device name (exact name as defined in the DFP) device: LPC55S69JEV98:cm33_core0 # Device name (exact name as defined in the DFP) with Pname specified device: :cm33_core0 # Pname added to a previously defined device name (or a device derived from a board)","title":"device: Name Conventions"},{"location":"YML-Input-Format/#board-name-conventions","text":"Evaluation Boards define a device indirectly via the related BSP. The following syntax is used to specify a board: value in the *.yml files. [vendor::] board_name [:revision] Element Description vendor Optional Name of the board vendor-defined in <boards><board> element of the board support pack (BSP). Bname Required Board name (name attribute) as defined in the \\<board> element of the BSP. revision Optional Board revision (revision attribute) as defined in the \\<board> element of the BSP. Note When a board: is specified, the device: specification can be omitted, however it is possible to overwrite the device setting in the BSP with an explicit device: setting. Examples: board: Keil::MCB54110 # The Keil MCB54110 board (with device NXP::LPC54114J256BD64) board: LPCXpresso55S28 # The LPCXpresso55S28 board board: STMicroelectronics::NUCLEO-L476RG:Rev.C # A board with revision specification","title":"board: Name Conventions"},{"location":"YML-Input-Format/#context-name-conventions","text":"A context: name combines project-name , built-type , and target-type and is used in various places in the CMSIS-Toolbox. The following syntax is used to specify a context: name. [project-name][.build-type][+target-type] Element Description project-name Optional Project name of a project (base name of the *.cproject.yml file). .build-type Optional The build-type name that is currently processed (specified with - type: name ). +target-type Optional The target-type name that is currently processed (specified with - type: name ). Note The .build-type and +target-type names allow letters (A-Z, a-z), digits (0-9), dash ('-'), and underscore ('_'); the maximum length is 32 characters. When project-name is omitted, the project-name is the base name of the *.cproject.yml file. When .build-type is omitted, it matches with any possible .build-type . When +target-type is omitted, it matches with any possible +target-type . By default, the specified - type: name of build-types: and target-types: nodes in the *.csolution.yml file are directly mapped to the context name. Using the context-map: node, it is possible to assign a different .build-type and/or +target-type mapping for a specific project-name . Example: Show the different possible context settings of a *.csolution.yml file. AWS_MQTT_MutualAuth_SW_Framework>csolution list contexts -s Demo.csolution.yml Demo.Debug+AVH Demo.Debug+IP-Stack Demo.Debug+WiFi Demo.Release+AVH Demo.Release+IP-Stack Demo.Release+WiFi The context name is also used in for-context: and not-for-context: nodes that allow to include or exclude items depending on the context . In many cases, the project-name can be omitted as the context name is within a specific *.cproject.yml file or applied to a specific *.cproject.yml file.","title":"context: Name Conventions"},{"location":"YML-Input-Format/#access-sequences","text":"The access sequences export values from the CMSIS Project Manager for the *.yml file nodes define: , define-asm: , add-path: , misc: , files: , executes: , and variables: . The access sequences can specify a different project and describe, therefore, project dependencies. Note variables: that are defined in the *.csolution.yml file can be accessed also using the $<key>$ notation. Access Sequence Description Target Access to target and build related settings $Bname$ Bname of the selected board as specified in the board: node. $Dname$ Dname of the selected device as specified in the device: node. $Pname$ Pname of the selected device as specified in the device: node. $BuildType$ Build-type name of the currently processed project. $TargetType$ Target-type name of the currently processed project. $Compiler$ Compiler name of the compiler used in this project context as specified in the compiler: node. YML Input Access to YML Input Directories and Files $Solution$ Solution name (base name of the *.csolution.yml file). $SolutionDir()$ Path to the directory of the current processed csolution.yml file. $Project$ Project name of the current processed cproject.yml file. $ProjectDir(context)$ Path to the directory of a related cproject.yml file. Output Access to Output Directories and Files $OutDir(context)$ Path to the output directory of a related project that is defined in the *.csolution.yml file. $bin(context)$ Path and filename of the binary output file generated by the related context. $cmse-lib(context)$ Path and filename of the object file with secure gateways of a TrustZone application generated by the related context. $elf(context)$ Path and filename of the ELF/DWARF output file generated by the related context. $hex(context)$ Path and filename of the HEX output file generated by the related context. $lib(context)$ Path and filename of the library file of the related context. Pack Access to Pack Directories and Files $Bpack$ Path to the pack that defines the selected board (BSP). $Dpack$ Path to the pack that defines the selected device (DFP). $Pack(vendor::name)$ Path to a specific pack. Example: $Pack(NXP::K32L3A60_DFP)$ . For a context , the project-name , .build-type , and +target-type are optional. An access sequence that specifies only project-name uses the context that is currently processed. It is important that the project is part of the selected build variant in the build process. Example: $ProjectDir()$ is the directory of the current processed cproject.yml file. Example: This example uses the following build-type , target-type , and projects definitions. solution: target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q # specifies board target-set: - set: - project-context: TFM.Debug - project-context: MQTT_AWS.Debug - type: Production-HW # target-type: Production-HW device: STM32L5X # specifies device target-set: - set: - project-context: TFM.Release - project-context: MQTT_AWS.Debug build-types: - type: Debug # build-type: Debug optimize: none debug: on - type: Release # build-type: Release optimize: size projects: - project: ./bootloader/Bootloader.cproject.yml # relative path - project: /MyDevelopmentTree/security/TFM.cproject.yml # absolute path - project: ./application/MQTT_AWS.cproject.yml # relative path The project: /application/MQTT_AWS.cproject.yml may use access sequences to reference files or directories in other projects that belong to the same csolution project . For example, these references are possible in the file MQTT_AWS.cproject.yml . files: - file: $cmse-lib(TFM)$ # use symbol output file of TFM Project The example above uses the build-type and target-type of the processed context for the project TFM . With a target-set you may mix different build-types for an application. Note that it is important to build both projects using the same build process, for example by specifying the option --active to select a build variant . cbuild iot-product.csolution.yml --active Production-HW The example below uses from the TFM project always build-type: Debug and the target-type: Production-HW . files: - file: `$cmse-lib(TFM.Release+Production-HW)$` # use symbol output file of TFM Project The example below uses the build-type: Debug and the target-type of the current processed context is used. executes: - execute: GenImage run: gen_image %input% -o %output% input: - $elf(TFM.Debug)$ - $elf(Bootloader.Release)$ output: - $OutDir(TFM.Debug)$ The example below creates a define that uses the device name. groups: - group: \"Main File Group\" define: - $Dname$ # Generate a #define 'device-name' for this file group","title":"Access Sequences"},{"location":"YML-Input-Format/#order-of-list-nodes","text":"The key / value pairs in a list node can be in any order. The two following list nodes are logically identical. This might be confusing for yml files that are generated by an IDE. build-types: - type: Release # build-type name optimize: size # optimize for size debug: off # generate no debug information for the release build build-types: - debug: off # generate no debug information for the release build optimize: size # optimize for size type: Release # build-type name","title":"Order of List Nodes"},{"location":"YML-Input-Format/#project-file-structure","text":"The table below explains the top-level elements in each of the different *.yml input files that define the overall application. Keyword Description default: Start of cdefault.yml file that is used to setup the compiler along with some compiler-specific controls. solution: Start of *.csolution.yml file that collects related projects along with build-types: and target-types: . project: Start of *.cproject.yml file that defines files, components, and layers which can be independently translated to a binary image or library. layer: Start of *.clayer.yml file that contains pre-configured software components along with source files.","title":"Project File Structure"},{"location":"YML-Input-Format/#cdefault","text":"When cdefault: is specified in the *.csolution.yml file, the csolution Project Manager uses a file with the name cdefault.yml to setup the compiler with specific default controls. The search order for this file is: A cdefault.yml file in the same directory as the <solution-name>.csolution.yml file. A cdefault.yml file in the directory <cmsis-toolbox-installation-dir>/etc . The default: node is the start of a cdefault.yml file and contains the following. default: Content misc: Optional Literal tool-specific controls. Refer to CSolution Project Structure - cdefault.yml for an example. Note The compiler: selection in cdefault.yml has been deprecated in CMSIS-Toolbox 2.6.0.","title":"cdefault:"},{"location":"YML-Input-Format/#solution","text":"The solution: node is the start of a *.csolution.yml file that collects related projects as described in the section \"Configure Related Projects\" . solution: Content created-by: Optional Identifies the tool that created this solution. created-for: Optional Specifies the tool for building this solution, i.e. CMSIS-Toolbox@2.5.0 description: Optional Brief description text of this solution. select-compiler: Optional Lists the possible compiler selection that this project is tested with. cdefault: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. compiler: Optional Overall toolchain selection for this solution. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. output-dirs: Optional Control the output directories for the build output. generators: Optional Control the directory structure for generator output. packs: Optional Defines local packs and/or scope of packs that are used. target-types: Required List of target-types that define the target system (device or board). build-types: Optional List of build-types (i.e. Release, Debug, Test). projects: Required List of projects that belong to the solution. executes: Optional Additional pre or post build steps using external tools. misc: Optional Literal tool-specific controls. Example: solution: created-for: cmsis-toolbox@2.6 # minimum CMSIS-Toolbox version required for project build cdefault: # use default setup of toolchain-specific controls. compiler: GCC # overwrite compiler definition in 'cdefaults.yml' packs: - pack: ST # add ST packs in 'cdefaults.yml' build-types: # additional build types - type: Test # build-type: Test optimize: none debug: on packs: # with explicit pack specification - pack: ST::TestSW path: ./MyDev/TestSW target-types: - type: Board # target-type: Board board: NUCLEO-L552ZE-Q - type: Production-HW # target-type: Production-HW device: STM32U5X # specifies device projects: - project: ./blinky/Bootloader.cproject.yml - project: /security/TFM.cproject.yml - project: /application/MQTT_AWS.cproject.yml","title":"solution:"},{"location":"YML-Input-Format/#project","text":"The project: node is the start of a *.cproject.yml file and can contain the following: project: Content description: Optional Brief description text of this project. output: Optional Configure the generated output files. generators: Optional Control the directory structure for generator output. rte: Optional Control the directory structure for RTE (run-time environment) files. packs: Optional Defines packs that are required for this project. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. linker: Optional Instructions for the linker. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Specify processor core. processor: Optional Processor specific settings. setups: Optional Configurations specific to a compiler, target-type, and/or built-type. groups: Required List of source file groups along with source files. components: Optional List of software components used. layers: Optional List of software layers that belong to the project. connections: Optional List of consumed and provided resources. executes: Optional Additional pre or post build steps using external tools. Example: project: misc: - compiler: AC6 # specify misc controls for Arm Compiler 6 C: [-fshort-enums, -fshort-wchar] # set options for C files add-path: - $OutDir(Secure)$ # add the path to the secure project's output directory components: - component: Startup # Add startup component - component: CMSIS CORE - component: Keil RTX5 Library_NS groups: - group: Non-secure Code # Create group files: - file: main_ns.c # Add files to group - file: $Source(Secure)$interface.h - file: $Output(Secure)$_CMSE_Lib.o","title":"project:"},{"location":"YML-Input-Format/#layer","text":"The layer: node is the start of a *.clayer.yml file and defines a Software Layer . It can contain the following nodes: layer: Content type: Optional Layer type for combining layers; used to identify compatible layers . description: Optional Brief description text of the layer. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. device: Optional Specify processor core. generators: Optional Control the directory structure for generator output. packs: Optional Defines packs that are required for this layer. for-device: Optional Device information, used for consistency check (device selection is in *.csolution.yml ). for-board: Optional Board information, used for consistency check (board selection is in *.csolution.yml ). connections: Optional List of consumed and provided resources. processor: Optional Processor specific settings. linker: Optional Instructions for the linker. groups: Optional List of source file groups along with source files. components: Optional List of software components used. Example: layer: type: Board description: Setup with Ethernet and WiFi interface processor: trustzone: secure # set processor to secure components: - component: Startup - component: CMSIS CORE groups: - group: Secure Code files: - file: main_s.c - group: CMSE files: - file: interface.c - file: interface.h - file: tz_context.c","title":"layer:"},{"location":"YML-Input-Format/#directory-control","text":"The following nodes control the application's directory structure.","title":"Directory Control"},{"location":"YML-Input-Format/#output-dirs","text":"Allows control of the directory structure for building output files and temporary files. Notes This control is only possible at csolution.yml level. CMake manages the temporary directory of all projects therefore tmpdir: does not support access sequences. output-dirs: Content outdir: Optional Specifies the directory for the build output files (ELF, binary, MAP files). tmpdir: Optional Specifies the directory for the interim temporary files. intdir: Optional Legacy node, applied instead of tmpdir: when using cbuild with option --cbuildgen . The default setting for the output-dirs: are: tmpdir: tmp # All projects use the same temporary directory outdir: $SolutionDir()$/out/$TargetType$/$BuildType$ With the tool option --output an prefix top-level directory can be added. The effective outdir: with the command below is: MyOut/out/$TargetType$/$BuildType$ . cbuild <name>.csolution.yml --output MyOut Example: output-dirs: tmpdir: ./tmp2 # relative path to csolution.yml file outdir: ./out/$Project$/$TargetType$ # $BuildType$ no longer part of the outdir","title":"output-dirs:"},{"location":"YML-Input-Format/#generators","text":"Allows control of the directory structure for generator output files. When no explicit generators: is specified, the csolution Project Manager uses as path: The workingDir defined in the generators element of the PDSC file. When no workingDir is defined the default directory $ProjectDir()$/generated/<generator-id> is used; <generator-id> is defined by the id in the generators element of the PDSC file. The generators: node can be added at various levels of the *.yml input files. The following order is used: Use generators: specification of the *.clayer.yml input file, if not exist: Use generators: specification of the *.cproject.yml input file, if not exist: Use generators: specification of the *.csolution.yml input file. Notes Only relative paths are permitted to support the portability of projects. The location of the *.yml file that contains the generators: node is the reference for relative paths. generators: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/generated . options: Optional Specific generator options; allows explicit directory configuration for a generator. Note The base directory is extended for each generator with /<generator-id> ; <generator-id> is defined by the id in the generator element of the PDSC file.","title":"generators:"},{"location":"YML-Input-Format/#generators-options","text":"options: Content - generator: Optional Identifier of the generator tool, specified with id in the generators element of the PDSC file. path: Optional Specifies the directory for generated files. Relative paths used the location of the *.cproject.yml or *.clayer.yml file as the base directory. name: Optional Specifies the base name of the generator import file (added in CMSIS-Toolbox 2.4.0); typically used for a board layer. map: Optional Mapping of the csolution project to a generator-specific run-time context name (added in CMSIS-Toolbox 2.4.0). Example: generators: base-dir: $SolutionDir()$/MyGenerators # Path for all generators extended by '/<generator-id>' options: - generator: CubeMX # for the generator id `CubeMX` use this path path: ./CubeFiles # relative path to generated files and the generator import file name: MyConf # results in generator import file ./CubeFiles/MyConf.cgen.yml map: Boot # Map this project part to the CubeMX run-time context Boot","title":"generators: options:"},{"location":"YML-Input-Format/#rte","text":"Allows to control the directory structure for RTE (run-time environment) files. Notes This control is only possible at *.cproject.yml level. Only relative paths are permitted to support the portability of projects. The location of the *.cproject.yml file is the reference for relative paths. rte: Content base-dir: Optional Base directory for unspecified generators; default: $ProjectDir()$/RTE . rte: base-dir: $TargetType$/RTE # Path extended with target-type, results in `$ProjectDir()$/$TargetType$/RTE`","title":"rte:"},{"location":"YML-Input-Format/#toolchain-options","text":"Toolchain options may be used at various places, such as: solution: level to specify options for a collection of related projects. project: level to specify options for a project.","title":"Toolchain Options"},{"location":"YML-Input-Format/#select-compiler","text":"Lists the compilers that this csolution project is tested with. This information is used by the cbuild setup command to determine possible compiler choices. The actual compiler to be used is selected with the compiler: node. Notes select-compiler: is only supported in the *.csolution.yml project file. This control is new in CMSIS-Toolbox 2.5.0 select-compiler: Content - compiler: Required Specifies a supported compiler. Example: solution: created-for: cmsis-toolbox@2.5 # minimum CMSIS-Toolbox version required for project build select-compiler: # list tested compilers that can be selected - compiler: GCC # GCC is supported - compiler: AC6@6.22 # AC6 is supported, version number is a hint on what was tested","title":"select-compiler:"},{"location":"YML-Input-Format/#compiler","text":"Selects the compiler toolchain used for code generation. It can be applied in *.csolution.yml files. Optionally the compiler can have a version number specification. Compiler Name Supported Compiler AC6 Arm Compiler version 6 GCC GCC Compiler IAR IAR Compiler CLANG CLANG Compiler based on LLVM technology Example: compiler: GCC # Select GCC Compiler compiler: AC6@6.18.0 # Select Arm Compiler version 6.18.0","title":"compiler:"},{"location":"YML-Input-Format/#linker","text":"The linker: node specifies an explicit Linker Script and/or memory regions header file. It can be applied in *.cproject.yml and *.clayer.yml files. Refer to Linker Script Management for detailed information. linker: Content - regions: Optional Path and file name of <regions_file>.h , used to generate a Linker Script. script: Optional Explicit file name of the Linker Script, overrules files provided with file: or components. auto: Optional Request automatic Linker Script generation . define: Optional Define symbol settings for the linker script file preprocessor. for-compiler: Optional Include Linker Script for the specified toolchain. for-context: Optional Include Linker Script for a list of build and target type names. not-for-context: Optional Exclude Linker Script for a list of build and target type names. Notes The linker: node must have at least regions: , script: , auto: , or define: . If no script: file is specified, compiler-specific Linker Script template files are used. A Linker Script file is preprocessed when regions: or a define: is or the file extension is *.src . If both auto: and script: is specified, a warning is issued, and automatic Linker Script generation is performed, and the specified script: is ignored. Examples: linker: - script: MyLinker.scf.src # linker script file regions: MyRegions.h # pre-processed using header file linker: - regions: MyRegions.h # Default linker script is used and pre-processed using header file linker: - script: MyLinker.scf.src # linker script file, not pre-processed for-compiler: AC6 # for Arm Compiler 6 - script: MyLinker.ld # linker script file, not pre-processed for-compiler: CLANG # for CLANG LLVM-based compiler linker: - script: MyLinker.scf.src # linker script file for-compiler: AC6 # for Arm Compiler 6 regions: MyRegions.h # pre-processed using header file - script: MyLinker.ld.src # linker script file for-compiler: CLANG # for CLANG LLVM-based compiler regions: MyRegions.h # pre-processed using header file define: # with define setting - Setup: 1 # define with value","title":"linker:"},{"location":"YML-Input-Format/#output","text":"Configure the generated output files. output: Content base-name: Optional Specify a common base name for all output files. type: Optional A list of output types for code generation (see list below). type: Description - lib Library or archive. Note: GCC uses the prefix lib in the base name for archive files. - elf Executable in ELF format. The file extension is toolchain-specific. - hex Intel HEX file in HEX-386 format. - bin Binary image. - map Linker MAP file. The default setting for output: is: output: base-name: $Project$ # used the base name of the `cproject.yml` file. type: elf # Generate executable file. Example: output: type: - elf # Generate executable file. - map # Generate Linker MAP file. output: # configure output files. base-name: MyProject # used for all output files, including linker map file. type: - elf # Generate executable file. - hex # generate a HEX file. - bin # generate a BIN file. Generate a library : output: # configure output files. type: lib # Generate library file.","title":"output:"},{"location":"YML-Input-Format/#translation-control","text":"The following translation control options may be used at various places such as: solution: level to specify options for a collection of related projects project: level to specify options for a project groups: level to specify options for a specify source file group files: level to specify options for a specify source file Note The keys define: , define-asm: , add-path: , add-path-asm: , del-path: , and misc: are additive. All other keys can only be defined once at the level of solution: , project: , setup: , layer: and build-types: . or target-types: . However, it is possible to overwrite these keys at the level of group: , file: , or component: ; for example it is possible to translate a file group with a different optimize level.","title":"Translation Control"},{"location":"YML-Input-Format/#language-c","text":"Set the language standard for C source file compilation. Value Select C Language Standard c90 compile C source files as defined in C90 standard (ISO/IEC 9899:1990). gnu90 same as c90 but with additional GNU extensions. c99 (default) compile C source files as defined in C99 standard (ISO/IEC 9899:1999). gnu99 same as c99 but with additional GNU extensions. c11 compile C source files as defined in C11 standard (ISO/IEC 9899:2011). gnu11 same as c11 but with additional GNU extensions. c17 compile C source files as defined in C17 standard (ISO/IEC 9899:2017). Experimental compiler feature new in CMSIS-Toolbox 2.6.0. c23 compile C source files as defined in C23 standard (ISO/IEC 9899:2023). Experimental compiler feature new in CMSIS-Toolbox 2.6.0.","title":"language-C:"},{"location":"YML-Input-Format/#language-cpp","text":"Set the language standard for C++ source file compilation. Value Select C++ Language Standard c++98 compile C++ source files as defined in C++98 standard (ISO/IEC 14882:1998). gnu++98 same as c++98 but with additional GNU extensions. c++03 compile C++ source files as defined in C++03 standard (ISO/IEC 14882:2003). gnu++03 same as c++03 but with additional GNU extensions. c++11 compile C++ source files as defined in C++11 standard (ISO/IEC 14882:2011). gnu++11 same as c++11 but with additional GNU extensions. c++14 (default) compile C++ source files as defined in C++14 standard (ISO/IEC 14882:2014). gnu++14 same as c++14 but with additional GNU extensions. c++17 compile C++ source files as defined in C++17 standard (ISO/IEC 14882:2014). gnu++17 same as c++17 but with additional GNU extensions. c++20 compile C++ source files as defined in C++20 standard (ISO/IEC 14882:2020). gnu++20 same as c++20 but with additional GNU extensions. c++23 compile C++ source files as defined in C++23 standard (ISO/IEC 14882:2023). gnu++23 same as c++23 but with additional GNU extensions.","title":"language-CPP:"},{"location":"YML-Input-Format/#optimize","text":"Generic optimize levels for code generation. Value Code Generation balanced Balanced optimization size Optimize for code size speed Optimize for execution speed debug Optimize for debug experience none No optimization Note When optimize: is not specified, the default optimize setting of the compiler is used. Example: groups: - group: \"Main File Group\" optimize: none # optimize this file group for debug illusion files: - file: file1a.c - file: file1b.c","title":"optimize:"},{"location":"YML-Input-Format/#link-time-optimize","text":"When applied, the link-time optimization is enabled. It enables global optimizations across multiple translation units at the linker stage which typically further improves performance and reduces code size. Example: groups: - group: \"Main File Group\" optimize: speed # optimize for execution speed link-time-optimize: # enable link-time optimization for this file group files: - file: file1a.c - file: file1b.c Note This feature is not available with the IAR compiler.","title":"link-time-optimize:"},{"location":"YML-Input-Format/#debug","text":"Control the generation of debug information. Value Code Generation on Generate debug information (default) off Generate no debug information Example: build-types: - type: Release optimize: size # optimize for size debug: off # generate no debug information for the release build","title":"debug:"},{"location":"YML-Input-Format/#warnings","text":"Control warning level for compiler diagnostics. Value Control diagnostic messages (warnings) on Generate warning messages all Enable all compiler warning messages (compiler option -Wall) off No warning messages generated","title":"warnings:"},{"location":"YML-Input-Format/#define","text":"Contains a list of symbol #define statements that are passed via the command line to the development tools for C, C++ source files, or the linker script file preprocessor. define: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Note This control only applies to C and C++ source files (or to the linker script preprocessor). For assembler source files use the define-asm: node. Example: define: # Start a list of define statements - TestValue: 12 # add symbol 'TestValue' with value 12 - TestMode # add symbol 'TestMode'","title":"define:"},{"location":"YML-Input-Format/#define-asm","text":"Contains a list of symbol #define statements that are passed via the command line to the development tools for Assembler source files. define-asm: Content - <symbol-name> #define symbol passed via command line - <symbol-name>: <value> #define symbol with value passed via command line - <symbol-name>: \\\"<string>\\\" #define symbol with string value passed via command line Example: define-asm: # Start a list of define statements for Assembler source code - AsmValue: 12 # add symbol 'AsmValue' with value 12","title":"define-asm:"},{"location":"YML-Input-Format/#undefine","text":"Remove symbol #define statements from the command line of the development tools. undefine: Content - <symbol-name> Remove #define symbol Examples: groups: - group: \"Main File Group\" undefine: - TestValue # remove define symbol `TestValue` for this file group files: - file: file1a.c undefine: - TestMode # remove define symbol `TestMode` for this file - file: file1b.c","title":"undefine:"},{"location":"YML-Input-Format/#add-path","text":"Add include paths to the command line of the development tools for C and C++ source files. add-path: Content - <path-name> Named path to be added Note This control only applies to C and C++ source files. For assembler source files, use the add-path-asm: node. Example: project: misc: - for-compiler: AC6 C: [-fshort-enums, -fshort-wchar] - for-compiler: GCC C: [-fshort-enums, -fshort-wchar] add-path: - $OutDir(Secure)$ # add path to secure the project's output directory","title":"add-path:"},{"location":"YML-Input-Format/#add-path-asm","text":"Add include paths to the command line of the development tools for assembly source files. add-path-asm: Content - <path-name> Named path to be added Note This control only applies to assembler source files. For C and C++ source files use the add-path: node. Example: project: add-path-asm: - .\\MyAsmIncludes # add path to assembler include files secure project's output directory","title":"add-path-asm:"},{"location":"YML-Input-Format/#del-path","text":"Remove include paths (that are defined at the cproject level) from the command line of the development tools. del-paths: Content - <path-name> Named path to be removed; * for all Example: target-types: - type: CM3 device: ARMCM3 del-paths: - /path/solution/to-be-removed","title":"del-path:"},{"location":"YML-Input-Format/#misc","text":"Add miscellaneous literal tool-specific controls that are directly passed to the individual tools depending on the file type. misc: Content - for-compiler: Optional Name of the toolchain that the literal control string applies to. C-CPP: Optional Applies to *.c and *.cpp files (added before C and CPP: ). C: Optional Applies to *.c files only. CPP: Optional Applies to *.cpp files only. ASM: Optional Applies to assembler source files only. Link: Optional Applies to the linker (added before Link-C: or Link-CPP: ). Link-C: Optional Applies to the linker; added when no C++ files are part of the project. Link-CPP: Optional Applies to the linker; added when C++ files are part of the project. Library: Optional Set libraries to the correct position in the linker command line (for GCC). Example: build-types: - type: Debug misc: - for-compiler: AC6 C-CPP: - -O1 - -g - for-compiler: GCC C-CPP: - -Og - type: Release compiler: AC6 misc: - C: - -O3 - type: GCC-LibDebug compiler: GCC misc: - Library: - -lm - -lc - -lgcc - -lnosys","title":"misc:"},{"location":"YML-Input-Format/#project-setups","text":"The setups: node can be used to create setups specific to a compiler, target type, and/or built type.","title":"Project Setups"},{"location":"YML-Input-Format/#setups","text":"The setups: node collects a list of setup: notes. Only one setup will be selected for each context. The result is a setup: that collects various toolchain options, and that is valid for all files and components in the project. It is, however, possible to change that setup: settings on a group: or file: level. setups: Content - setup: Required Description of the setup for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. output: Optional Configure the generated output files. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. linker: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. processor: Optional Processor configuration. project: setups: - setup: Arm Compiler 6 project setup for-compiler: AC6 linker: - script: my-project.sct define: - test: 12 - setup: GCC project setup for-compiler: GCC linker: - script: my-project.inc define: - test: 11","title":"setups:"},{"location":"YML-Input-Format/#pack-selection","text":"The packs: node can be specified in the *.csolution.yml file allows you to: Reduce the scope of software packs that are available for projects. Add specific software packs that are optional with version specifications. Provide a path to a local installation of a software pack that is, for example, project-specific or under development. The Pack Name Conventions specify the names of the software packs. The pack: definition may be specific to a context that specifies target-types: and/or build-types: or provides a local path to a development repository of a software pack. Notes By default, the csolution Project Manager only loads the latest version of the installed software packs. It is, however, possible to request specific versions using the - pack: node. An attempt to add two different versions of the same software pack results in an error.","title":"Pack Selection"},{"location":"YML-Input-Format/#packs","text":"The packs: node is the start of a pack selection. packs: Content - pack: Explicit pack specification (additive)","title":"packs:"},{"location":"YML-Input-Format/#pack","text":"The pack: list allows to add specific software packs , optional with a version specification. pack: Content path: Explicit path name that stores the software pack. This can be a relative path to your project workspace. for-context: Include pack for a list of build and target types. not-for-context: Exclude pack for a list of build and target types. Note When an explicit path: to the pack is specified, an explicit pack version cannot be specified as the path directly specifies the pack to include. Example: packs: # start section that specifics software packs - pack: AWS # use packs from AWS - pack: NXP::*K32L* # use packs from NXP relating to K32L series (would match K32L3A60_DFP + FRDM-K32L3A6_BSP) - pack: ARM # use packs from Arm - pack: Keil::Arm_Compiler # add latest version of Keil::Arm_Compiler pack - pack: Keil::MDK-Middleware@7.13.0 # add Keil::MDK-Middleware pack at version 7.13.0 - pack: ARM::CMSIS-FreeRTOS@~10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 10.5.0 - pack: ARM::CMSIS-FreeRTOS@^10.4.0 # add CMSIS-FreeRTOS with version 10.4.x or higher but lower than 11.0.0 - pack: NXP::K32L3A60_DFP # add pack for NXP device ftar path: ./local/NXP/K32L3A60_DFP # with path to the pack (local copy, repo, etc.) - pack: AWS::coreHTTP # add pack path: ./development/AWS/coreHTTP # with path to development source directory for-context: +DevTest # pack is only used for target-type \"DevTest\"","title":"pack:"},{"location":"YML-Input-Format/#target-selection","text":"","title":"Target Selection"},{"location":"YML-Input-Format/#board","text":"Specifies a unique board name , optionally with vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings.","title":"board:"},{"location":"YML-Input-Format/#device","text":"Specifies a unique device name , optionally with the vendor that must be defined in software packs. This information is used to define the device: along with basic toolchain settings. A device: is derived from the board: setting, but an explicit device: setting overrules the board: device. If device: specifies a device with a multi-core processor, and no explicit pname for the processor core selection is specified, the default pname of the device is used. At the level of a cproject.yml file, only the pname can be specified as the device itself is selected at the level of a csolution.yml file. Example: The following assumes that the csolution is based on NXP's K32L3A60VPJ1A which has two pnames : cm4 and cm0plus . Here are the corresponding entries in the *.cproject.yml files: CM4.cproject.yml: project: device: :cm4 CM0Plus.cproject.yml: project: device: :cm0plus","title":"device:"},{"location":"YML-Input-Format/#processor-attributes","text":"","title":"Processor Attributes"},{"location":"YML-Input-Format/#processor","text":"The processor: keyword specifies the processor features used in this project. processor: Content fpu: Select usage of FPU instructions: dp (double precision) | sp (single precision) | off (disabled). dsp: Select usage of SIMD instructions: on (enabled) | off (disabled). mve: Select usage of M-Profile vector extension: fp (floating point and integer instructions) | int (integer instructions) | off (disabled). trustzone: Select TrustZone mode: secure | secure-only | non-secure | off . branch-protection: Select Branch Protection mode: bti (branch target identification) | bti-signret (branch target identification and pointer authentication) | off (disabled). The default setting enables the available features of the device. For example fpu: dp is selected for devices that offer double precision floating point hardware. For trustzone: the possible settings are: trustzone: Description off TrustZone disabled, classic Cortex-M programmers model. Default for devices with configurable TrustZone feature. non-secure Non-secure mode. Default for devices with enabled TrustZone feature. secure Secure mode with veneers for non-secure calls. Related options to generate cmse library are enabled. secure-only Secure mode without veneers for non-secure calls. No cmse library generated (new in CMSIS-Toolbox 2.6.0). Example: project: processor: trustzone: secure fpu: off # do not use FPU instructions mve: off # do not use vector instructions.","title":"processor:"},{"location":"YML-Input-Format/#context","text":"A context is an environment setup for a project that is composed of: project-name that is the base name of the *.cproject.yml file. .build-type that defines typically build-specific settings such as for debug, release, or test. +target-type that defines typically target-specific settings such as device, board, or usage of processor features. Note The context name is used throughout the build process and is reflected in directory names. Even when there is not a fixed limit, keep identifiers short. Recommended is less than 32 characters for the context name. Blank characters (' ') in the context name are not permitted by CMake. The section \"Configure Related Projects\" explains the overall concept of target-types and build-types . These target-types and build-types are defined in the *.csolution.yml that defines the overall application for a system. The settings of the target-types: are processed first, followed by the settings of the build-types: , which potentially overwrite the target-types: settings.","title":"Context"},{"location":"YML-Input-Format/#target-types","text":"The target-types: node may include toolchain options , target selection , and processor attributes : target-types: Content - type: Required The target-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. board: see Note Board specification. device: see Note Device specification. processor: Optional Processor specific settings. context-map: Optional Use different target-types: for specific projects. variables: Optional Variables that can be used to define project components. memory: Optional Add additional off-chip memory available in target hardware. target-set: Optional One or more target-set configurations for projects, images, and debugger. west-defs: Optional Defines in CMake format for the west build system. Note Either device: or board: is required.","title":"target-types:"},{"location":"YML-Input-Format/#build-types","text":"The build-types: node may include toolchain options : build-types: Content - type: Required The build-type identifier that is used to create the context name. compiler: Optional Toolchain selection. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove preprocessor (#define) symbols. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. context-map: Optional Use different build-types: for specific projects. variables: Optional Variables that can be used to define project components. west-defs: Optional Defines in CMake format for the west build system. Example: target-types: - type: Board # target-type name, used in context with: +Board board: NUCLEO-L552ZE-Q # board specifies indirectly also the device - type: Production-HW # target-type name, used in context with: +Production-HW device: STM32L552RC # specifies device build-types: - type: Debug # build-type name, used in context with: .Debug optimize: none # specifies code optimization level debug: debug # generates debug information - type: Test # build-type name, used in context with: .Test optimize: size debug: on The board: , device: , and processor: settings are used to configure the code translation for the toolchain. These settings are processed in the following order: board: relates to a BSP software pack that defines board parameters, including the mounted device . If board: is not specified, a device: must be specified. device: defines the target device. If board: is specified, the device: setting can be used to overwrite the device or specify the processor core used. processor: overwrites default settings for code generation, such as endianness, TrustZone mode, or disabling Floating Point code generation. Examples: target-types: - type: Production-HW board: NUCLEO-L552ZE-Q # hardware is similar to a board (to use related software layers) device: STM32L552RC # but uses a slightly different device processor: trustzone: off # TrustZone disabled for this project target-types: - type: Production-HW board: FRDM-K32L3A6 # NXP board with K32L3A6 device device: :cm0plus # use the Cortex-M0+ processor","title":"build-types:"},{"location":"YML-Input-Format/#target-set","text":"The target-set: specifies for a target-type: the projects and images to include along with the configuration settings for a debug adapter. It is possible to specify one or more set configurations per target-type . Refer to the section \"Configure Related Projects\" that describes how to combine multiple projects into an application. target-set: Content - set: Required Start of a configuration, optional with name. The default set is unnamed. info: Optional Brief description of the configuration. images: Optional List of images that belong to this set. debugger: Optional Debugger configuration for this set.","title":"target-set:"},{"location":"YML-Input-Format/#images","text":"The images: node under target-set: specifies the projects with build-type and optional additional images that belong to this configuration of the target set. images: Content - project-context: Optional Project output or with optional build-type to use. Format: <project_name>[.buid_type] image: Optional Additional image file to load. load: Optional Load mode of the image file for programmers and debug tools. info: Optional Brief description of the image file. type: Optional Specifies an explicit file of the image type. load-offset: Optional Offset applied when loading a image file with type: bin (pyOCD only). device: Optional For image files a pname can be specified to denote the processor that runs the image. Notes Each list node must contain either image: or project-context: (but not both). The type: specification is only accepted for an image: file. The project-context: can also refer to a west project-id: with build type.","title":"images:"},{"location":"YML-Input-Format/#load","text":"Specifies the load mode for an image file. This information is used by programmers and debug tools. load: Description image+symbols Load both the binary image and the debug symbol information (default for project-context and image with file type elf). symbols Load only the debug symbol information. image Load only the binary image (default image for other file types). none No content is loaded for this image, however it is part of the build process.","title":"load:"},{"location":"YML-Input-Format/#type","text":"With type: an explicit file type can be specified which is required for unknown file extensions. The explicit file type overwrites the auto-detection of file types based on the file extension. type: Auto-detected Extension Description - lib .lib , .a Library or archive. - elf .axf , .elf Executable in ELF format. - hex .h386 , .hex Intel HEX file in HEX-386 format. - bin .bin Binary image. Example: solution: : target-types: - type: MCXN947 board: FRDM-MCXN947 device: NXP::MCXN947VDF target-set: - set: # without id, <default> set debugger: name: ST-Link images: - project-context: core1.Debug - project-context: core0.Release - set: production # id for this target set images: - project-context: core1.Release device: :core1 # specify the pname that runs the image - project-context: core0.Release device: :core0 # specify the pname that runs the image - type: Custom-HW device: NXP::MCXN947VDF target-set: - set: # without id, <default> set debugger: name: ULINKplus protocol: swd images: - project-context: core1.Debug - project-context: core0.Release - image: Zephry.elf load: image build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./cm33_core1/core1.cproject.yml - project: ./cm33_core0/core0.cproject.yml","title":"type:"},{"location":"YML-Input-Format/#variables","text":"The variables: node defines key/value pairs in the *.csolution.yml file. Using $<key>$ in *.cproject.yml and *.clayer.yml files expands to the value of the variable. The variable $<key>$ can be used in the following nodes: layers: , define: , define-asm: , add-path: , add-path-asm: , misc: , files: , and executes: . The <key>: name format <type>-Layer is a convention that references layer-type . In this case the copied-from: can be used to describe the orginal source of a layer (typically a path in a software pack). variables: Description <key>: <key>: specifies a variable name with value. copied-from: Descriptive text that documents the source of a layer. Example: With variables that are defined in the *.csolution.yml file, a *.cproject.yml file requires no modifications when new target-types: are introduced. The required layers: could be instead specified in the *.csolution.yml file using a new node variables: . Example.csolution.yml solution: target-types: - type: NXP Board board: IMXRT1050-EVKB variables: - Socket-Layer: $SolutionDir()$/Socket/FreeRTOS+TCP/Socket.clayer.yml - Board-Layer: $SolutionDir()$/Board/IMXRT1050-EVKB/Board.clayer.yml - type: ST Board board: B-U585I-IOT02A variables: - Socket-Layer: $SolutionDir()$/Socket/WiFi/Socket.clayer.yml - Board-Layer: $SolutionDir()$/Board/B-U585I-IOT02A/Board.clayer.yml copied-from: ${CMSIS_PACK_ROOT}/Keil/B-U585I-IOT02A_BSP/2.0.0/CMSIS/Board/ Example.cproject.yml layers: - layer: $Socket-Layer$ type: Socket - layer: $Board-Layer$ # no `*.clayer.yml` specified. Compatible layers are listed type: Board # layer of type `Board` is expected","title":"variables:"},{"location":"YML-Input-Format/#variable-west-board","text":"West Build uses a different schema for the board name . However several board names can be mapped to west tool. By default, the variable $west-board$ holds the board_name (converted to lower-case, - replaced by _ ) of the current active target type as default for the west: node. However, as some CMSIS boards names do not map, the variable $west-board$ can be defined as shown below. Example.csolution.yml solution: target-types: - type: Alif Board board: Alif Semiconductor::DevKit-E7 variables: - west-board: alif_e7_dk_rtss_he # explicit west board name - type: ST Board board: STMicroelectronics::STM32H7B3I-DK # $west-board$ set to `stm32h7b3i_dk`","title":"Variable west-board"},{"location":"YML-Input-Format/#context-map","text":"The context-map: node allows for a specific project-name the remapping of target-types: and/or build-types: to a different context: which enables: Integrating an existing *.cproject.yml file in a different *.csolution.yml file that uses different build-types: and/or target-types: for the overall application. Defines how different *.cproject.yml files of a *.csolution.yml are to the binary image of the final target (needs reflection in cbuild-idx.yml). The context-map: node lists a remapping of the context-name for a project-name and specific target-types: and build-types: . context-map: Content - <context-name> Required Specify an alternative context-name for a project. For the context-map: it is required to specify the <project-name> as part of the context-name . This project will use a different .build-type and/or +target-type as applied in the context-name . This remapping of the context applies for the specific type in the build-types: or target-types: list. Example 1: This application combines two projects for a multi-processor device, but the project HelloCM7 requires a different setting for the build-type name Release as this enables different settings within the *.cproject.yml file. target-types: - type: DualCore device: MyDualCoreDevice build-types: - type: Release # When applying build-type name 'release': context-map: - HelloCM7.flex_release # project HelloCM7 uses build-type name \"flex_release\" instead of \"release\" projects: - project: ./CM7/HelloCM7.cproject.yml - project: ./CM4/HelloCM4.cproject.yml Example 2: The following example uses three projects: Demo , TFM , and Boot . The project TFM should always be built using the context TFM.Release+LibMode . For the target-type name Board , the Boot project requires the +Flash target, but any build type could be used. target-types: - type: Board # When applying target-type: 'Board': context-map: - TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode - Boot+Flash # for project Boot use target-type: Flash board: B-U585I-IOT02A - type: AVH # When applying target-type: 'AVH': context-map: - context: TFM.Release+LibMode # for project TFM use build-type: Release, target-type: LibMode device: ARM::SSE-300-MPS3 projects: - project: ./App/Demo.cproject.yml - project: ./Security/TFM.cproject.yml - project: ./Loader/Boot.cproject.yml","title":"context-map:"},{"location":"YML-Input-Format/#conditional-build","text":"It is possible to include or exclude items of a list node in the build process. for-compiler: includes items only for a compiler toolchain. for-context: includes items only for a context list. not-for-context: excludes items for a context list. Note for-context: and not-for-context: are mutually exclusive, only one occurrence can be specified for a list node .","title":"Conditional Build"},{"location":"YML-Input-Format/#for-compiler","text":"Depending on a compiler toolchain it is possible to include list nodes in the build process. Examples: for-compiler: AC6@6.16 # add item for Arm Compiler version 6.16 only for-compiler: GCC # for GCC Compiler (any version)","title":"for-compiler:"},{"location":"YML-Input-Format/#for-context","text":"A context list that adds a list-node for specific target-type and/or build-type names.","title":"for-context:"},{"location":"YML-Input-Format/#not-for-context","text":"A context list that removes a list-node for specific target-types: and/or build-types: .","title":"not-for-context:"},{"location":"YML-Input-Format/#context-list","text":"It is also possible to provide a context list with: - [.build-type][+target-type] - [.build-type][+target-type] Examples: for-context: - .Test # add item for build-type: Test (any target-type) for-context: # add item - .Debug # for build-type: Debug and - .Release+Production-HW # build-type: Release / target-type: Production-HW not-for-context: +Virtual # remove item for target-type: Virtual (any build-type) not-for-context: .Release+Virtual # remove item for build-type: Release with target-type: Virtual","title":"Context List"},{"location":"YML-Input-Format/#usage","text":"The keyword for-context: and not-for-context: can be used for the following list nodes : List Node Description - project: At projects: level it is possible to control inclusion of project. - layer: At layers: level, it is possible to control the inclusion of a software layer. The keyword for-context: , not-for-context: , and for-compiler: can be applied to the following list nodes : List Node Description - component: At components: level, control the inclusion of a software component. - group: At groups: level, control the inclusion of a file group. - setup: At setups: level, define toolchain-specific options that apply to the whole project. - file: At files: level, control the inclusion of a file. The inclusion of a list node is processed with this hierarchy from top to bottom: project --> layer --> component / group --> file In other words, the restrictions specified by for-context: or not-for-context for a list node are applied to it child nodes. Child list nodes inherit the restrictions from their parent. Note With for-context: and not-for-context: the project-name of a context cannot be applied. The context name must, therefore, start with . to refer to the build-type: or + to refer to the target-type: .","title":"Usage"},{"location":"YML-Input-Format/#regular-expressions","text":"With for-context: and not-for-context: a regular expression can be used to refer to multiple context names. When a context name starts with the character \\ the regular expression expansion is enabled. The character \\ itself is not part of the sequence. Example: The following project is only included when the build-type: of a context contains Test . build-types: - Debug-Test: # Debug build with Test functionality : - Test-Release: # Release build with Test functionality : - Debug: : - Release: : project: Test.cproject.yml - for-context: \\.*Test*`","title":"Regular Expressions"},{"location":"YML-Input-Format/#multiple-projects","text":"The section \"Configure Related Projects\" describes the organization of multiple projects. The file *.csolution.yml describes the relationship of these projects and may also re-map target-types: and build-types: for projects using context-map: .","title":"Multiple Projects"},{"location":"YML-Input-Format/#projects","text":"The YAML structure of the section projects: is: projects: Content - project: Optional Path to the project file. west: Optional Enable West \"build orchestration wrapper\" for Zephyr projects. for-context: Optional Include project for a list of build and target types. not-for-context: Optional Exclude project for a list of build and target types. !!! Notes: project and west nodes are mutually exclusive (ToDo) Examples: This example uses two projects that are built in parallel using the same build-type: and target-type: . Such a setup is typical for multi-processor systems. projects: - project: ./CM0/CM0.cproject.yml # include project for Cortex-M0 processor - project: ./CM4/CM4.cproject.yml # include project for Cortex-M4 processor This example uses multiple projects but with additional controls. projects: - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # build only when 'target-type: CM0-Addon' is selected - project: ./CM0/CM0.cproject.yml # specify cproject.yml file for-context: +CM0-Addon # specify use case - project: ./Debug/Debug.cproject.yml # specify cproject.yml file not-for-context: .Release # generated for any 'build-type:' except 'Release' - west: # enable west build orchestration wrapper app-path: ./blinky # specify a zephyr application path","title":"projects:"},{"location":"YML-Input-Format/#source-file-management","text":"Keyword Used in files Description groups: *.cproject.yml , *.clayer.yml Start of a list that adds source groups and files to a project or layer. layers: *.cproject.yml Start of a list that adds software layers to a project. components: *.cproject.yml , *.clayer.yml Start of a list that adds software components to a project or layer.","title":"Source File Management"},{"location":"YML-Input-Format/#groups","text":"The groups: keyword specifies a list that adds source groups and files to a project or layer: groups: Content - group: Required Name of the group. for-context: Optional Include group for a list of build and target types. not-for-context: Optional Exclude group for a list of build and target types. for-compiler: Optional Include group for a list of compilers. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. groups: Optional Start a nested list of groups. files: Optional Start a list of files. Example: See files: section.","title":"groups:"},{"location":"YML-Input-Format/#files","text":"Add source files to a project. files: Content - file: Required Name of the file. for-context: Optional Include file for a list of build and target types. not-for-context: Optional Exclude file for a list of build and target types. for-compiler: Optional Include file for a list of compilers. category: Optional Explicit file category to overwrite filename extension assignment. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. Note It is also possible to specify a Linker Script . Files with the extension .sct , .scf , .ld , and .icf are recognized as Linker Script files. Example: Add source files to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. groups: - group: \"Main File Group\" not-for-context: # includes this group not for the following: - .Release+Virtual # build-type 'Release' and target-type 'Virtual' - .Test-DSP+Virtual # build-type 'Test-DSP' and target-type 'Virtual' - +Board # target-type 'Board' files: - file: file1a.c - file: file1b.c define: - a: 1 undefine: - b optimize: size - group: \"Other File Group\" files: - file: file2a.c for-context: +Virtual # include this file only for target-type 'Virtual' define: - test: 2 - file: file2a.c not-for-context: +Virtual # include this file not for target-type 'Virtual' - file: file2b.c - group: \"Nested Group\" groups: - group: Subgroup1 files: - file: file-sub1-1.c - file: file-sub1-2.c - group: Subgroup2 files: - file: file-sub2-1.c - file: file-sub2-2.c It is also possible to include a file group for a specific compiler using for-compiler: or a specific target-type and/or build-type using for-context: or not-for-context: . groups: - group: \"Main File Group\" for-compiler: AC6 # includes this group only for Arm Compiler 6 files: - file: file1a.c - file: file2a.c - group: \"Main File Group\" for-compiler: GCC # includes this group only for GCC Compiler files: - file: file1b.c - file: file2b.c Using category: allows to specify pre-include files that are project-wide or related only to the group: . A global pre-include file is added to the compiler command line for all modules of the whole project (globally). - group: \"Main File Group\" files: - file: SystemDefinitions.h category: preIncludeGlobal A local pre-include file is added to the compiler command line for all modules of a group (locally). - group: \"Group 2\" files: - file: MyDefinitions.h category: preIncludeLocal","title":"files:"},{"location":"YML-Input-Format/#layers","text":"Add a software layer to a project. Used in *.cproject.yml files. layers: Content - layer: Optional Path to the *.clayer.yml file that defines the layer. type: Optional Refers to an expected layer type. for-context: Optional Include layer for a list of build and target types. not-for-context: Optional Exclude layer for a list of build and target types. Example: layers: # Socket - layer: ./Socket/FreeRTOS+TCP/Socket.clayer.yml for-context: - +IP-Stack - layer: ./Socket/WiFi/Socket.clayer.yml for-context: - +WiFi - layer: ./Socket/VSocket/Socket.clayer.yml for-context: - +AVH # Board - layer: ./Board/IMXRT1050-EVKB/Board.clayer.yml for-context: - +IP-Stack # - +WiFi - layer: ./Board/B-U585I-IOT02A/Board.clayer.yml for-context: - +WiFi - layer: ./Board/AVH_MPS3_Corstone-300/Board.clayer.yml for-context: - +AVH","title":"layers:"},{"location":"YML-Input-Format/#layer-type","text":"The layer: - type: is used in combination with the meta-data of the connections: to check the list of available *.clayer.yml files for matching layers. Instead of an explicit layer: node that specifies a *.clayer.yml file, the type: is used to search for matching layers with the csolution command list layers . Example: layers: - type: Socket # search for matching layers of type `Socket` - type: Board # search for matching layers of type `Board` When combined with variables: it is possible to define the required *.clayer.yml files at the level of the *.csolution.yml file. Refer to variables: for an example.","title":"layer: type:"},{"location":"YML-Input-Format/#components","text":"Add software components to a project or a software layer. Used in *.cproject.yml and *.clayer.yml files. components: Content - component: Required Name of the software component. for-context: Optional Include component for a list of build and target types. not-for-context: Optional Exclude component for a list of build and target types. language-C: Optional Set the language standard for C source file compilation. language-CPP: Optional Set the language standard for C++ source file compilation. optimize: Optional Optimize level for code generation. link-time-optimize: Optional Enable optimization at linker level. debug: Optional Generation of debug information. warnings: Optional Control generation of compiler diagnostics. define: Optional Define symbol settings for C/C++ code generation. define-asm: Optional Define symbol settings for Assembler code generation. undefine: Optional Remove define symbol settings for code generation. add-path: Optional Additional include file paths for C/C++ source files. add-path-asm: Optional Additional include file paths for assembly source files. del-path: Optional Remove specific include file paths. misc: Optional Literal tool-specific controls. instances: Optional Add multiple instances of component configuration files (default: 1) Example: components: - component: ARM::CMSIS:RTOS2:FreeRTOS&Cortex-M - component: ARM::RTOS&FreeRTOS:Config&CMSIS RTOS2 - component: ARM::RTOS&FreeRTOS:Core&Cortex-M - component: ARM::RTOS&FreeRTOS:Event Groups - component: ARM::RTOS&FreeRTOS:Heap&Heap_5 - component: ARM::RTOS&FreeRTOS:Stream Buffer - component: ARM::RTOS&FreeRTOS:Timers - component: ARM::Security:mbed TLS define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" - component: AWS::FreeRTOS:backoffAlgorithm - component: AWS::FreeRTOS:coreMQTT - component: AWS::FreeRTOS:coreMQTT Agent - component: AWS::FreeRTOS:corePKCS11&Custom define: - MBEDTLS_CONFIG_FILE: \"aws_mbedtls_config.h\" Note The name format for a software component is described under Name Conventions - Component Name Conventions .","title":"components:"},{"location":"YML-Input-Format/#instances","text":"Allows to add multiple instances of a component and actually applies to configuration files. For detailed description refer to Open-CMSIS-Pack specification - Component Instances Example: components: - component: USB:Device instances: 2 If the user selects multiple instances of the same component, all files with the attribute config in the *.PDSC file will be copied multiple times to the project. The name of the component (for example config_mylib.h) will get a postfix _n whereby n is the instance number starting with 0. Instance 0: config_usb_device_0.h Instance 1: config_usb_device_1.h The availability of instances in a project can be made public in the RTE_Components.h file. The existing way to extend the %Instance% with the instance number n .","title":"instances:"},{"location":"YML-Input-Format/#west-build","text":"Enable the West build system integration and add Zephyr application images to the csolution project .","title":"West Build"},{"location":"YML-Input-Format/#west","text":"Use the command west build to generate images from application source code specified in the west: node. When the west: node is applied (even with an empty app-path source directory list), the environment variables for the west build system are created based on the compiler: selection. west: Content app-path: Required Path to the application source directory. project-id: Optional Project identifier (default: last sub-dir name of app-path ). board: Optional Board name used for west build invocation (default: variable $west-board$ ). device: Optional Specify the processor core for execution of the generated image (used in *.cbuild-run.yml ). west-defs: Optional Defines in CMake format. The west-defs: from build and target-type are added. west-opt: Optional Options for the west tool (default: empty).","title":"west:"},{"location":"YML-Input-Format/#west-defs","text":"Defines for the west build commands are specified in CMake format. The west-defs: that are defined under the active target and build type are concatinated as follows: <west-defs> := <west:west-defs> + <target-type:west-defs> + <build-type:west-defs> The information provided with the west: and west-def: nodes are used to generate the command line for the west tool: >west <west-opt> build --board <board> --build-dir $SolutionDir()$/out/<project-id>/$TargetType$ --pristine {auto | always} <app-path> -- <west-defs> Notes The generated image files in the build directory (zephyr/zephyr.elf, zephyr/zephyr.hex) are added to the output: node in *.cbuild-run.yml . The CMSIS build system configures the environment variables for west . The --sysbuild option is not supported as the csolution project manages multiple applications and images. The cbuild orchestration instructs west calls with --pristine auto option. The cbuild option --rebuild cleans temporary files before proceeding with a new build. Examples: ToDo","title":"west-defs:"},{"location":"YML-Input-Format/#prepost-build-steps","text":"The CMSIS-Toolbox supports pre-build and post-build steps that utilize external tools or scripts. Such external commands can be used for various tasks such as: pre-process source files. add checksums to a binary file. combine multiple ELF files into a single image. add a timestamp to an image ( always: ensures execution in every build). sign images for a bootloader.","title":"Pre/Post Build Steps"},{"location":"YML-Input-Format/#executes","text":"Execute an external command for pre or post-build steps used in the *.csolution.yml and *.cproject.yml files. The input: and output: files are used for dependency checking and scheduling the execution (as a pre-build or post-build step) during the build process of an application (option --context is not used). Other CMake Build scripts may be integrated into the overall build process using the executes: node. Refer to Build Operation - CMake Integration for an example that utilizes a file converter for website images. The structure of the executes: node is: executes: Content - execute: Required The identifier is used as a CMake target name and must not contain spaces and special characters; recommended is less than 32 characters. run: Required Command string with the name of the program or script (optionally with path) along with argument string. always: Optional When present, the build step always runs and bypasses check for outdated output: files. input: Optional A list of input files (may contain Access Sequences ). output: Optional A list of output files (may contain Access Sequences ). for-context: Optional Run command for a list of build and target types (only supported in *.cproject.yml ). not-for-context: Optional Exclude run command for a list of build and target types (only supported in *.cproject.yml ). The run: command string uses these sequences to access input files and output files: run: command file access Description $input$ List of all input files separated by semicolon (;) character. $input(<n>)$ Input file in the list with index <n> ; first item is <n>=0 . $output$ List of all output files separated by semicolon (;) character. $output(<n>)$ Output file in the list with index <n> ; first item is <n>=0 . The run: command string also accepts these access sequences : $Bname$, $Dname$, $Pname$, $BuildType$, $TargetType$, $Compiler$, $Solution$, $Project$. It does not accept access sequences that reference directories or files as this bypasses the project dependency check . Instead use the input: list to pass files or directories. Consider the following: The execute: node is processed by the CMake build system. The order of execution depends on $input$ and $output files and is evaluated by CMake. The execute: node is processed only for an application build when no --context option is specified. The option --context-set can be used. CMake uses Linux-style path names with / characters; it does not accept the Windows-style \\ characters in the run: node to specify the location of an executable tool. CMake provides several builtin command-line tools (copy, checksum, etc.) that run on every Host OS. Consider using these command-line tools instead of Windows or Linux-specific commands. Use CMake -E help to list the available commands. The base directory for execution is not controlled by the CMSIS-Toolbox and is typically the tmp directory. The commands specified by run: should be in the path of the Host OS or the path/tool should be passed using an $input(<n>)$ argument. At the *.csolution.yml level for-context: and not-for-context: is not evaluated. Examples: The tool gen_image combines multiple input images. It is called together with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). solution: # executed as part of a complete solution build : executes: - execute: GenImage # generate final download image run: gen_image $input$ -o $output$ --sign # command string input: - $elf(Application)$ # combine these project parts - $elf(TFM)$ - $elf(Bootloader)$ output: - $SolutionDir()$/$Solution$.out # output file name The Windows batch file KeyGen.bat converts an input file keyfile.txt to a C source file. combines multiple input images. It is called together with the list of elf files that are created by the various projects. It runs when cbuild executes a solution build (option --context is not used). project: # executed as part of a project build executes: - execute: GenerateEncryptionKeys run: $input(1)$ $input(0)$ -o $output$ always: # always generate the keyfile.c as it has a timestamp input: - $ProjectDir()$/keyfile.txt # contains the key in text format - $SolutionDir()$/KeyGen.bat output: - $ProjectDir()$/keyfile.c # output as C source file that is part of this project The built-in CMake command-line tool copy is used to copy the ELF output file. project: # executed as part of a project build executes: - execute: copy-elf run: ${CMAKE_COMMAND} -E copy $input$ $output$ input: - $elf()$ output: - $OutDir()$/Project.out for-context: .Release For examples of integrating CMake scripts, refer to Build Operation\u2014CMake Integration .","title":"executes:"},{"location":"YML-Input-Format/#auto-select-layers","text":"To find compatible layers in software packs, projects and layers can be annotated. The command csolution list layers lists compatible layers. This enables reference applications that work across a range of different hardware targets where: The *.cproject.yml file of the reference application lists with the connections: node the required functionality with consumes: . The *.clayer.yml project part lists with the connections: node the implemented functionality with provides: . Example projects that use connections: for layer selection: MDK-Middleware examples use board layers to run on different hardware boards. Sensor SDK Example shows how board layers and shield layers may be used to run different sensor shields on many boards. [AWS_MQTT_Demo}(https://github.com/Arm-Examples/AWS_MQTT_Demo) combines the board layer and communication socket layer. Optionally a shield layer can be used to connect WiFi drivers.","title":"Auto-select Layers"},{"location":"YML-Input-Format/#connections","text":"The connections: node contains meta-data that describes the compatibility of the *.cproject.yml and *.clayer.yml project parts. The connections: node lists functionality (drivers, pins, and other software or hardware resources). The node consumes: lists required functionality; the node provides: is the implemented functionality of that project part. This works across multiple levels, which means that a *.clayer.yml file could also require other functionality using consumes: . The connections: node is used to identify compatible software layers. These software layers could be stored in CMSIS software packs using the following structure: A reference application described in a *.cproject.yml file could be provided in a git repository. This reference application uses software layers that are provided in CMSIS software packs. A CMSIS Board Support Pack (BSP) contains a configured board layer described in a *.clayer.yml file. This software layer is pre-configured for a range of use cases and provides drivers for I2C and SPI interfaces, along with pin definitions and provisions for an Arduino shield. For a sensor, a CMSIS software pack contains the sensor middleware and software layer ( *.clayer.yml ) that describes the hardware of the Arduino sensor shield. This shield can be applied to many different hardware boards that provide an Arduino shield connector. This connections: node enables therefore software reuse in multiple ways: The board layer can be used by many different reference applications, as the provided: functionality enables a wide range of use cases. The sensor hardware shield and middleware can be used across many different boards that provide an Ardunio shield connector and board layer support. The structure of the connections: node is: connections: Description - connect: Required Lists specific functionality with a brief verbal description","title":"connections:"},{"location":"YML-Input-Format/#connect","text":"The connect: node describes one or more functionalities that belong together. connect: Description set: Optional Specifies a config-id . select value that identifies a configuration option info: Optional Verbal description displayed when this connect is selected provides: Optional List of functionality ( key / value pairs) that are provided consumes: Optional List of functionality ( key / value pairs) that are required The behaviour of the connect: node depends on the usage in csolution project files. In a cproject.yml file the connect: node is always active. In a clayer.yml file the connect: node is only active if one or more key listed under provides: is listed under consumes: in other active connect: nodes. It is also active by default if the connect: node has no provides: node. Example: In the example below the connect for: Sensor Communication Interface is only active when the SENSOR_I2C is in the consumes: list of other active connect nodes. Sensor Interrupt is only active when the SENSOR_INT is in the consumes: list of other active connect nodes. Core Functionality is always active as it does not have a provides: list. layer: type: Shield connections: - connect: Sensor Communication Interface provides: - SENSOR_I2C consumes: - ARDUINO_UNO_I2C - connect: Sensor Interrupt provides: - SENSOR_INT consumes: - ARDUINO_UNO_D2 - connect: Core Functionality consumes: - CMSIS-RTOS2","title":"connect:"},{"location":"YML-Input-Format/#set","text":"Some hardware boards have configuration settings (DIP switch or jumper) that configure interfaces. These settings have an impact on the functionality (for example, hardware interfaces). With set: config-id . select , the possible configuration options are considered when evaluating compatible *.cproject.yml and *.clayer.yml project parts. The csolution Project Manager iterates the connect: node with a set: config-id . select as described below: For each config-id only one connect: node with a select value is active at a time. Each possible select value is checked for a matching configuration. When project parts have a matching configuration, the set: value along with the info: is shown to the user. This allows the user to enable the correct hardware options. Refer to Example: Sensor Shield for a usage example.","title":"set:"},{"location":"YML-Input-Format/#provides","text":"A user-defined key / value pair list of functionality that is implemented or provided by a project: or layer: . The csolution Project Manager combines all the key / value pairs that are listed under provides: and matches them with the key / value pairs that are listed under consumes: . For key / value pairs listed under provides: the following rules exist for a match with consumes: key / value pair: It is possible to omit the value . It matches with an identical key listed in consumes: A value is interpreted as a number. Depending on the value prefix, this number must be: when consumes: value is a plain number identical to this value. when consumes: value is prefixed with + , higher or equal then this value or the sum of all values in multiple consumes: nodes.","title":"provides:"},{"location":"YML-Input-Format/#consumes","text":"A user-defined key / value pair list of functionality that is required or consumed by a project: or layer: . For key / value pairs listed under consumed: the following rules exist: When no value is specified, it matches with any value of an identical key listed under provides: . A value is interpreted as a number. This number must be identical in the provides: value pair. A value that is prefixed with + is interpreted as a number that is added together in case that the same key is listed multiple times under consumes: . The sum of this value must be lower or equal to the value upper limit of the provides: key .","title":"consumes:"},{"location":"YML-Input-Format/#example-board","text":"This connections: node of a board layer describes the available interfaces. The WiFi interface requires a CMSIS-RTOS2 function. connections: # describes the functionality of a board layer - connect: WiFi interface provides: - CMSIS-Driver WiFi: requires: - CMSIS-RTOS2: - connect: SPI and UART interface provides: - CMSIS-Driver SPI: - CMSIS-Driver UART:","title":"Example: Board"},{"location":"YML-Input-Format/#example-simple-project","text":"This shows the connections: node of a complete application project composed of two software layers. MyProject.cproject.yml connections: - connect: all resources provides: - RTOS2: # implements RTOS2 API interface consumes: - IoT_Socket: # requires IoT_Socket interface - STDOUT: # requires STDOUT interface - Heap: +30000 # requires an additional 30000 bytes memory heap : layers: - layer: MySocket.clayer.yml - layer: MyBoard.clayer.yml MySocket.clayer.yml connections: - connect: consumes: - RTOS2: # requires RTOS2 API interface - VSocket: # requires VSocket interface - Heap: +20000 # requires an additional 20000 bytes memory heap provides: - IoT_Socket: # provides IoT_Socket interface MyBoard.clayer.yml connections: - connect: consumes: - RTOS2: provides: - VSocket: - STDOUT: - Heap: 65536","title":"Example: Simple Project"},{"location":"YML-Input-Format/#example-sensor-shield","text":"This sensor shield layer provides a set of interfaces that are configurable. connections: - connect: I2C Interface 'Std' set: comm.I2C-Std info: JP1=Off JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C: - connect: I2C Interface 'Alt' set: comm.I2C-Alt info: JP1=On JP2=Off provides: - Sensor_I2C: consumes: - Ardunio_Uno_I2C-Alt: - connect: SPI Interface 'Alt' set: comm.SPI info: JP2=On provides: - Sensor_SPI: consumes: - Ardunio_Uno_SPI: - connect: Sensor Interrupt INT0 set: SensorIRQ.0 info: JP3=Off provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D2: - connect: Sensor Interrupt INT1 set: SensorIRQ.1 info: JP3=On provides: - Sensor_IRQ: consumes: - Ardunio_Uno_D3:","title":"Example: Sensor Shield"},{"location":"YML-Input-Format/#debugger-configuration","text":"The debugger: node specified under the target-set: in the csolution project configures the debugger. Notes Packs may provide a default configuration for a debugger connection to a device or board. Serveral settings are optional and the default settings are specific to the selected debug adapter. The complete debugger settings including default values are listed in debugger: node of the *.cbuild-run.yml file .","title":"Debugger Configuration"},{"location":"YML-Input-Format/#debugger","text":"debugger: Content name: Required Identifies the debug adapter. *: Optional Other debugger specific options can be used as documented below. The command csolution list debuggers outputs the name: of the supported debug adatpers; using the option --verbose extends the list with alias names that are also accepted as name: There are five different debug adapter categories: Debug Adapter name: Description <adapter>@pyOCD Debug Adapters that interface via pyOCD ( CMSIS-DAP and ST-Link). <adapter>@Arm-Debugger Debug Adapters that interface via the Arm-Debugger. Arm-FVP FVP simulation models that represent processor sub-systems. Keil uVision uVision Debugger that is integrated in the Keil uVision IDE. J-Link Server Segger J-Link debug probes that connect using the J-Link Server. The Arm CMSIS Solution VS Code extension uses the debugger: node to create entries in the files .vscode/tasks.json and .vscode/launch.json for running and debugging using the specified debug adapter. pyOCD supports a command-line mode that uses the *.cbuild-run.yml file which is created by the CMSIS-Toolbox. The following sections describe the options available for the different debug adapter types.","title":"debugger:"},{"location":"YML-Input-Format/#pyocd","text":"This section lists the options that are specific to pyOCD that connects to CMSIS-DAP and ST-Link debug adapters. CMSIS-DAP is a standardized protocol used by many different debug adapters. All CMSIS-DAP enabled debug adapters can be accessed with name: CMSIS-DAP@pyOCD . A specific debug adapter name such as name: ULINKplus@pyOCD provides tailored default settings and a custom configuration dialog in the Arm CMSIS Solution VS Code extension. Extended options are required for rare use cases and further tailor the behaviour of pyOCD.","title":"pyOCD"},{"location":"YML-Input-Format/#debugger-for-pyocd","text":"debugger: Description name: Required Identifies the debug adapter with <adapter>@pyOCD . clock: Optional Debug clock speed in Hz. protocol: Optional Debug portocol (jtag or swd). dbgconf: Optional Configuration file for device settings such as trace pins and option bytes. start-pname: Optional Debugger connects at start to this processor. telnet: Optional Telnet service configuration. trace: Optional Extended Option: Trace configuration. connect: Optional Extended Option: Connect mode to hardware. reset: Optional Extended Option: Reset type configuration for various cores. load-setup: Optional Extended Option: Reset type and Halt configuration for Load command. Examples: debugger: name: CMSIS-DAP@pyOCD protocol: swd clock: 20000000 # 20 MHz debugger: name: ULINKplus protocol: jtag clock: 10000000 # 10 MHz dbgconf: MyHardware.dbgconf","title":"debugger: for pyOCD"},{"location":"YML-Input-Format/#telnet-for-pyocd","text":"Note The telnet: feature will be implemented until Dec 2025. This section is only a preview. pyOCD allows to configure for each processor that runs a independent application an Telnet service that connects to character I/O funtions. Character I/O is supported via Semihosting or Segger RTT channel 0. The telnet: node configures: Telnet port for connecting remote tools, for example the Serial Monitor VS Code extension . Redirect the output to a file , console , port , or monitor . The setting monitor connects a telnet port to the Serial Monitor in VS Code. The default output file and location is derived from the cbuild-run.yml file and uses the extension <pname>.txt , format: <solution-name>+<target-type>.<pname>.out telnet: Description - mode: Required Redirect output: off , server , file , console , monitor . pname: Optional Identifies the processor (not requried for single core system). port: Optional Set TCP/IP port number of Telnet Server (default: 4444, 4445, ... incremented for each processor). file-in: Optional Explicit path and name of the telnet input file. Default: ./out/\\<solution-name>+\\<target-type>.\\<pname>.in file-out: Optional Explicit path and name of the telnet output file. Default: ./out/\\<solution-name>+\\<target-type>.\\<pname>.out Telnet Mode Description server Serial I/O to Telnet server port file Serial I/O to text files. Default: ./out/\\<solution-name\\>+\\<target-type\\>.\\<pname\\>.{in \\| out} console Serial output to console (Debug console in VS Code). monitor Serial I/O via TCP/IP port to VS Code Serial Monitor. off Serial I/O disabled. Note When no telnet node is applied Serial I/O to all processors is disabled. Examples: Enable Telnet service or a single core system. debugger: name: CMSIS-DAP@pyOCD protocol: swd telnet: mode: monitor # Output via TCP/IP port to VS Code Serial Monitor Enable Telnet service or a single core system. debugger: name: CMSIS-DAP@pyOCD protocol: swd telnet: mode: server debugger: name: CMSIS-DAP@pyOCD protocol: swd telnet: - pname: Core0 # enable Telnet service with default settings port: 4444 - pname: Core1 mode: console # route Telnet input/output to console - pname: Core2 mode: file # route Telnet input/output to files","title":"telnet: for pyOCD"},{"location":"YML-Input-Format/#arm-debugger","text":"This section lists options that are specific for the Arm Debugger. debugger: Description name: Required Identifies the debug adapter with <adapter>@Arm-Debugger . clock-armdbg Optional Debug clock speed. Possible values: auto (default), 50MHz, 33MHz, 25MHz, 20MHz, 10MHz, 5MHz, 2MHz, 1MHz, 500kHz, 200kHz, 100kHz, 50kHz, 20kHz, 10kHz, 5kHz protocol-armdbg Optional Debug protocol. Possible values: auto (default), JTAG, SWD Example: debugger: name: CMSIS-DAP@Arm-Debugger protocol-armdbg: SWD clock-armdbg: 5MHz","title":"Arm Debugger"},{"location":"YML-Input-Format/#arm-fvp","text":"This section lists options that are specific to the FVP simulation models. FVPs are configureable simulation models that are designed for software validation. An FVP represents one or more Arm processors.","title":"Arm-FVP"},{"location":"YML-Input-Format/#debugger-for-arm-fvp","text":"debugger: Description name: Required Identifies the debug adapter with Arm-FVP . model: Optional Filename (optionally with path) of the FVP executable. Default: FVP_MPS2_Cortex-M3 . config-file: Optional Path and filename of the FVP configuration file . args: Optional Miscellaneous command line arguments . The following model: executables are installed from the Arm Tools Artifactory . You should use these models in combination with a pack: and device: as listed under \"CMSIS-based projects for AVH FVPs\" . The PATH environment variable of your system can define the path to the FVP executable (then only the model: name from the list below is required. Optionally an explicit path can be specified in the model: node. model: Simulation Model Represents FVP_Corstone 300 Arm Corstone 300 Reference Platform with Cortex-M55 FVP_Corstone_SSE-300_Ethos-U55 Arm Corstone 300 Reference Platform with Cortex-M55 and Ethos-U55 FVP_Corstone_SSE-300_Ethos-U65 Arm Corstone 300 Reference Platform with Cortex-M55 and Ethos-U65 FVP_Corstone 310 Arm Corstone 310 Reference Platform with Cortex-M85 and Ethos-U55. FVP_Corstone_SSE-310_Ethos-U65 Arm Corstone 310 Reference Platform with Cortex-M85 and Ethos-U65. FVP_Corstone 315 Arm Corstone 315 Reference Platform with Cortex-M85, Ethos-U65, and Mali-C55. FVP_Corstone 320 Arm Corstone 320 Reference Platform with Cortex-M85, Ethos-U85, and Mali-C55. FVP_MPS2_Cortex-M0 Arm Microcontroller Prototyping System with Cortex-M0 FVP_MPS2_Cortex-M0plus Arm Microcontroller Prototyping System with Cortex-M0+ FVP_MPS2_Cortex-M3 Arm Microcontroller Prototyping System with Cortex-M3 FVP_MPS2_Cortex-M4 Arm Microcontroller Prototyping System with Cortex-M4 FVP_MPS2_Cortex-M7 Arm Microcontroller Prototyping System with Cortex-M7 FVP_MPS2_Cortex-M23 Arm Microcontroller Prototyping System with Cortex-M23 FVP_MPS2_Cortex-M33 Arm Microcontroller Prototyping System with Cortex-M33 FVP_MPS2_Cortex-M35P Arm Microcontroller Prototyping System with Cortex-M35P FVP_MPS2_Cortex-M52 Arm Microcontroller Prototyping System with Cortex-M52 FVP_MPS2_Cortex-M55 Arm Microcontroller Prototyping System with Cortex-M55 FVP_MPS2_Cortex-M85 Arm Microcontroller Prototyping System with Cortex-M85 Example: debugger: name: CMSIS-DAP@Arm-Debugger model: FVP_Corstone_SSE-320 config-file: ./FVP_Config.txt args: --simlimit 600 # stop simulation after 600 seconds","title":"debugger: for Arm-FVP"},{"location":"YML-Input-Format/#keil-uvision","text":"This section lists options that are specific for the uVision Debugger.","title":"Keil uVision"},{"location":"YML-Input-Format/#debugger-for-keil-uvision","text":"debugger: Description name: Required Identifies the debug adapter with Keil uVision . uv4: Optional Path to the uVision executable; default: C:/Keil_v5/UV4/UV4.exe . debugger: name: Keil uVision","title":"debugger: for Keil uVision"},{"location":"YML-Input-Format/#j-link-server","text":"This section lists options that are specific for the Segger J-Link debug probes. Extended options are required for rare use cases and further tailor the behaviour of J-Link Server.","title":"J-Link Server"},{"location":"YML-Input-Format/#debugger-for-j-link-server","text":"debugger: Description name: Required Identifies the debug adapter with <adapter>@pyOCD . clock: Optional Debug clock speed in Hz. protocol: Optional Debug portocol (jtag or swd). telnet: Optional Telnet service configuration. trace: Optional Trace configuration. connect: Optional Extended Option: Connect mode to hardware. reset: Optional Extended Option: Reset type configuration for various cores. Examples: debugger: name: J-Link Server clock: 4000000 # 4000 kHz protocol: swd","title":"debugger: for J-Link Server"},{"location":"YML-Input-Format/#telnet-for-j-link-server","text":"Note The telnet: feature will be implemented until Dec 2025. This section is only a preview. J-Link supports a Telnet service that connects to character I/O funtions. Character I/O is supported via Semihosting (or Segger RTT channel 0). Currently only semihosting is configured for the primary core. telnet: Description - mode: Required Redirect output: server , console , monitor , off (default). pname: Optional Identifies the processor (not requried for single core system). port: Optional Set TCP/IP port number of Telnet Server (default: 4444, 4445, ... incremented for each processor). Telnet Mode Description server Serial I/O to Telnet server port console Serial output to console (Debug console in VS Code). monitor Serial I/O via TCP/IP port to VS Code Serial Monitor. off Serial I/O disabled. Note The Telnet service is always enabled for the J-Link GDB Server. The mode off turns off the data source (semihosting, Segger RTT). When no telnet node is added then Serial I/O to all processors is set to mode off .","title":"telnet: for J-Link Server"},{"location":"YML-Input-Format/#trace-for-j-link-server","text":"Note The trace: feature is Work-In-Progress and will be completed in Q1'26. J-Link supports SWO Trace. trace: Description clock: Required Trace clock frequency in Hz. mode: Optional Set Trace Port transport mode. Currently only SWO-UART is accepted. port: Optional Set TCP/IP port number of Trace output (default: 4444).","title":"trace: for J-Link Server"},{"location":"YML-Input-Format/#add-memory","text":"Hardware targets may have additional off-chip memory. The memory: node that can be added as additional information to a target type. This information is used for the Run and Debug Management and the Automatic Linker Script generation .","title":"Add Memory"},{"location":"YML-Input-Format/#memory","text":"memory: Content - name: Required Identifier of the memory. access: Required Access attribute string for the memory (see table below). start: Required Base address of the memory. size: Required Size of the memory. pname: Optional Only accessible by the specified processor. algorithm: Optional Programming algorithm for download. The table lists the letters and their meaning for use in the access attribute string. access: Description r Readable w Writable x eXecutable s Secure attribute n Non-secure attribute c non-secure Callable attribute Example: solution: : target-types: - type: MyHardware device: STMicroelectronics::STM32F746NGHx memory: # Additional memory available in MyHardware - name: Ext-Flash # Identifier access: rx # access permission start: 0x40000000 size: 0x200000 algorithm: Flash/Ext-Flash.flm # Programming algorithm","title":"memory:"},{"location":"build-operation/","text":"Theory of Operation This chapter contains technical details about the operation of the CMSIS Toolbox. Build Process Overview details the build process. Adding a Toolchain to CMSIS-Toolbox contains details about the Compiler support. CMake Integration describes the integration of CMake. West Integration describes the integration of the West build system for Zephyr applications. Generator Integration explains the integration of device configuration tools. Debug Adapter Integration explains the integration of debuggers. Build Process Overview This section contains details of the build process. For a high-level description, refer to Overall Workflow . Note The tool options --verbose and --debug enable detailed output about the build process for analysis. Refer to the chapter Build Tools for more information on the command line syntax. cbuild Build Invocation The cbuild utility controls the overall build process. It has two operating modes: build mode generates the application and is the default command (no explicit command required). setup mode generates the setup information for an IDE to populate dialogues, IntelliSense, and project outline views. Details of the build mode Without a specific cbuild command, the application is built. The typical invocation is: cbuild <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] It generates the application program that is described with the <name>.csolution.yml project. When option --packs is used, it downloads missing software packs using cpackget . It calls csolution to process the the <name>.csolution.yml project. With option --update-rte new configuration files from software packs are updated and the RTE_Components.h file is recreated. With option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. With option --frozen-packs the file *.cbuild-pack.yml is used as input to issue an error when a pack version changes. The output are build information files with all relevant project information for the build process. The option --toolchain can be used to explicitly select a compiler. Note By default, the cbuild invocation does not update or change configuration files in the RTE Directory . Use the option --update-rte if this is required. Details of the setup mode The cbuild setup command prepares the data for an IDE environment. This command is called at the start of an IDE or whenever a csolution project file is modified. The typical invocation is: cbuild setup <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] Typical IDE environments use a --context-set that specifies the context configuration of the application. For an application described by a <name>.csolution.yml file, these steps are executed: Check YML file syntax against schema for all files specified by <name>.csolution.yml . Check the correctness of all files specified by <name>.csolution.yml . Evaluate the potential software layers for Reference Applications using variables: to refer to layers (if the value is undefined). All projects are considered in this step. Evaluate the selectable compiler toolchains when the csolution project does not contain a compiler: selection or the --toolchain option is not applied. The available toolchains are based on the compiler registration and the select-compiler: node in the file <name>.csolution.yml or cdefault.yml . Create the file compile_commands.json in the output directory for the context defined in *.cbuild-set.yml . Note The file compile_commands.json is generated by CMake with the option --target <context>-database and contains all source files of the context along with compiler options. It is used by various code analyzer tools and the IntelliSense system of an IDE. The operation is further controlled by options: The option --packs downloads missing software packs. The option --active selects a target-set or build variant that combines various projects with defined build-types. The option --update-rte updates the configuration files of the application. With the option --frozen-packs the file *.cbuild-pack.yml is used as input. An error is issued when a pack version changes. The option --toolchain can be used to explicitly select a compiler. csolution Project Manager csolution processes the csolution project files (in YAML format) and the *.pdsc metadata files of software packs and performs the following operations: In the Project Area : Generate build information files *.cbuild-idx.yml and *.cbuild.yml with all relevant project information for the build process. In the RTE Directory : Generate for each context the RTE_components.h file and pre-include files from the software pack ( *.pdsc ) metadata. Copy the configuration files from selected software componentsand provide PLM information. In the base directory of the solution : Generate the file *.cbuild-pack.yml that records all used software packs . With the option --frozen-packs , this file is used as input. With the option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. When --context names are specified this file is updated with this selection. The picture below outlines the operation. cbuild2cmake Generate CMakeLists Files cbuild2cmake reads the build information files *.cbuild-idx.yml and *.cbuild.yml to get all relevant project information for the build process. It generates the following output files for CMake build system: Output Directory/File Description ./<tmp-dir>/CMakeList.txt Describes the overall application build process with the current context configuration. ./<tmp-dir>/<context> Each context has a separate sub-directory with the following files: ./<tmp-dir>/<context>/CMakeList.txt Describes the build process for this context. ./<tmp-dir>/<context>/toolchain.cmake Describes the toolchain used for this context. ./<tmp-dir>/<context>/groups.cmake Contains all definitions and source files that are related to file groups . ./<tmp-dir>/<context>/components.cmake Contains all definitions and source files that are related to components . CMake Invocation The CMake build system is invoked with the following commands: CMake configuration command defines the build generator, source, and build directory with: cmake -G Ninja -S <tmpdir> -B <tmpdir> -Wnodev CMake build command to build the application program for each context with: cmake --build <tmpdir> -j <n> --target <context> CMake build command to generate the database file compile_commands.json (used by the command cbuild setup ) for each context with: cmake --build <tmpdir> -j <n> --target <context>-database Adding a Toolchain to CMSIS-Toolbox The following section explains how to add a compiler toolchain to the CMSIS-Toolbox. Steps The section below describes the steps to add a new compiler toolchain to the CMSIS-Toolbox. Define a compiler_name for the new compiler toolchain, i.e. CLang . Add this compiler_name to the \"CompilerType\": in the schema file ./tools/projmgr/schemas/common.schema.json . Create a new CMake file in ./tools/buildmgr/cbuildgen/config with the naming convention compiler_name.<version>.cmake . Map with the file compiler_name.<version>.cmake . the CMake input variables to the CMake toolchain variables. Use an existing *.cmake file, i.e. GCC.<version>.cmake as a reference. CMake Variables The CMakeLists.txt file sets the following CMake input variables that should be processed by compiler_name.<version>.cmake . CMake Variable Possible Values Description BYTE_ORDER Little-endian, Big-endian Endian processor configuration CPU DCoreEnum Processor core selection FPU DfpuEnum Floating point unit support DSP DdspEnum DSP instruction set support TZ DtzEnum TrustZone support SECURE DsecureEnum Software model selection MVE DmveEnum MVE instruction set support BRANCHPROT BRANCHPROT values [Branch protection OPTIMIZE Optimize values Generic optimize levels for code generation WARNINGS Warnings values Control warning level for compiler diagnostic DEBUG Debug values Control the generation of debug information DEFINES Define symbols List of symbol #define statements BRANCHPROT Values The following table lists the possible values for the CMake variable BRANCHPROT . Values Description NO_BRANCHPROT Branch protection not used BTI Using BTI (Branch Target ID) BTI_SIGNRET Using BTI + Sign Return The compiler_name.<version>.cmake sets the following CMake variables to specify the toolchain and select toolchain options. CMake Variable Description ASM_CPU , CC_CPU , CXX_CPU Device selection set according to the combination of device attributes ( CPU , FPU , DSP , MVE , etc.) AS_LEG_CPU , AS_ARM_CPU , AS_GNU_CPU Similar to the previous item but for assembly dialect variants (if applicable) ASM_FLAGS , CC_FLAGS , CXX_FLAGS , LD_FLAGS Flags applicable to all modules of the given language CC_SECURE , LD_SECURE Flags applicable only for secure projects _PI Pre-include option _ISYS system include option LIB_PREFIX Generated library name prefix LIB_SUFFIX Generated library name suffix EXE_SUFFIX Generated executable name suffix ELF2HEX Flags for ELF to HEX conversion ELF2BIN Flags for ELF to BIN conversion CMAKE_C_COMPILER_ID CMake compiler identifier CMAKE_C_COMPILER_VERSION CMake compiler version CMake Integration The executes: node in the csolution project files allows the integration of other CMake projects or scripts. Example The following CMakeLists.txt file integrates the FCARM file converter that is part of the MDK-Middleware. The FCARM file converter reformats all web files into a single C-file which is then included and compiled into the project. # CMakeLists.txt for calling FCARM # Find input files in the input base directory and in its subfolders using recursive scanning # Format arguments and generate a steering command file, overcoming any command line length limitation # Call FCARM using the steering command file, generating the source file in the expected output # # Configuration Step: ${CMAKE_COMMAND} -G <generator> -S <source directory> -B <build directory> -DINPUT_DIRECTORY=<input base directory> -DOUTPUT=<output source file> # Build Step: ${CMAKE_COMMAND} --build <build directory> # # <generator>: underlying generator build system, e.g. Ninja # <source directory>: directory where this CMakeLists.txt resides # <build directory>: directory for temp files # <input base directory>: directory where input data is located # <output source file>: path and filename of source file to be generated cmake_minimum_required(VERSION 3.22) include(ExternalProject) project(\"FCARM\" NONE) file(GLOB_RECURSE INPUT ${INPUT_DIRECTORY}/*) foreach(ITEM ${INPUT}) cmake_path(RELATIVE_PATH ITEM BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE FILE) list(APPEND FILES ${FILE}) endforeach() string(REPLACE \";\" \",\\n\" FILES \"${FILES}\") cmake_path(RELATIVE_PATH OUTPUT BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE RELATIVE_OUTPUT) cmake_path(GET INPUT_DIRECTORY FILENAME INPUT_DIRECTORY_NAME) cmake_path(GET INPUT_DIRECTORY PARENT_PATH WORKING_DIRECTORY) set(COMMAND_FILE \"${CMAKE_CURRENT_BINARY_DIR}/Auto_FcArm_Cmd.inp\") file(WRITE ${COMMAND_FILE} \"${FILES}\\nTO ${RELATIVE_OUTPUT} RTE NOPRINT ROOT(${INPUT_DIRECTORY_NAME})\\n\") add_custom_target(FCARM ALL DEPENDS ${OUTPUT}) add_custom_command(OUTPUT ${OUTPUT} DEPENDS ${INPUT} COMMAND fcarm @${COMMAND_FILE} WORKING_DIRECTORY ${WORKING_DIRECTORY} ) Integration in a csolution project . In this case, it is part of the *.csolution.yml , but it may also be part of the *.cproject.yml file that uses the source file Web.c as input. The CMake build system checks for project dependencies and schedules the overall build process. solution: : executes: - execute: Run-FCARM run: ${CMAKE_COMMAND} -G Ninja -S ${INPUT_0} -B ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -DINPUT_DIRECTORY=${INPUT_1} -DOUTPUT=${OUTPUT} && ${CMAKE_COMMAND} --build ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -- --quiet always: input: - fcarm-cmake # CMake script directory - Web # Input directory with \"web files\" for FCARM output: - project/Web.c # Output file for FCARM West Integration The west build system uses two environment variables to configure the toolchain. These variables are set when the *.csolution.yml contains the west: node. It is created by the VS Code CMSIS Solution extension when a terminal is opened (ToDo) or by the cbuild orchestration when west build is called during the setup and build process. The west build command is called for each app-path: that is specified in the west: node. Environment Variable Description ZEPHYR_TOOLCHAIN_VARIANT Toolchain selection depending on the selected compiler: in csolution.yml . Values are: armclang (for AC6), gnuarmemb (for GCC), llvm (for CLANG), iar (for IAR). <TOOLCHAIN>_TOOLCHAIN_PATH Path to selected compiler executable. <TOOLCHAIN> is the capitalized string specified with ZEPHYR_TOOLCHAIN_VARIANT . The value is copied from the compiler registration environment variable . The various build operations of the cbuild tool map as shown below to the west tool. Operation Cbuild Invocation West Invocation Build cbuild <name>.csolution.yml west build -p auto -d <dir> -b <board> <app> Database cbuild setup <name>.csolution.yml west build -p auto -d <dir> -b <board> --cmake-only <app> -- -DCMAKE_EXPORT_COMPILE_COMMANDS=ON The cbuild Clean operation is performed as usual by cleaning temporary and output files, and the cbuild Rebuild triggers a normal build after cleaning. No other west build option is required. Generator Integration The diagram below shows how the STM32CubeMX generator is integrated into the CMSIS build process. The data flow is exemplified on STM32CubeMX (Generator ID for this example is CubeMX ). The information about the project is delivered to the generator using the Generator Information files ( <solution-name>.cbuild-gen-idx.yml and <context>.cbuild-gen.yml ). This information provides CubeMX with the project context, such as the selected board or device, and CPU mode, such as TrustZone, disabled/enabled. The utility cbridge gets as parameter the <solution-name>.cbuild-gen-idx.yml and calls the generator. For the CubeMX generator example, these files are created: *.ioc CubeMX project file with current project settings *.c/.h source files, i.e. for interfacing with drivers <project-name>.cgen.yml (created by cbridge ) provides the data for project import into the csolution build process. Note The NXP MCUXpresso generator has a direct interface to the csolution project format. The utility cbridge is in this case not required as the build information files are the input and the <project-name>.cgen.yml is directly generated. Generator Start via component A <component> element with a generator attribute in a *.PDSC file is used to start the generator. Typically this component is provided in a Device Family Pack (DFP) or a Board Support Pack (BSP). Example component for CubeMX in DFP: <component generator=\"CubeMX\" Cclass=\"Device\" Cgroup=\"CubeMX\" Cversion=\"0.9.0\"> <description>Configure device or board with STM32CubeMX</description> </component> Note No <generator> element in the *.PDSC file is required when the Global Generator Registry File is used. The generator=\"id\" attribute of the <component> element in the *.PDSC file is the reference to the - id: list node in the global.generator.yml file. Global Generator Registry File For generators with no <generator> element in the *.PDSC file, the global.generator.yml in the CMSIS-Toolbox ./etc directory contains is used. The generator: node in this YAML file registers the supported generators with the following keys: generator: Content - id: Required <generator-id> referred in the *.PDSC file download-url: Optional URL for downloading the generator run: Required Name and location of the utility that starts the generator path: Required Output directory of the generator. Contains the file *.cgen.yml . generator: - id: CubeMX download-url: https://www.st.com/en/development-tools/stm32cubemx.html#st-get-software run: ../bin/cbridge path: $SolutionDir()$/STM32CubeMX/$TargetType$ Note The only argument to the run: command is the path to the Generator Information Index File . There are no configurable parameters for this utility. The invocation is: cbrige <csolution-name>.cbuild-gen-idx.yml Add Configuration Generator The following steps add a new generator to the CMSIS-Toolbox: Add a Generator Start Component to a software pack (for device configuration typically the DFP). Add the configuration utility to the Global Generator Registry File with a pull request to the devtools repository . The generator tool specified with run: is called with the *.cbuild-gen-idx.yml file as command line parameter. This file also specifies the output directory for the generated files. The generator tool should generate a *.cgen.yml file and other source files that are included in the project. An example project where you can explore this process is CubeMX . It contains an example for a *.cgen.yml file . Debug Adapter Integration The file debug-adapters.yml in the CMSIS-Toolbox ./etc directory contains the list of supported debug adapters. If no debugger is specified for a csolution project , the first debug adapter (\"CMSIS-DAP@pyOCD\") contained in this file will be used. The debug-adapters: node in this YAML file registers the supported debug adapters with the following keys: debug-adapters: Content - name: Required <generator-id> referred in the *.PDSC file alias-name: Optional List of names (in input node or BSP) that map to this debug adapter. template: Optional Used only by the VS Code CMSIS Solution extension for configuration. gdbserver: Optional Add the gdbserver: node in the cbuild-run.yml file. defaults: Optional List of default options to use when not specified in the target-set: node. user-interface: Optional Defines the user interface for VS Code CMSIS Solution extension. Note As the file is shared with the VS Code CMSIS Solution extension, also template files are references. However these template files are not part of the CMSIS-Toolbox. The debugger name: <none> identifies no debugger configuration. With this setting, no template: is applied and the .vscode configuration files are not modified. Example debug-adapters.yml debug-adapters: - name: \"CMSIS-DAP@pyOCD\" alias-name: [\"CMSIS-DAP\", \"DAP-Link\"] # alternative names that map to this debug adapter template: CMSIS-DAP-pyOCD.adapter.json # template file gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: 10000000 - name: \"ULINKplus\" template: CMSIS-DAP-pyOCD.adapter.json # template file (initally same as CMSIS-DAP@pyOCD) gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: 10000000 - name: \"ST-Link@pyOCD\" alias-name: [\"ST-LINK\"] # alternative names that map to this debug adapter template: STLink-pyOCD.adapter.json # template file gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: 10000000 - name: \"J-Link Server\" template: jlink.adapter.json # template file defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: auto - name: \"AVH-FVP\" template: FVP.adapter.json # template file - name: \"Keil uVision\" template: uVision.adapter.json # template file User Interface The file debug-adapters.yml also contains the information for the user interface that is available in the VS Code CMSIS Solution extension. The options are added user-interface: Content - section: Required Label text for configuration section. description: Optional Hover over text. yml-node: Optional If present, options are under this group node in the debugger: section. select: Optional If present, the section can be enabled. Applies to all options. options: Optional List of available options. pname-options: Optional List of available options that are repeated for each pname. Note When a section: is disabled all nodes are removed from the csolution.yml file. options: Content - name: Required Label text for the option in the user interface. description: Optional Hover over text. yml-node: Required Name of the node in the csolution file under debugger: section. type: Required Type (enum: value list, number: value, string: name, file: name). range: Optional Value range for type int. values: Optional Value list for type enum. default: Optional Default value (or enum name) for user interface when no value given in csolution.yml. scale: Optional The value in csolution.yml value is multiplied by the scale factor. values: Content - name: Required Label text for the option in the user interface. value: Optional Value used for the enum name in csolution.yml file. If empty, name is used as value . description: Optional Descriptive text (hover over or sub-text in dialog). Example solution: : target-set: - set: debugger:0 name: CMSIS-DAP@pyOCD protocol: swd clock: 10000000 # SWD clock = 10MHz trace: mode: UART clock: 120000000 # Trace clock = 120 MHz telnet: # Enable telnet with defaults Example debug-adapters.yml debug-adapters: - name: \"CMSIS-DAP@pyOCD\" alias-name: [\"CMSIS-DAP\", \"DAP-Link\"] # alternative names that map to this debug adapter template: CMSIS-DAP-pyOCD.adapter.json # template file gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # this section is only used by csolution to provide default values when settings are missing port: 3333 # default value of first gdbserver port protocol: swd clock: 1000 user-interface: # this section is only used by the UI to display and edit settings - section: Debug Interface description: Interface configuration for the debug port options: - name: Clock (kHz) # UI display description: Trace configuration # hover over text yml-node: clock # node entry in csolution.yml type: int # type of value range: [10, 5000] # valid range default: 1000 # default value if not specified anywhere - name: Protocol yml-node: protocol type: enum values: - name: JTAG value: jtag - name: SWD value: swd default: SWD - section: Trace description: Trace configuration # hover over text yml-node: trace # when a yml node is given options are under this section select: off options: - name: Clock (kHz) yml-node: trace-clock type: number range: [10, 200000] # 10 kHz .. 200 MHz default: 12000 - name: Mode yml-node: trace-port type: enum values: - name: UART # UART is also used as value description: SWO configured for UART protocol - name: Manchester value: Man description: SWO configured for Manchester protocol - name: Trace Port 4 value: TP4 description: Connection via 4-bit Trace port default: UART - section: Telnet description: Telnet server configuration # hover over text yml-node: telnet select: off pname-option: - title: Port yml-node: port type: inumber range: [1, 100000] default: 4444 - name: \"J-Link Server\" - section: Debug Interface description: Interface configuration for the debug port options: - name: Clock (kHz) # UI display description: JTAG/SWO clock frequency # hover over text yml-node: clock # node entry in csolution.yml type: number # type of value range: [10, 5000] # valid range default: 4000 # default value if not specified anywhere - name: Protocol yml-node: protocol type: enum values: - name: SWD value: swd default: SWD - section: Trace description: Trace configuration # hover over text yml-node: trace # only on/off option select: off options: - name: Mode yml-node: trace-port type: enum values: name: UART default: UART - name: \"Keil uVision\" template: uVision.adapter.json # template file defaults: uv4: \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\" args: [] user-interface: # this section is only used by the UI to display and edit settings - section: Setup description: Configure uVision settings options: - name: Path description: Absolute path to uVision executable yml-node: uv4 # node entry in csolution.yml type: file # type of value default: \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\"","title":"Theory of Operation"},{"location":"build-operation/#theory-of-operation","text":"This chapter contains technical details about the operation of the CMSIS Toolbox. Build Process Overview details the build process. Adding a Toolchain to CMSIS-Toolbox contains details about the Compiler support. CMake Integration describes the integration of CMake. West Integration describes the integration of the West build system for Zephyr applications. Generator Integration explains the integration of device configuration tools. Debug Adapter Integration explains the integration of debuggers.","title":"Theory of Operation"},{"location":"build-operation/#build-process-overview","text":"This section contains details of the build process. For a high-level description, refer to Overall Workflow . Note The tool options --verbose and --debug enable detailed output about the build process for analysis. Refer to the chapter Build Tools for more information on the command line syntax.","title":"Build Process Overview"},{"location":"build-operation/#cbuild-build-invocation","text":"The cbuild utility controls the overall build process. It has two operating modes: build mode generates the application and is the default command (no explicit command required). setup mode generates the setup information for an IDE to populate dialogues, IntelliSense, and project outline views.","title":"cbuild Build Invocation"},{"location":"build-operation/#details-of-the-build-mode","text":"Without a specific cbuild command, the application is built. The typical invocation is: cbuild <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] It generates the application program that is described with the <name>.csolution.yml project. When option --packs is used, it downloads missing software packs using cpackget . It calls csolution to process the the <name>.csolution.yml project. With option --update-rte new configuration files from software packs are updated and the RTE_Components.h file is recreated. With option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. With option --frozen-packs the file *.cbuild-pack.yml is used as input to issue an error when a pack version changes. The output are build information files with all relevant project information for the build process. The option --toolchain can be used to explicitly select a compiler. Note By default, the cbuild invocation does not update or change configuration files in the RTE Directory . Use the option --update-rte if this is required.","title":"Details of the build mode"},{"location":"build-operation/#details-of-the-setup-mode","text":"The cbuild setup command prepares the data for an IDE environment. This command is called at the start of an IDE or whenever a csolution project file is modified. The typical invocation is: cbuild setup <name>.csolution.yml [--packs] [--context-set] [--update-rte] [--frozen-packs] Typical IDE environments use a --context-set that specifies the context configuration of the application. For an application described by a <name>.csolution.yml file, these steps are executed: Check YML file syntax against schema for all files specified by <name>.csolution.yml . Check the correctness of all files specified by <name>.csolution.yml . Evaluate the potential software layers for Reference Applications using variables: to refer to layers (if the value is undefined). All projects are considered in this step. Evaluate the selectable compiler toolchains when the csolution project does not contain a compiler: selection or the --toolchain option is not applied. The available toolchains are based on the compiler registration and the select-compiler: node in the file <name>.csolution.yml or cdefault.yml . Create the file compile_commands.json in the output directory for the context defined in *.cbuild-set.yml . Note The file compile_commands.json is generated by CMake with the option --target <context>-database and contains all source files of the context along with compiler options. It is used by various code analyzer tools and the IntelliSense system of an IDE. The operation is further controlled by options: The option --packs downloads missing software packs. The option --active selects a target-set or build variant that combines various projects with defined build-types. The option --update-rte updates the configuration files of the application. With the option --frozen-packs the file *.cbuild-pack.yml is used as input. An error is issued when a pack version changes. The option --toolchain can be used to explicitly select a compiler.","title":"Details of the setup mode"},{"location":"build-operation/#csolution-project-manager","text":"csolution processes the csolution project files (in YAML format) and the *.pdsc metadata files of software packs and performs the following operations: In the Project Area : Generate build information files *.cbuild-idx.yml and *.cbuild.yml with all relevant project information for the build process. In the RTE Directory : Generate for each context the RTE_components.h file and pre-include files from the software pack ( *.pdsc ) metadata. Copy the configuration files from selected software componentsand provide PLM information. In the base directory of the solution : Generate the file *.cbuild-pack.yml that records all used software packs . With the option --frozen-packs , this file is used as input. With the option --context-set the file *.cbuild-set.yml specifies the context configuration of the application. When --context names are specified this file is updated with this selection. The picture below outlines the operation.","title":"csolution Project Manager"},{"location":"build-operation/#cbuild2cmake-generate-cmakelists-files","text":"cbuild2cmake reads the build information files *.cbuild-idx.yml and *.cbuild.yml to get all relevant project information for the build process. It generates the following output files for CMake build system: Output Directory/File Description ./<tmp-dir>/CMakeList.txt Describes the overall application build process with the current context configuration. ./<tmp-dir>/<context> Each context has a separate sub-directory with the following files: ./<tmp-dir>/<context>/CMakeList.txt Describes the build process for this context. ./<tmp-dir>/<context>/toolchain.cmake Describes the toolchain used for this context. ./<tmp-dir>/<context>/groups.cmake Contains all definitions and source files that are related to file groups . ./<tmp-dir>/<context>/components.cmake Contains all definitions and source files that are related to components .","title":"cbuild2cmake Generate CMakeLists Files"},{"location":"build-operation/#cmake-invocation","text":"The CMake build system is invoked with the following commands: CMake configuration command defines the build generator, source, and build directory with: cmake -G Ninja -S <tmpdir> -B <tmpdir> -Wnodev CMake build command to build the application program for each context with: cmake --build <tmpdir> -j <n> --target <context> CMake build command to generate the database file compile_commands.json (used by the command cbuild setup ) for each context with: cmake --build <tmpdir> -j <n> --target <context>-database","title":"CMake Invocation"},{"location":"build-operation/#adding-a-toolchain-to-cmsis-toolbox","text":"The following section explains how to add a compiler toolchain to the CMSIS-Toolbox.","title":"Adding a Toolchain to CMSIS-Toolbox"},{"location":"build-operation/#steps","text":"The section below describes the steps to add a new compiler toolchain to the CMSIS-Toolbox. Define a compiler_name for the new compiler toolchain, i.e. CLang . Add this compiler_name to the \"CompilerType\": in the schema file ./tools/projmgr/schemas/common.schema.json . Create a new CMake file in ./tools/buildmgr/cbuildgen/config with the naming convention compiler_name.<version>.cmake . Map with the file compiler_name.<version>.cmake . the CMake input variables to the CMake toolchain variables. Use an existing *.cmake file, i.e. GCC.<version>.cmake as a reference.","title":"Steps"},{"location":"build-operation/#cmake-variables","text":"The CMakeLists.txt file sets the following CMake input variables that should be processed by compiler_name.<version>.cmake . CMake Variable Possible Values Description BYTE_ORDER Little-endian, Big-endian Endian processor configuration CPU DCoreEnum Processor core selection FPU DfpuEnum Floating point unit support DSP DdspEnum DSP instruction set support TZ DtzEnum TrustZone support SECURE DsecureEnum Software model selection MVE DmveEnum MVE instruction set support BRANCHPROT BRANCHPROT values [Branch protection OPTIMIZE Optimize values Generic optimize levels for code generation WARNINGS Warnings values Control warning level for compiler diagnostic DEBUG Debug values Control the generation of debug information DEFINES Define symbols List of symbol #define statements","title":"CMake Variables"},{"location":"build-operation/#branchprot-values","text":"The following table lists the possible values for the CMake variable BRANCHPROT . Values Description NO_BRANCHPROT Branch protection not used BTI Using BTI (Branch Target ID) BTI_SIGNRET Using BTI + Sign Return The compiler_name.<version>.cmake sets the following CMake variables to specify the toolchain and select toolchain options. CMake Variable Description ASM_CPU , CC_CPU , CXX_CPU Device selection set according to the combination of device attributes ( CPU , FPU , DSP , MVE , etc.) AS_LEG_CPU , AS_ARM_CPU , AS_GNU_CPU Similar to the previous item but for assembly dialect variants (if applicable) ASM_FLAGS , CC_FLAGS , CXX_FLAGS , LD_FLAGS Flags applicable to all modules of the given language CC_SECURE , LD_SECURE Flags applicable only for secure projects _PI Pre-include option _ISYS system include option LIB_PREFIX Generated library name prefix LIB_SUFFIX Generated library name suffix EXE_SUFFIX Generated executable name suffix ELF2HEX Flags for ELF to HEX conversion ELF2BIN Flags for ELF to BIN conversion CMAKE_C_COMPILER_ID CMake compiler identifier CMAKE_C_COMPILER_VERSION CMake compiler version","title":"BRANCHPROT Values"},{"location":"build-operation/#cmake-integration","text":"The executes: node in the csolution project files allows the integration of other CMake projects or scripts.","title":"CMake Integration"},{"location":"build-operation/#example","text":"The following CMakeLists.txt file integrates the FCARM file converter that is part of the MDK-Middleware. The FCARM file converter reformats all web files into a single C-file which is then included and compiled into the project. # CMakeLists.txt for calling FCARM # Find input files in the input base directory and in its subfolders using recursive scanning # Format arguments and generate a steering command file, overcoming any command line length limitation # Call FCARM using the steering command file, generating the source file in the expected output # # Configuration Step: ${CMAKE_COMMAND} -G <generator> -S <source directory> -B <build directory> -DINPUT_DIRECTORY=<input base directory> -DOUTPUT=<output source file> # Build Step: ${CMAKE_COMMAND} --build <build directory> # # <generator>: underlying generator build system, e.g. Ninja # <source directory>: directory where this CMakeLists.txt resides # <build directory>: directory for temp files # <input base directory>: directory where input data is located # <output source file>: path and filename of source file to be generated cmake_minimum_required(VERSION 3.22) include(ExternalProject) project(\"FCARM\" NONE) file(GLOB_RECURSE INPUT ${INPUT_DIRECTORY}/*) foreach(ITEM ${INPUT}) cmake_path(RELATIVE_PATH ITEM BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE FILE) list(APPEND FILES ${FILE}) endforeach() string(REPLACE \";\" \",\\n\" FILES \"${FILES}\") cmake_path(RELATIVE_PATH OUTPUT BASE_DIRECTORY ${INPUT_DIRECTORY} OUTPUT_VARIABLE RELATIVE_OUTPUT) cmake_path(GET INPUT_DIRECTORY FILENAME INPUT_DIRECTORY_NAME) cmake_path(GET INPUT_DIRECTORY PARENT_PATH WORKING_DIRECTORY) set(COMMAND_FILE \"${CMAKE_CURRENT_BINARY_DIR}/Auto_FcArm_Cmd.inp\") file(WRITE ${COMMAND_FILE} \"${FILES}\\nTO ${RELATIVE_OUTPUT} RTE NOPRINT ROOT(${INPUT_DIRECTORY_NAME})\\n\") add_custom_target(FCARM ALL DEPENDS ${OUTPUT}) add_custom_command(OUTPUT ${OUTPUT} DEPENDS ${INPUT} COMMAND fcarm @${COMMAND_FILE} WORKING_DIRECTORY ${WORKING_DIRECTORY} ) Integration in a csolution project . In this case, it is part of the *.csolution.yml , but it may also be part of the *.cproject.yml file that uses the source file Web.c as input. The CMake build system checks for project dependencies and schedules the overall build process. solution: : executes: - execute: Run-FCARM run: ${CMAKE_COMMAND} -G Ninja -S ${INPUT_0} -B ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -DINPUT_DIRECTORY=${INPUT_1} -DOUTPUT=${OUTPUT} && ${CMAKE_COMMAND} --build ${CMAKE_CURRENT_BINARY_DIR}/fcarm-cmake -- --quiet always: input: - fcarm-cmake # CMake script directory - Web # Input directory with \"web files\" for FCARM output: - project/Web.c # Output file for FCARM","title":"Example"},{"location":"build-operation/#west-integration","text":"The west build system uses two environment variables to configure the toolchain. These variables are set when the *.csolution.yml contains the west: node. It is created by the VS Code CMSIS Solution extension when a terminal is opened (ToDo) or by the cbuild orchestration when west build is called during the setup and build process. The west build command is called for each app-path: that is specified in the west: node. Environment Variable Description ZEPHYR_TOOLCHAIN_VARIANT Toolchain selection depending on the selected compiler: in csolution.yml . Values are: armclang (for AC6), gnuarmemb (for GCC), llvm (for CLANG), iar (for IAR). <TOOLCHAIN>_TOOLCHAIN_PATH Path to selected compiler executable. <TOOLCHAIN> is the capitalized string specified with ZEPHYR_TOOLCHAIN_VARIANT . The value is copied from the compiler registration environment variable . The various build operations of the cbuild tool map as shown below to the west tool. Operation Cbuild Invocation West Invocation Build cbuild <name>.csolution.yml west build -p auto -d <dir> -b <board> <app> Database cbuild setup <name>.csolution.yml west build -p auto -d <dir> -b <board> --cmake-only <app> -- -DCMAKE_EXPORT_COMPILE_COMMANDS=ON The cbuild Clean operation is performed as usual by cleaning temporary and output files, and the cbuild Rebuild triggers a normal build after cleaning. No other west build option is required.","title":"West Integration"},{"location":"build-operation/#generator-integration","text":"The diagram below shows how the STM32CubeMX generator is integrated into the CMSIS build process. The data flow is exemplified on STM32CubeMX (Generator ID for this example is CubeMX ). The information about the project is delivered to the generator using the Generator Information files ( <solution-name>.cbuild-gen-idx.yml and <context>.cbuild-gen.yml ). This information provides CubeMX with the project context, such as the selected board or device, and CPU mode, such as TrustZone, disabled/enabled. The utility cbridge gets as parameter the <solution-name>.cbuild-gen-idx.yml and calls the generator. For the CubeMX generator example, these files are created: *.ioc CubeMX project file with current project settings *.c/.h source files, i.e. for interfacing with drivers <project-name>.cgen.yml (created by cbridge ) provides the data for project import into the csolution build process. Note The NXP MCUXpresso generator has a direct interface to the csolution project format. The utility cbridge is in this case not required as the build information files are the input and the <project-name>.cgen.yml is directly generated.","title":"Generator Integration"},{"location":"build-operation/#generator-start-via-component","text":"A <component> element with a generator attribute in a *.PDSC file is used to start the generator. Typically this component is provided in a Device Family Pack (DFP) or a Board Support Pack (BSP). Example component for CubeMX in DFP: <component generator=\"CubeMX\" Cclass=\"Device\" Cgroup=\"CubeMX\" Cversion=\"0.9.0\"> <description>Configure device or board with STM32CubeMX</description> </component> Note No <generator> element in the *.PDSC file is required when the Global Generator Registry File is used. The generator=\"id\" attribute of the <component> element in the *.PDSC file is the reference to the - id: list node in the global.generator.yml file.","title":"Generator Start via component"},{"location":"build-operation/#global-generator-registry-file","text":"For generators with no <generator> element in the *.PDSC file, the global.generator.yml in the CMSIS-Toolbox ./etc directory contains is used. The generator: node in this YAML file registers the supported generators with the following keys: generator: Content - id: Required <generator-id> referred in the *.PDSC file download-url: Optional URL for downloading the generator run: Required Name and location of the utility that starts the generator path: Required Output directory of the generator. Contains the file *.cgen.yml . generator: - id: CubeMX download-url: https://www.st.com/en/development-tools/stm32cubemx.html#st-get-software run: ../bin/cbridge path: $SolutionDir()$/STM32CubeMX/$TargetType$ Note The only argument to the run: command is the path to the Generator Information Index File . There are no configurable parameters for this utility. The invocation is: cbrige <csolution-name>.cbuild-gen-idx.yml","title":"Global Generator Registry File"},{"location":"build-operation/#add-configuration-generator","text":"The following steps add a new generator to the CMSIS-Toolbox: Add a Generator Start Component to a software pack (for device configuration typically the DFP). Add the configuration utility to the Global Generator Registry File with a pull request to the devtools repository . The generator tool specified with run: is called with the *.cbuild-gen-idx.yml file as command line parameter. This file also specifies the output directory for the generated files. The generator tool should generate a *.cgen.yml file and other source files that are included in the project. An example project where you can explore this process is CubeMX . It contains an example for a *.cgen.yml file .","title":"Add Configuration Generator"},{"location":"build-operation/#debug-adapter-integration","text":"The file debug-adapters.yml in the CMSIS-Toolbox ./etc directory contains the list of supported debug adapters. If no debugger is specified for a csolution project , the first debug adapter (\"CMSIS-DAP@pyOCD\") contained in this file will be used. The debug-adapters: node in this YAML file registers the supported debug adapters with the following keys: debug-adapters: Content - name: Required <generator-id> referred in the *.PDSC file alias-name: Optional List of names (in input node or BSP) that map to this debug adapter. template: Optional Used only by the VS Code CMSIS Solution extension for configuration. gdbserver: Optional Add the gdbserver: node in the cbuild-run.yml file. defaults: Optional List of default options to use when not specified in the target-set: node. user-interface: Optional Defines the user interface for VS Code CMSIS Solution extension. Note As the file is shared with the VS Code CMSIS Solution extension, also template files are references. However these template files are not part of the CMSIS-Toolbox. The debugger name: <none> identifies no debugger configuration. With this setting, no template: is applied and the .vscode configuration files are not modified. Example debug-adapters.yml debug-adapters: - name: \"CMSIS-DAP@pyOCD\" alias-name: [\"CMSIS-DAP\", \"DAP-Link\"] # alternative names that map to this debug adapter template: CMSIS-DAP-pyOCD.adapter.json # template file gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: 10000000 - name: \"ULINKplus\" template: CMSIS-DAP-pyOCD.adapter.json # template file (initally same as CMSIS-DAP@pyOCD) gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: 10000000 - name: \"ST-Link@pyOCD\" alias-name: [\"ST-LINK\"] # alternative names that map to this debug adapter template: STLink-pyOCD.adapter.json # template file gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: 10000000 - name: \"J-Link Server\" template: jlink.adapter.json # template file defaults: # default values to use when nowhere specified port: 3333 # default value of first gdbserver port protocol: swd clock: auto - name: \"AVH-FVP\" template: FVP.adapter.json # template file - name: \"Keil uVision\" template: uVision.adapter.json # template file","title":"Debug Adapter Integration"},{"location":"build-operation/#user-interface","text":"The file debug-adapters.yml also contains the information for the user interface that is available in the VS Code CMSIS Solution extension. The options are added user-interface: Content - section: Required Label text for configuration section. description: Optional Hover over text. yml-node: Optional If present, options are under this group node in the debugger: section. select: Optional If present, the section can be enabled. Applies to all options. options: Optional List of available options. pname-options: Optional List of available options that are repeated for each pname. Note When a section: is disabled all nodes are removed from the csolution.yml file. options: Content - name: Required Label text for the option in the user interface. description: Optional Hover over text. yml-node: Required Name of the node in the csolution file under debugger: section. type: Required Type (enum: value list, number: value, string: name, file: name). range: Optional Value range for type int. values: Optional Value list for type enum. default: Optional Default value (or enum name) for user interface when no value given in csolution.yml. scale: Optional The value in csolution.yml value is multiplied by the scale factor. values: Content - name: Required Label text for the option in the user interface. value: Optional Value used for the enum name in csolution.yml file. If empty, name is used as value . description: Optional Descriptive text (hover over or sub-text in dialog). Example solution: : target-set: - set: debugger:0 name: CMSIS-DAP@pyOCD protocol: swd clock: 10000000 # SWD clock = 10MHz trace: mode: UART clock: 120000000 # Trace clock = 120 MHz telnet: # Enable telnet with defaults Example debug-adapters.yml debug-adapters: - name: \"CMSIS-DAP@pyOCD\" alias-name: [\"CMSIS-DAP\", \"DAP-Link\"] # alternative names that map to this debug adapter template: CMSIS-DAP-pyOCD.adapter.json # template file gdbserver: # add gdbserver: node under debugger: in cbuild-run.yml defaults: # this section is only used by csolution to provide default values when settings are missing port: 3333 # default value of first gdbserver port protocol: swd clock: 1000 user-interface: # this section is only used by the UI to display and edit settings - section: Debug Interface description: Interface configuration for the debug port options: - name: Clock (kHz) # UI display description: Trace configuration # hover over text yml-node: clock # node entry in csolution.yml type: int # type of value range: [10, 5000] # valid range default: 1000 # default value if not specified anywhere - name: Protocol yml-node: protocol type: enum values: - name: JTAG value: jtag - name: SWD value: swd default: SWD - section: Trace description: Trace configuration # hover over text yml-node: trace # when a yml node is given options are under this section select: off options: - name: Clock (kHz) yml-node: trace-clock type: number range: [10, 200000] # 10 kHz .. 200 MHz default: 12000 - name: Mode yml-node: trace-port type: enum values: - name: UART # UART is also used as value description: SWO configured for UART protocol - name: Manchester value: Man description: SWO configured for Manchester protocol - name: Trace Port 4 value: TP4 description: Connection via 4-bit Trace port default: UART - section: Telnet description: Telnet server configuration # hover over text yml-node: telnet select: off pname-option: - title: Port yml-node: port type: inumber range: [1, 100000] default: 4444 - name: \"J-Link Server\" - section: Debug Interface description: Interface configuration for the debug port options: - name: Clock (kHz) # UI display description: JTAG/SWO clock frequency # hover over text yml-node: clock # node entry in csolution.yml type: number # type of value range: [10, 5000] # valid range default: 4000 # default value if not specified anywhere - name: Protocol yml-node: protocol type: enum values: - name: SWD value: swd default: SWD - section: Trace description: Trace configuration # hover over text yml-node: trace # only on/off option select: off options: - name: Mode yml-node: trace-port type: enum values: name: UART default: UART - name: \"Keil uVision\" template: uVision.adapter.json # template file defaults: uv4: \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\" args: [] user-interface: # this section is only used by the UI to display and edit settings - section: Setup description: Configure uVision settings options: - name: Path description: Absolute path to uVision executable yml-node: uv4 # node entry in csolution.yml type: file # type of value default: \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\"","title":"User Interface"},{"location":"build-overview/","text":"CSolution Project Structure This chapter outlines the structure of csolution project files that contain the build information of the software application. Project Examples and project templates help to get started with the tools. Software Layers provide reusable configurations and give projects a better structure. Directory Structure describes the overall directory structure of projects. Linker Script Management defines the available memory and controls the linker operation. Generator Support integrates configuration tools such as STM32CubeMX or MCUXpresso Config. Run and Debug Configuration explains how to configure debug adapters such as CMSIS-DAP or J-Link. West Build System Integration allows to manage Zephyr applications in context with a csolution project . Overview of Operation The diagram below outlines the operation of the csolution command convert that processes the csolution project with one or more context configurations for an application. Tip Project Examples show different project types and provide templates for user projects. Build Process Overview explains the complete end-to-end build process. Input Files Description Generic Software Packs Provide re-usable software components that are typically configurable towards a user application. DFP Software Pack Device-related information (including memory sizes) for the tool configuration. BSP Software Pack Board specific configuration (i.e. additional memory resources). cdefault.yml When enabled with cdefault: , setup of toolchain specific controls and pre-defined toolchains. *.csolution.yml Complete scope of the application with sub-projects. Defines target and build types. *.cproject.yml Content of an independent build step (linker or library archiver run). *.clayer.yml Set of source files along with pre-configured components for reuse in different applications. Input/Output Files Description *.cbuild-pack.yml Exact list of the packs that are used by the application; enables reproducible builds as it locks the pack versions. *.cbuild-set.yml Specifies the context set of projects, target-types, and build-types that are used to generate the application image. Output Files Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.yml Build description of a single *.cproject.yml input file for each context. *.cbuild-run.yml Configuration file of a csolution project to run and debug an application on a target. Run-Time Environment (RTE) Contains the user-configured files of a project along with the RTE_Components.h inventory file. Linker Script Files Header file that describes the memory resources. To generate the build information of an application project, the csolution command convert executes the following steps: Read Input Files ( csolution project and Software Packs ) Process each project context (defined by a target-set or the option: --context ): Apply pack: , device: , board: , and compiler: to filter the content of software packs. From groups: add the list of user source files. From components: add the list of component source files. Generate Output Files : Update configuration files in RTE directory (disable with option: --no-update-rte ). Print results of software component dependency validation. Source Code of Software Packs Software packs and the related components: allow you to share and reuse code. The content of a software pack is, therefore, read-only (with the exception of configuration files that are copied to the RTE directory ) as these source code files should not be modified by a user. The benefit is a clean project directory that only contains the user code and configuration files for components: . This keeps a repository small and makes it easy to upgrade to a new pack version . Note During the development of a software pack, you may install a repository , which contains the source of the software pack. You may copy the content of a software pack to your project workspace and provide a path to the pack . Project Examples GitHub repositories The following repositories provide several working examples: Repository Description csolution-examples Contains several getting started examples that show single-core, multi-core, and TrustZone setup as well as how to use a generator (CubeMX). github.com/Arm-Examples Contains many examples that include CMSIS-Toolbox setup. The section below explains the overall concepts considered by the csolution Project Manager based on examples. Template Projects The following *.csolution.yml templates may be used to create embedded applications. Template Description Simple A csolution.yml template with a single *.cproject.yml . Multicore A csolution.yml template with multiple *.cproject.yml files, each targeting one processor of a multicore device. TrustZone A csolution.yml template with a non-secure *.cproject.yml and an optional secure *.cproject.yml file. UnitTest A csolution.yml template that shares one HAL *.clayer.yml with multiple *.cproject.yml files for unit testing. To use these templates, copy the content of the folder to your own application folder. Then adapt the names accordingly and add missing information. Refer to CMSIS-Toolbox Templates for more details. Minimal Project Setup A minimal application requires two files: Sample.csolution.yml that defines a target type with board or device . It includes a project and selects a compiler . Sample.cproject.yml defines the files and software components that are translated into an image or library archive. Note When no packs: are specified in csolution project files , the tools use the latest version of the installed packs. Simple Project: Sample.csolution.yml solution: cdefault: # use default setup for toolchains compiler: AC6 # select the compiler to use packs: # explicit pack selection may be omitted - pack: NXP::K32L3A60_DFP@16.0.0 # specify DFP - pack: NXP::FRDM-K32L3A6_BSP@16.0.0 target-types: - type: FRDM-K32L3A6 board: FRDM-K32L3A6 build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Sample.cproject.yml Simple Project: Sample.cproject.yml project: packs: - pack: ARM::CMSIS # specify additional packs groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup Context A context is defined in the *.csolution.yml file by projects: , target-types: , and build-types: . It identifies a configuration with project-name , build-type , and target-type and is used on various places in the CMSIS-Toolbox. The following context refers to the example above and selects the project: Sample.cproject.yml with build-type: Debug and target-type: FRDM-K32L3A6 : Sample.Debug+FRDM-K32L3A6 The context allows you to refer to each possible build combination that, by default, uses a different output directory . A context may be partly specified in many places. The context-set defines a combination of projects and is useful when an application is composed of multiple related projects . Toolchain Agnostic Project Generic Translation Control settings enable projects that work across the range of supported compilers (AC6, GCC, IAR, CLANG). The Translation Control settings are mapped to specify compiler controls by the build tools. cdefault.yml The cdefault.yml file contains a common set of compiler-specific settings that select reasonable defaults with misc: controls for each compiler. The cdefault: node in the *.csolution.yml file enables the usage of this file. The directory <cmsis-toolbox-installation-dir>/etc contains a cdefault.yml file that is used when no local copy of the cdefault.yml file is provided. Note It is recommended that a local copy of the cdefault.yml file be provided in the same directory that stores the *.csolution.yml file. Example: default: misc: - for-compiler: AC6 C-CPP: - -Wno-macro-redefined - -Wno-pragma-pack - -Wno-parentheses-equality - -Wno-license-management C: - -std=gnu11 ASM: - -masm=auto Link: - --entry=Reset_Handler - --map - --info summarysizes - --summary_stderr - --diag_suppress=L6314W - for-compiler: GCC C-CPP: - -masm-syntax-unified - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - --specs=nano.specs - --specs=nosys.specs - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - -Wl,--no-warn-rwx-segments # suppress incorrect linker warning - for-compiler: CLANG C-CPP: - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - -lcrt0 - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - for-compiler: IAR C-CPP: - --dlib_config DLib_Config_Full.h Link: - --map=$elf()$.map Compiler Selection There are two ways to select a toolchain: An explicit compiler: selection in the *.csolution.yml project file: solution: cdefault: # use the cdefault.yml file with toolchain specific controls compiler: AC6 # select Arm Compiler : The command line option --toolchain of the cbuild or csolution tool overwrites any compiler: definition in the csolution project files. cbuild Hello.csolution.yml --toolchain GCC Tip Toolchain agnostic example projects do not contain a compiler: selection in the *.csolution.yml project file. Instead the select-compiler: node list the compilers that this csolution project is tested with. The VS Code extension Arm CMSIS Solution adds the compiler: node based on the installed compiler in your environment. Reproducible builds Reproducible builds are supported by the *.cbuild-pack.yml file that is created and read by the csolution project manager. This file: Records the exact list of the pack versions used during the creation of an application. Ensures that pack versions do not change during development, even when new packs are installed on the host computer, for example, to develop other applications. Note The *.cbuild-pack.yml file should be committed to a repository to ensure reproducible builds. The cbuild option --frozen-packs checks that the *.cbuild-pack.yml file exists and reports an error if any pack is changed or not available. To update a pack to a new version, delete the file *.cbuild-pack.yml or remove the information about a specific pack in this file. Repository Contents To support reproducible builds, the following files should be committed to a repository of a version control system. All user source code files. All csolution project files ( cdefault.yml , *.csolution.yml , *.cproject.yml , etc.). All files in the RTE directory Ensure that there are no files with the extension .update@ as this indicates that configuration files are not up-to-date due to updated software packs. The file *.cbuild-pack.yml to allow reproducible builds . Optionally, the file *.cbuild-set.yml defines the application's context set that should be generated. Note If the file *.cbuild-set.yml file is missing, the setup command creates a *.cbuild-set file with a selection of the first target-type and the first build-type . Configure Related Projects A solution is the software view of the complete system. It combines projects that can be generated independently and therefore, manages related projects. It may also be deployed to different targets during development as described in section Software Layers . The picture below shows a system that is composed of: Project A that implements a time-critical control algorithm running on an independent processor #2. Project B is a cloud-connected IoT application with Machine Learning (ML) functionality. Project C is the separate data model of the ML algorithm, allowing independent updates. Project D implements the device security (for example, with TF-M that runs with TrustZone in secure mode). In addition, such systems may have a boot-loader that can also be implemented as another independent project. At the level of the *.csolution.yml file, the target-types: and build-types: are managed so that a common set is available across all *.cproject.yml files in the system. target-types: typically describe a different hardware target system. build-types: typically describe a build variant of the same hardware target system. Both types are used for peripherals and the same hardware configuration but may compile a different variant (i.e. with test I/O enabled) of an application. Related Projects: iot-product.csolution.yml solution: : # setup not shown target-types: - type: Board board: NUCLEO-L552ZE-Q # uses device defined by the board - type: Production-HW device: STM32U5X # specifies device build-types: - type: Debug optimize: none debug: on - type: Release optimize: balanced debug: on - type: Test optimize: size debug: on projects: - project: ./security/TFM.cproject.yml # Project D: Only generated for build type: Release for-context: .Release - project: ./application/MQTT_AWS.cproject.yml # Project B - project: ./mldata/Model.cproject.yml # Project C - project: ./bootloader/Bootloader.cproject.yml # Not generated for target type: Board not-for-context: +Board - project: ./processor2/Control.cproject.yml # Project A Working with target-set A target-set: specifies the context types and additional images that are combined into an application. The following example defines the Run and Debug configurations for the iot-product.csolution.yml application that is shown above using the target-set: node. Note Run and Debug Configuration shows how a debugger: is specified for a build variant that is defined with target-set: . solution: : # setup not shown target-types: - type: Board board: NUCLEO-L552ZE-Q # uses device defined by the board target-set: - set: # default set for this target images: - project-context: MQTT_AWS.Debug - project-context: Control.Debug - type: Production-HW device: STM32U5X # specifies device - set: # default set for this target images: # all projects as release version - project-context: Bootloader.Release - project-context: TFM.Release - project-context: MQTT_AWS.Release - project-context: Model.Release - project-context: Control.Release - set: Debug # alternative set for debugging on Production-HW images: # projects and images required for debugging - image: Bootloader_Dummy.hex # use an dummy image - project-context: TFM.Release - project-context: MQTT_AWS.Debug # load debug build - image: Model_Test.hex # use a test Model Using the Build Tools option --active (or -a ) generates the different build variants: cbuild iot-product.csolution.yml -a Board # target-type Board with default set cbuild iot-product.csolution.yml -a Production-HW # target-type Production-HW with default set cbuild iot-product.csolution.yml -a Production-HW@Debug # target-type Production-HW with Debug set Working with context-set Note With CMSIS-Toolbox version 2.9 or higher the target-set: is introduced. It is recommended to use target-set: instead of the --context-set option as the --context-set option may be deprecated. Frequently, it is required to build applications with different context types. The following command line example generates the iot-product.csolution.yml with build type Debug for the project MQTT_AWS.cproject.yml , while the other projects use the build type Release . When using the option -S or --context-set , this selection is saved to the file iot-product.cbuild-set.yml located in the same directory as the *.csolution.yml file. Refer to File Structure of *.cbuild-set.yml for details. cbuild iot-product.csolution.yml -c TFM.Release+Board -c MQTT_AWS.Debug+Board -c Bootloader.Release+Board -S The saved context-set ( iot-product.cbuild-set.yml ) is used when the option -S or --context-set is used without option --context or -c . cbuild iot-product.csolution.yml -S Rules for context-set The same target-type must be selected for all projects. Only one build-type can be selected for a project. Projects that are not required can be excluded. Note The VS Code extension Arm CMSIS Solution always uses a context-set that is selected in the Manage Solution view. External Tools and Build Order The executes: node integrates CMake scripts, projects, and external tools. The input: and output: list typically refers to files and therefore define the build order of projects: When input: contains files that are the output of a cproject.yml , this project part is built first. When output: contains files that are the input of a cproject.yml , the execute: node is built first. Example: The KeyGenerator tool builds the file keys.c , which is added as a source file: for other projects. Using cbuild My.csolution.yml [--context-set] starts the build process of the application and runs the KeyGenerator before building projects that use the source file keys.c as input. Note Using cbuild with the option --context does not run execute: nodes as it triggers project builds only. The option --context-set must be used. solution: : executes: - execute: GenKeys # is a CMake target name run: KeyGenerator -k $input(0)$ -p $input(1)$ -o $output$ input: - $SolutionDir()$/keyfile.txt # input(0) contains key in text format - $SolutionDir()$/passcode.txt # input(1) contains passcode in text format output: - $SolutionDir()$/keys.c # output keys source file (input to other projects) Project Dependency An access sequence that refers to the output of another project also impacts the build order. Example: The access sequence $cmse-lib(Project_S)$ includes the secure entry library of Project_S . Hence, Project_S is built before the non-secure project part of the application. project: # Non-secure project : groups: - group: CMSE Library files: - file: $cmse-lib(Project_S)$ # Secure part of an application Software Layers Software layers collect source files and software components along with configuration files for reuse in different projects. Software Layers gives projects a better structure and simplifies: Development flows with evaluation boards and production hardware. Evaluation of middleware and hardware modules across different microcontroller boards. Code reuse across projects, i.e. board support for test-case deployment. Test-driven software development on simulation model and hardware. Simple Example: This example uses a layer to include an RTOS kernel. The file MyProject.cproject.yml includes the file RTOS.clayer.yml using the layers: node: project: groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup layers: - layer: ../Layer/RTOS.clayer.yml # Add RTOS kernel The RTOS.clayer.yml file defines the kernel along with configuration settings. layer: description: RTX RTOS with configuration settings packs: - pack: ARM:CMSIS-RTX components: - component: CMSIS:RTOS2:Keil RTX5&Source The diagram below shows two different scenarios, which are explained in the following sections. Target Production Hardware Software development frequently starts on evaluation boards. Using a board layer simplifies re-targeting to production hardware. The following *.csolution.yml file exemplifies the concept. A software developer starts with a board layer for the evaluation board in the folder MyBoard . Once the production hardware is available, this layer is copied to a different folder (i.e. MyHardware ). As both layers are independently managed, the configuration of the MyHardware layer can be modified, for example, to target different devices, pin layout, or peripheral configurations. In the *.csolution.yml project, the layer is defined using a variable . By changing the target-type during the build process, the software developer can continue to use the evaluation board or target the production hardware. solution: cdefault: compiler: AC6 target-types: - type: EvalBoard board: STMicroelectronics::B-U585I-IOT02A:Rev.C device: STMicroelectronics::STM32U585AIIx variables: - Board-Layer: $SolutionDir()$/MyBoard/Board.clayer.yml - type: ProductionHW device: STMicroelectronics::STM32U575AIIx # uses a different device variables: - Board-Layer: $SolutionDir()$/MyHardware/Board.clayer.yml build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: HID/HID.cproject.yml Tip The MDK-Middleware examples are structured in this way. Start with a board layer that is provided in several Board Support Packs . Another project that extends this concept to hardware shields is the Sensor-SDK-Example . Test Case Project Modern software design mandates for test-driven development that utilize DevOps or CI principals. Simulation models such as the Arm Virtual Hardware (AVH) FVP allow test automation without target hardware. However, in some cases, tests should also be performed on physical hardware. A test case project may, therefore, contain targets for simulation and physical hardware. The csolution project format allows multiple test projects to be combined to validate different parts of the application. solution: cdefault: compiler: GCC : # pack definition not shown target-types: - type: Board board: NUCLEO-L552ZE-Q variables: - Board-Layer: ./Board/NUCLEO-L552ZE-Q/Board.clayer.yml - type: Virtual board: VHT-Corstone-300 # Virtual Hardware platform (appears as a board) variables: - Board-Layer: ./Board/Corstone-300/AVH.clayer.yml projects: - project: ./TestSuite1/TestCases.cproject.yml - project: ./TestSuite2/TestCases.cproject.yml - project: ./TestSuite3/TestCases.cproject.yml Tip Several examples for Arm Virtual Hardware (AVH) FVP simulation models show usage of csolution projects in CI workflows. The project AVH-MLOps-Main is a test project that shows retargeting to different processors using a layer. The project AWS_MQTT_Demo extends this concept with retargeting of an IP communication to virtual or physical hardware. Configuration Settings A software layer is a set of source files and pre-configured software components or source code that can be shared across multiple projects. To achieve this, the configuration files of a layer are stored within the directory structure of the software layer. This separate RTE Directory Structure allows that projects can share a layer with common configuration settings. Note When using a generator, such as CubeMX or MCUxpresso, the output should be redirected as described under Configure Generator Output . Software Layers in Packs Software layers for reference applications may be published in software packs. For more information, refer to Pack Creation \u00bb Layers . Directory Structure This section describes how the csolution based project files should be organized to allow the scenarios described above. This section also gives guidelines for a directory structure. Refer to Directory Control for information about configuring these directories. Working Areas The table below explains the different working area sections of an application project. Working Area Access Description Project Area RW Contains user source code files managed by the user along with the project files (see next item). Project files RW Created by a user or an IDE to describe the application project. Component source code RO Content of software packs; the location is specified by the environment variable CMSIS_PACK_ROOT or the node pack: path in project files. Component Configuration\u200b RW User-editable config files of software components that are copied to the RTE directory. Generator artifacts\u200b RO (see note) Managed by domain-specific configuration tools such as STM32CubeMX or MCUXpresso. Build artifacts RW Created during the build process for example by a compiler. Note Some generators allow user modification of the generated files. For example, STM32CubeMX allows modification of source code between /* USER CODE BEGIN */ and /* USER CODE END */ and preserves this modification even when the STM32CubeMX regenerates the files. Project Area There are no strict rules on how to organize the project area that stores the user source code. However, the following guidelines apply: Each solution should have a distinct base directory. This directory contains the file *.csolution.yml which refers to the independent projects defined with *.cproject.yml files. Each project should have a distinct base directory. This directory contains the file *.cproject.yml , which defines the project's content. The project's source code might be grouped in subdirectories that are typically stored in this base directory. The configuration files of the software components are typically stored in a subdirectory with the name ./RTE . A *.cproject.yml may refer to one or more software layers with *.clayer.yml files. Each software layer should have a distinct base directory with a similar structure as a project. This base directory contains the file *.clayer.yml that defines the content of the software layer. It also contains the user source code (optionally organized in sub-directories) and the configuration\u200b files of software components that belong to this layer, typically stored in a sub-directory with the name ./RTE . RTE Directory Structure The table below summarizes the overall directory structure and further details the ./RTE directory. The ./RTE directory contains the configuration information for software components and is managed by the csolution Project Manager . It contains: Configuration files of the software components. These files have attr=\"config\" in the PDSC-file of the software packs. Refer to PLM of Configuration Files for more information. The file RTE_components.h and pre-include files are generated based on the software packs' PDSC file information. Note The ./RTE directory structure is maintained by tools. You should not modify its structure. However, the complete directory should be committed to a repository of a version control system. Directory Structure Content <csolution> Base directory that contains one or more *.csolution.yml files. <project> Each project has its own directory; this base directory contains the *.cproject.yml file. <project>/RTE/<Cclass> Configurable files for each component Cclass have a common directory. <project>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory. <project>/RTE/<context-dir> Directory for RTE_components.h and pre-include files that are generated by the csolution Project Manager . <layer> Each layer has its own base directory; this directory contains the *.clayer.yml file. <layer>/RTE/<Cclass> Configurable files for each component Cclass have a common directory below the layer base directory. <layer>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory below the layer base directory. The <context-dir> has the following format: _<build-type>_<target-type> . Note cbuild no longer generates the <context-dir> by default. It is, therefore, required to align the naming of <context-dir> with other tools (MDK, CMSIS-Pack-Eclipse, etc.) that support the CMSIS-Pack system. Output Directory Structure By default, the following output directories are used. Use cbuild to generate the content of these output directories. Output Content ./out/<project>/<target>/<build> Contains the final binary and symbol files of a project context. Software Components Software components are re-usable library or source files that do not require modification in the user application. Optionally, configurable source and header files are provided to allow the setting of parameters for the software component. Configurable source and header files are copied to the project using the directory structure explained above. Libraries, source, and header files that are not configurable (and need no modification) are stored in the directory of the software component (typically part of CMSIS_Pack_ROOT) and get included directly from this location into the project. An include path to the header files of the software component is added to the C/C++ Compiler control string. Notes The csolution command convert provides the option --no-update-rte that disables the generation of files in the ./RTE directory and, therefore the management of configuration files and the RTE_Components.h file. The csolution command update-rte only updates the configuration files in the RTE directory. Using the option --verbose outputs additional version details. PLM of Configuration Files Configurable source and header files have a piece of version information that is required during Project Lifetime Management (PLM) of a project. The version number is important when the underlying software pack changes and provides a newer configuration file version. Depending on the PLM status of the application, csolution performs the following operation for configuration files: Add a software component for the first time. Upgrade (or downgrade) a software component. Add When adding a software component for the first time, the related config file is copied twice into the related RTE project directory. The first copy can be modified by the user with the parameters for the user application. The second copy is an unmodified backup file with the format <configfile>.<ext>.base@version . Example: A configuration file ConfigFile.h at version 1.2.0 is copied: ./RTE/component_class/ConfigFile.h // user editable configuration file ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison csolution shows a user notification to indicate that files have been added: ./RTE/component_class/ConfigFile.h - info: component 'name' added configuration file version '1.2.0' Note The unmodified files with @version information should be committed to the repository of the version control system as these files are used to upgrade configuration information using merge utilities. Upgrade When upgrading (or downgrading) a software component, the version information of the configuration file is considered. If the version of the unmodified backup file is identical, no operation is performed. If the version differs, the new configuration file is copied with the format <configfile>.<ext>.update@version . Example: after updating the configuration file ConfigFile.h to version 1.3.0 , the directory contains these files: ./RTE/component_class/ConfigFile.h // user editable configuration file (based on the current version) ./RTE/component_class/ConfigFile.h.update@1.3.0 // new configuration file; used to start a 3-way merge ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison csolution displays a user notification to indicate that configuration files have changed: ./RTE/component_class/ConfigFile.h - warning: component 'name' upgrade for configuration file version '1.3.0' added, but file inactive User action to complete upgrade The user now has several options (outside of csolution ) to merge the configuration file information. A potential way could be to use a 3-way merge utility. After merging the configuration file, the original base@version file should be deleted, and the new unmodified version should become the new base@version . The previous configuration file may be stored as a backup, as shown below. ./RTE/component_class/ConfigFile.h // new configuration file with merge configuration ./RTE/component_class/ConfigFile.h.bak // previous configuration file stored as backup ./RTE/component_class/ConfigFile.h.base@1.3.0 // current unmodified configuration file with version // information; used as a base for version comparison Multiple Instances of Configuration files The system is also capable of handling multiple instances of configuration files as explained in the CMSIS-Pack specification under Component Instances . In this case, the instance %placeholder% is expanded as shown below. ./RTE/component_class/ConfigFile_0.h ./RTE/component_class/ConfigFile_0.h.base@1.2.0 ./RTE/component_class/ConfigFile_1.h ./RTE/component_class/ConfigFile_1.h.base@1.2.0 RTE_Components.h The file ./RTE/RTE_Components.h is created by the CMSIS Project Manager when the option --update-rte is used. This option is the default for the csolution convert command. For each selected software component, it contains #define statements required by the component. These statements are defined in the *.PDSC file for that component. The following example shows a sample content of a RTE_Components.h file: /* Auto generated Run-Time-Environment Component Configuration File *** Do not modify ! *** */ #ifndef RTE_COMPONENTS_H #define RTE_COMPONENTS_H /* Define the Device Header File: */ #define CMSIS_device_header \"stm32f10x.h\" #define RTE_Network_Interface_ETH_0 /* Network Interface ETH 0 */ #define RTE_Network_Socket_BSD /* Network Socket BSD */ #define RTE_Network_Socket_TCP /* Network Socket TCP */ #define RTE_Network_Socket_UDP /* Network Socket UDP */ #endif /* RTE_COMPONENTS_H */ The RTE_Components.h file is typically used in other header files to control the inclusion of files related to other components of the same software pack. #include \"RTE_Components.h\" #include CMSIS_device_header #ifdef RTE_Network_Interface_ETH_0 // if component Network Interface ETH 0 is included #include \"Net_Config_ETH_0.h\" // add the related configuration file for this component #endif CMSIS_device_header The preprocessor symbol CMSIS_device_header represents the device header file provided by the CMSIS-Core. It defines the registers and interrupt mapping of the device that is used. Refer to Reference Applications > Header File Structure for more information. _RTE_ Preprocessor Symbol The preprocessor symbol _RTE_ is added to the compiler invocation when a CMSIS build system manages the file RTE_Components.h . This symbol can be used as follows: #ifdef _RTE_ // Is a CMSIS build system used? #include \"RTE_Components.h\" // Include Run-Time-Environment symbols #else // Otherwise, use different ways to supply required symbols #define CMSIS_device_header \"stm32f10x.h\" #endif Linker Script Management A Linker Script contains a series of Linker directives that specify the available memory and how it should be used in a project. The Linker directives reflect exactly the available memory resources and memory map for the project context. This section describes the Linker Script management of the csolution Project Manager : The linker: node specifies an explicit Linker Script and/or memory regions header file. This overrules Linker Scripts that are part of software components or specified using the file: notation. The linker: auto: enables the automatic Linker Script generation . If no linker: node is used, a Linker Script file can be provided as part of software components. The extensions .sct , .scf , .ld , and .icf are recognized as Linker Script files. If no Linker Script is found, the automatic Linker Script generation is used. Linker Script Preprocessing A standard C preprocessor is used for the Linker Script file when: the linker script file extension is *.src . the linker: node contains a regions: header file or a define: . Otherwise, no preprocessor is used, and the Linker Script file is directly passed to the linker. Automatic Linker Script generation The automatic Linker Script generation uses a Linker Script template and generates a <regions>.h file based on information from the software packs using the: <device> - <memory> element in the DFP <board> - <memory> element in the BSP Both files, the Linker Script template and the <regions>.h are located in the RTE directory path \\RTE\\Device\\<device> . The <regions>.h file name is extended with: Bname when the project context uses a board: specification, i.e. regions_IMXRT1050-EVKB.h Dname when the project context only uses a device: specification, i.e. regions_stm32u585xx.h . Both files, the Linker Script template and the <regions>.h can be modified by the user as it might be required to adjust the memory regions or give additional attributes (such as noinit ). Note For more information, refer to Create Applications\u2014Configure Linker Scripts . Linker Script Templates The following compiler-specific Linker Script template files are copied to the \\RTE\\Device\\<device> directory when no Linker Script exists. The files are located in the directory <cmsis-toolbox-installation-dir>/etc of the CMSIS-Toolbox. Linker Script Template Linker control file for ... ac6_linker_script.sct.src Arm Compiler gcc_linker_script.ld.src GCC Compiler iar_linker_script.icf.src IAR Compiler clang_linker_script.ld.src CLANG Compiler (LLVM) Generator Support Generators , such as STM32CubeMX or MCUXpresso Config Tools, simplify the configuration for devices and boards. The CMSIS-Toolbox implements a generic interface for generators . Generators may be used to: Configure device and/or board settings, such as clock configuration or pinout. Add and configure software drivers, for example, for UART, SPI, or I/O ports. Configure parameters of an algorithm, such as DSP filter design or motor control parameters. The steps for creating a *.csolution.yml application with a Generator are: Create the *.csolution.yml container that refers to the projects and selects device: or board: (by using target-types: ) Create *.cproject.yml files that are referred to by the *.csolution.yml container. Add components: to the *.cproject.yml file. For components that have a <generator-id> , run the related generator. The Generator can add files, components, and settings to a project using the Generator import file ( *.cgen.yml ) . The format of this file is similar to a software layer . Use a Generator An example that uses STM32CubeMX is provided in github.com/Open-CMSIS-Pack/csolution-examples . The ./CubeMX example is used below. To list the Generator configuration of a *.csolution.yml use: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # Name of the Generator base-dir: STM32CubeMX/MyBoard # Generator output directory for contexts listed below cgen-file: STM32CubeMX/MyBoard/CubeMX.cgen.yml # Generator import file for contexts listed below context: CubeMX.Debug+MyBoard context: CubeMX.Release+MyBoard To run the generator (in this case CubeMX) use: csolution CubeMX.csolution.yml run --generator CubeMX Configure Generator Output The Generator output directory and the name of the Generator import file ( *.cgen.yml ) can be configured using the node generators: as shown below. generators: options: - generator: CubeMX path: ../STM32CubeMX name: MyConfig A Generator output configuration is useful for: Using a board layer that is shareable across multiple projects. Using different configurations across a *.csolution.yml project. Detailed Usage Instructions These chapters explain how to manage device and board configuration in more detail: Configure STM32 Devices with CubeMX Configure NXP Devices with MCUXpresso Config Tools Run and Debug Configuration The CMSIS-Toolbox uses the information from the DFP and BSP to simplify the debugger configuration. It generates the file <solution-name>+<target-type>.cbuild-run.yml that contains for one target of a csolution project all information for run and debug. This file is used by pyOCD and the CMSIS Solution extension for VS Code to configure debug and programming features of the supported debug adapters . An application can be composed of various project contexts and additional images . In addition the debugger along with parameters are specified in the *.csolution.yml file using the target-set: node. Note Refer to Run and Debug Management for further details. Examples: The following example configures the ST-LINK debugger for the project MyProject with build-type Debug : target-types: - type: MyBoard board: B-U585I-IOT02A # Board name target-set: - set: debugger: name: ST-LINK images: - project-context: MyProject.Debug The following example uses a CMSIS-DAP debugger with JTAG protocol and configures a multi-core application with two projects. The project core0 uses the build-type Debug . The project core1 uses the build-type Release . target-types: - type: Alif_AppKitE7 board: Alif Semiconductor::AppKit-E7 target-set: - set: debugger: name: CMSIS-DAP protocol: jtag images: - project-context: core0.Debug - project-context: core1.Release Using pyOCD A csolution project that uses target-set: to configure the debugger should be build using the option --active to select the target-type. The cbuild command creates then a corresponding *.build-run.yml file that can be used with pyOCD version 0.37.0 or higher. This *.build-run.yml file contains all information to program and debug the application . Example: cbuild MyApplication.csolution.yml --active MyBoard # build application pyOCD load --cbuild-run MyApplication+MyBoard.cbuild-run.yml # download image to target pyOCD gdbserver --cbuild-run MyApplication+MyBoard.cbuild-run.yml # start GDB remote server Using VS Code With the VS Code extension CMSIS Solution version 1.54 or higher use the Manage Solution view to configure the debugger. You may then use the CMSIS Debugger extension for interactive debug or pyOCD in command line mode. Device Configuration Several DFP contain *.dbgconf files that configure device-specific debug and trace parameters. The CMSIS-Toolbox provides this configuration information in the *.build-run.yml file for debuggers with Debug Access Sequence support . The .cmsis directory in the csolution project directory contains for each target a default *.dbgconf configuration file. For example: .\\.cmsis\\MyApplication+MyBoard . This file can be configured to reflect user settings. An explict *.dbgconf configuration file can be specified using the debugger: node in the *.csolution.yml file. West Build System Integration The West build system is a project management system used primarily in the Zephyr ecosystem. The integration in the CMSIS-Toolbox acts as a \"build orchestration wrapper\" around CMake. The CMSIS-Toolbox connects the west build command with the information of the CMSIS-Pack system as shown in the diagram below. For the selected compiler the related environment variables for the west build system are set. When combined with the VS Code CMSIS Solution extension, features such as project outline in the CMSIS View or \"go-to-definition\" with clangd are available. West projects are specified using the west: node under projects: in the *.csolution.yml file and can be managed with the target-types and build-types of the csolution project . Note that the sysbuild feature of west is not supported as the CMSIS-Toolbox manages already related projects. Example: solution: compiler: AC6 packs: - pack: AlifSemiconductor::Ensemble@^2.0.0-0 - pack: ARM::CMSIS target-types: - type: DevKit-E7 board: Alif Semiconductor::DevKit-E7 device: Alif Semiconductor::AE722F80F55D5LS variables: # west board selection - west-board: alif_e7_dk_rtss target-set: - set: debugger: name: J-Link Server port: 3333 protocol: swd images: - project-context: rtss_he.Debug - project-context: rtss_hp.Release build-types: - type: Debug optimize: debug west-defs: # west defines - CONFIG_DEBUG: y - CONFIG_DEBUG_THREAD_INFO: y - SE_SERVICES: OFF - CMAKE_BUILD_TYPE: Debug - type: Release optimize: size west-defs: # west defines - SE_SERVICES: OFF - CMAKE_BUILD_TYPE: Release projects: - west: app-path: ./alif/samples/drivers/ipm/ipm_arm_mhuv2/rtss_he board: $west-board$_he device: :M55_HE - west: app-path: ./alif/samples/drivers/ipm/ipm_arm_mhuv2/rtss_hp board: $west-board$_hp device: :M55_HP","title":"CSolution Project Structure"},{"location":"build-overview/#csolution-project-structure","text":"This chapter outlines the structure of csolution project files that contain the build information of the software application. Project Examples and project templates help to get started with the tools. Software Layers provide reusable configurations and give projects a better structure. Directory Structure describes the overall directory structure of projects. Linker Script Management defines the available memory and controls the linker operation. Generator Support integrates configuration tools such as STM32CubeMX or MCUXpresso Config. Run and Debug Configuration explains how to configure debug adapters such as CMSIS-DAP or J-Link. West Build System Integration allows to manage Zephyr applications in context with a csolution project .","title":"CSolution Project Structure"},{"location":"build-overview/#overview-of-operation","text":"The diagram below outlines the operation of the csolution command convert that processes the csolution project with one or more context configurations for an application. Tip Project Examples show different project types and provide templates for user projects. Build Process Overview explains the complete end-to-end build process. Input Files Description Generic Software Packs Provide re-usable software components that are typically configurable towards a user application. DFP Software Pack Device-related information (including memory sizes) for the tool configuration. BSP Software Pack Board specific configuration (i.e. additional memory resources). cdefault.yml When enabled with cdefault: , setup of toolchain specific controls and pre-defined toolchains. *.csolution.yml Complete scope of the application with sub-projects. Defines target and build types. *.cproject.yml Content of an independent build step (linker or library archiver run). *.clayer.yml Set of source files along with pre-configured components for reuse in different applications. Input/Output Files Description *.cbuild-pack.yml Exact list of the packs that are used by the application; enables reproducible builds as it locks the pack versions. *.cbuild-set.yml Specifies the context set of projects, target-types, and build-types that are used to generate the application image. Output Files Description *.cbuild-idx.yml Index file of all *.cbuild.yml build descriptions; contains also overall information for the application. *.cbuild.yml Build description of a single *.cproject.yml input file for each context. *.cbuild-run.yml Configuration file of a csolution project to run and debug an application on a target. Run-Time Environment (RTE) Contains the user-configured files of a project along with the RTE_Components.h inventory file. Linker Script Files Header file that describes the memory resources. To generate the build information of an application project, the csolution command convert executes the following steps: Read Input Files ( csolution project and Software Packs ) Process each project context (defined by a target-set or the option: --context ): Apply pack: , device: , board: , and compiler: to filter the content of software packs. From groups: add the list of user source files. From components: add the list of component source files. Generate Output Files : Update configuration files in RTE directory (disable with option: --no-update-rte ). Print results of software component dependency validation.","title":"Overview of Operation"},{"location":"build-overview/#source-code-of-software-packs","text":"Software packs and the related components: allow you to share and reuse code. The content of a software pack is, therefore, read-only (with the exception of configuration files that are copied to the RTE directory ) as these source code files should not be modified by a user. The benefit is a clean project directory that only contains the user code and configuration files for components: . This keeps a repository small and makes it easy to upgrade to a new pack version . Note During the development of a software pack, you may install a repository , which contains the source of the software pack. You may copy the content of a software pack to your project workspace and provide a path to the pack .","title":"Source Code of Software Packs"},{"location":"build-overview/#project-examples","text":"","title":"Project Examples"},{"location":"build-overview/#github-repositories","text":"The following repositories provide several working examples: Repository Description csolution-examples Contains several getting started examples that show single-core, multi-core, and TrustZone setup as well as how to use a generator (CubeMX). github.com/Arm-Examples Contains many examples that include CMSIS-Toolbox setup. The section below explains the overall concepts considered by the csolution Project Manager based on examples.","title":"GitHub repositories"},{"location":"build-overview/#template-projects","text":"The following *.csolution.yml templates may be used to create embedded applications. Template Description Simple A csolution.yml template with a single *.cproject.yml . Multicore A csolution.yml template with multiple *.cproject.yml files, each targeting one processor of a multicore device. TrustZone A csolution.yml template with a non-secure *.cproject.yml and an optional secure *.cproject.yml file. UnitTest A csolution.yml template that shares one HAL *.clayer.yml with multiple *.cproject.yml files for unit testing. To use these templates, copy the content of the folder to your own application folder. Then adapt the names accordingly and add missing information. Refer to CMSIS-Toolbox Templates for more details.","title":"Template Projects"},{"location":"build-overview/#minimal-project-setup","text":"A minimal application requires two files: Sample.csolution.yml that defines a target type with board or device . It includes a project and selects a compiler . Sample.cproject.yml defines the files and software components that are translated into an image or library archive. Note When no packs: are specified in csolution project files , the tools use the latest version of the installed packs. Simple Project: Sample.csolution.yml solution: cdefault: # use default setup for toolchains compiler: AC6 # select the compiler to use packs: # explicit pack selection may be omitted - pack: NXP::K32L3A60_DFP@16.0.0 # specify DFP - pack: NXP::FRDM-K32L3A6_BSP@16.0.0 target-types: - type: FRDM-K32L3A6 board: FRDM-K32L3A6 build-types: # defines toolchain options for 'debug' and 'release' - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Sample.cproject.yml Simple Project: Sample.cproject.yml project: packs: - pack: ARM::CMSIS # specify additional packs groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup","title":"Minimal Project Setup"},{"location":"build-overview/#context","text":"A context is defined in the *.csolution.yml file by projects: , target-types: , and build-types: . It identifies a configuration with project-name , build-type , and target-type and is used on various places in the CMSIS-Toolbox. The following context refers to the example above and selects the project: Sample.cproject.yml with build-type: Debug and target-type: FRDM-K32L3A6 : Sample.Debug+FRDM-K32L3A6 The context allows you to refer to each possible build combination that, by default, uses a different output directory . A context may be partly specified in many places. The context-set defines a combination of projects and is useful when an application is composed of multiple related projects .","title":"Context"},{"location":"build-overview/#toolchain-agnostic-project","text":"Generic Translation Control settings enable projects that work across the range of supported compilers (AC6, GCC, IAR, CLANG). The Translation Control settings are mapped to specify compiler controls by the build tools.","title":"Toolchain Agnostic Project"},{"location":"build-overview/#cdefaultyml","text":"The cdefault.yml file contains a common set of compiler-specific settings that select reasonable defaults with misc: controls for each compiler. The cdefault: node in the *.csolution.yml file enables the usage of this file. The directory <cmsis-toolbox-installation-dir>/etc contains a cdefault.yml file that is used when no local copy of the cdefault.yml file is provided. Note It is recommended that a local copy of the cdefault.yml file be provided in the same directory that stores the *.csolution.yml file. Example: default: misc: - for-compiler: AC6 C-CPP: - -Wno-macro-redefined - -Wno-pragma-pack - -Wno-parentheses-equality - -Wno-license-management C: - -std=gnu11 ASM: - -masm=auto Link: - --entry=Reset_Handler - --map - --info summarysizes - --summary_stderr - --diag_suppress=L6314W - for-compiler: GCC C-CPP: - -masm-syntax-unified - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - --specs=nano.specs - --specs=nosys.specs - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - -Wl,--no-warn-rwx-segments # suppress incorrect linker warning - for-compiler: CLANG C-CPP: - -fomit-frame-pointer - -ffunction-sections - -fdata-sections C: - -std=gnu11 Link: - -lcrt0 - -Wl,-Map=$elf()$.map - -Wl,--gc-sections - for-compiler: IAR C-CPP: - --dlib_config DLib_Config_Full.h Link: - --map=$elf()$.map","title":"cdefault.yml"},{"location":"build-overview/#compiler-selection","text":"There are two ways to select a toolchain: An explicit compiler: selection in the *.csolution.yml project file: solution: cdefault: # use the cdefault.yml file with toolchain specific controls compiler: AC6 # select Arm Compiler : The command line option --toolchain of the cbuild or csolution tool overwrites any compiler: definition in the csolution project files. cbuild Hello.csolution.yml --toolchain GCC Tip Toolchain agnostic example projects do not contain a compiler: selection in the *.csolution.yml project file. Instead the select-compiler: node list the compilers that this csolution project is tested with. The VS Code extension Arm CMSIS Solution adds the compiler: node based on the installed compiler in your environment.","title":"Compiler Selection"},{"location":"build-overview/#reproducible-builds","text":"Reproducible builds are supported by the *.cbuild-pack.yml file that is created and read by the csolution project manager. This file: Records the exact list of the pack versions used during the creation of an application. Ensures that pack versions do not change during development, even when new packs are installed on the host computer, for example, to develop other applications. Note The *.cbuild-pack.yml file should be committed to a repository to ensure reproducible builds. The cbuild option --frozen-packs checks that the *.cbuild-pack.yml file exists and reports an error if any pack is changed or not available. To update a pack to a new version, delete the file *.cbuild-pack.yml or remove the information about a specific pack in this file.","title":"Reproducible builds"},{"location":"build-overview/#repository-contents","text":"To support reproducible builds, the following files should be committed to a repository of a version control system. All user source code files. All csolution project files ( cdefault.yml , *.csolution.yml , *.cproject.yml , etc.). All files in the RTE directory Ensure that there are no files with the extension .update@ as this indicates that configuration files are not up-to-date due to updated software packs. The file *.cbuild-pack.yml to allow reproducible builds . Optionally, the file *.cbuild-set.yml defines the application's context set that should be generated. Note If the file *.cbuild-set.yml file is missing, the setup command creates a *.cbuild-set file with a selection of the first target-type and the first build-type .","title":"Repository Contents"},{"location":"build-overview/#configure-related-projects","text":"A solution is the software view of the complete system. It combines projects that can be generated independently and therefore, manages related projects. It may also be deployed to different targets during development as described in section Software Layers . The picture below shows a system that is composed of: Project A that implements a time-critical control algorithm running on an independent processor #2. Project B is a cloud-connected IoT application with Machine Learning (ML) functionality. Project C is the separate data model of the ML algorithm, allowing independent updates. Project D implements the device security (for example, with TF-M that runs with TrustZone in secure mode). In addition, such systems may have a boot-loader that can also be implemented as another independent project. At the level of the *.csolution.yml file, the target-types: and build-types: are managed so that a common set is available across all *.cproject.yml files in the system. target-types: typically describe a different hardware target system. build-types: typically describe a build variant of the same hardware target system. Both types are used for peripherals and the same hardware configuration but may compile a different variant (i.e. with test I/O enabled) of an application. Related Projects: iot-product.csolution.yml solution: : # setup not shown target-types: - type: Board board: NUCLEO-L552ZE-Q # uses device defined by the board - type: Production-HW device: STM32U5X # specifies device build-types: - type: Debug optimize: none debug: on - type: Release optimize: balanced debug: on - type: Test optimize: size debug: on projects: - project: ./security/TFM.cproject.yml # Project D: Only generated for build type: Release for-context: .Release - project: ./application/MQTT_AWS.cproject.yml # Project B - project: ./mldata/Model.cproject.yml # Project C - project: ./bootloader/Bootloader.cproject.yml # Not generated for target type: Board not-for-context: +Board - project: ./processor2/Control.cproject.yml # Project A","title":"Configure Related Projects"},{"location":"build-overview/#working-with-target-set","text":"A target-set: specifies the context types and additional images that are combined into an application. The following example defines the Run and Debug configurations for the iot-product.csolution.yml application that is shown above using the target-set: node. Note Run and Debug Configuration shows how a debugger: is specified for a build variant that is defined with target-set: . solution: : # setup not shown target-types: - type: Board board: NUCLEO-L552ZE-Q # uses device defined by the board target-set: - set: # default set for this target images: - project-context: MQTT_AWS.Debug - project-context: Control.Debug - type: Production-HW device: STM32U5X # specifies device - set: # default set for this target images: # all projects as release version - project-context: Bootloader.Release - project-context: TFM.Release - project-context: MQTT_AWS.Release - project-context: Model.Release - project-context: Control.Release - set: Debug # alternative set for debugging on Production-HW images: # projects and images required for debugging - image: Bootloader_Dummy.hex # use an dummy image - project-context: TFM.Release - project-context: MQTT_AWS.Debug # load debug build - image: Model_Test.hex # use a test Model Using the Build Tools option --active (or -a ) generates the different build variants: cbuild iot-product.csolution.yml -a Board # target-type Board with default set cbuild iot-product.csolution.yml -a Production-HW # target-type Production-HW with default set cbuild iot-product.csolution.yml -a Production-HW@Debug # target-type Production-HW with Debug set","title":"Working with target-set"},{"location":"build-overview/#working-with-context-set","text":"Note With CMSIS-Toolbox version 2.9 or higher the target-set: is introduced. It is recommended to use target-set: instead of the --context-set option as the --context-set option may be deprecated. Frequently, it is required to build applications with different context types. The following command line example generates the iot-product.csolution.yml with build type Debug for the project MQTT_AWS.cproject.yml , while the other projects use the build type Release . When using the option -S or --context-set , this selection is saved to the file iot-product.cbuild-set.yml located in the same directory as the *.csolution.yml file. Refer to File Structure of *.cbuild-set.yml for details. cbuild iot-product.csolution.yml -c TFM.Release+Board -c MQTT_AWS.Debug+Board -c Bootloader.Release+Board -S The saved context-set ( iot-product.cbuild-set.yml ) is used when the option -S or --context-set is used without option --context or -c . cbuild iot-product.csolution.yml -S Rules for context-set The same target-type must be selected for all projects. Only one build-type can be selected for a project. Projects that are not required can be excluded. Note The VS Code extension Arm CMSIS Solution always uses a context-set that is selected in the Manage Solution view.","title":"Working with context-set"},{"location":"build-overview/#external-tools-and-build-order","text":"The executes: node integrates CMake scripts, projects, and external tools. The input: and output: list typically refers to files and therefore define the build order of projects: When input: contains files that are the output of a cproject.yml , this project part is built first. When output: contains files that are the input of a cproject.yml , the execute: node is built first. Example: The KeyGenerator tool builds the file keys.c , which is added as a source file: for other projects. Using cbuild My.csolution.yml [--context-set] starts the build process of the application and runs the KeyGenerator before building projects that use the source file keys.c as input. Note Using cbuild with the option --context does not run execute: nodes as it triggers project builds only. The option --context-set must be used. solution: : executes: - execute: GenKeys # is a CMake target name run: KeyGenerator -k $input(0)$ -p $input(1)$ -o $output$ input: - $SolutionDir()$/keyfile.txt # input(0) contains key in text format - $SolutionDir()$/passcode.txt # input(1) contains passcode in text format output: - $SolutionDir()$/keys.c # output keys source file (input to other projects)","title":"External Tools and Build Order"},{"location":"build-overview/#project-dependency","text":"An access sequence that refers to the output of another project also impacts the build order. Example: The access sequence $cmse-lib(Project_S)$ includes the secure entry library of Project_S . Hence, Project_S is built before the non-secure project part of the application. project: # Non-secure project : groups: - group: CMSE Library files: - file: $cmse-lib(Project_S)$ # Secure part of an application","title":"Project Dependency"},{"location":"build-overview/#software-layers","text":"Software layers collect source files and software components along with configuration files for reuse in different projects. Software Layers gives projects a better structure and simplifies: Development flows with evaluation boards and production hardware. Evaluation of middleware and hardware modules across different microcontroller boards. Code reuse across projects, i.e. board support for test-case deployment. Test-driven software development on simulation model and hardware. Simple Example: This example uses a layer to include an RTOS kernel. The file MyProject.cproject.yml includes the file RTOS.clayer.yml using the layers: node: project: groups: - group: App files: - file: ./main.c components: - component: CMSIS:CORE - component: Device:Startup layers: - layer: ../Layer/RTOS.clayer.yml # Add RTOS kernel The RTOS.clayer.yml file defines the kernel along with configuration settings. layer: description: RTX RTOS with configuration settings packs: - pack: ARM:CMSIS-RTX components: - component: CMSIS:RTOS2:Keil RTX5&Source The diagram below shows two different scenarios, which are explained in the following sections.","title":"Software Layers"},{"location":"build-overview/#target-production-hardware","text":"Software development frequently starts on evaluation boards. Using a board layer simplifies re-targeting to production hardware. The following *.csolution.yml file exemplifies the concept. A software developer starts with a board layer for the evaluation board in the folder MyBoard . Once the production hardware is available, this layer is copied to a different folder (i.e. MyHardware ). As both layers are independently managed, the configuration of the MyHardware layer can be modified, for example, to target different devices, pin layout, or peripheral configurations. In the *.csolution.yml project, the layer is defined using a variable . By changing the target-type during the build process, the software developer can continue to use the evaluation board or target the production hardware. solution: cdefault: compiler: AC6 target-types: - type: EvalBoard board: STMicroelectronics::B-U585I-IOT02A:Rev.C device: STMicroelectronics::STM32U585AIIx variables: - Board-Layer: $SolutionDir()$/MyBoard/Board.clayer.yml - type: ProductionHW device: STMicroelectronics::STM32U575AIIx # uses a different device variables: - Board-Layer: $SolutionDir()$/MyHardware/Board.clayer.yml build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: HID/HID.cproject.yml Tip The MDK-Middleware examples are structured in this way. Start with a board layer that is provided in several Board Support Packs . Another project that extends this concept to hardware shields is the Sensor-SDK-Example .","title":"Target Production Hardware"},{"location":"build-overview/#test-case-project","text":"Modern software design mandates for test-driven development that utilize DevOps or CI principals. Simulation models such as the Arm Virtual Hardware (AVH) FVP allow test automation without target hardware. However, in some cases, tests should also be performed on physical hardware. A test case project may, therefore, contain targets for simulation and physical hardware. The csolution project format allows multiple test projects to be combined to validate different parts of the application. solution: cdefault: compiler: GCC : # pack definition not shown target-types: - type: Board board: NUCLEO-L552ZE-Q variables: - Board-Layer: ./Board/NUCLEO-L552ZE-Q/Board.clayer.yml - type: Virtual board: VHT-Corstone-300 # Virtual Hardware platform (appears as a board) variables: - Board-Layer: ./Board/Corstone-300/AVH.clayer.yml projects: - project: ./TestSuite1/TestCases.cproject.yml - project: ./TestSuite2/TestCases.cproject.yml - project: ./TestSuite3/TestCases.cproject.yml Tip Several examples for Arm Virtual Hardware (AVH) FVP simulation models show usage of csolution projects in CI workflows. The project AVH-MLOps-Main is a test project that shows retargeting to different processors using a layer. The project AWS_MQTT_Demo extends this concept with retargeting of an IP communication to virtual or physical hardware.","title":"Test Case Project"},{"location":"build-overview/#configuration-settings","text":"A software layer is a set of source files and pre-configured software components or source code that can be shared across multiple projects. To achieve this, the configuration files of a layer are stored within the directory structure of the software layer. This separate RTE Directory Structure allows that projects can share a layer with common configuration settings. Note When using a generator, such as CubeMX or MCUxpresso, the output should be redirected as described under Configure Generator Output .","title":"Configuration Settings"},{"location":"build-overview/#software-layers-in-packs","text":"Software layers for reference applications may be published in software packs. For more information, refer to Pack Creation \u00bb Layers .","title":"Software Layers in Packs"},{"location":"build-overview/#directory-structure","text":"This section describes how the csolution based project files should be organized to allow the scenarios described above. This section also gives guidelines for a directory structure. Refer to Directory Control for information about configuring these directories.","title":"Directory Structure"},{"location":"build-overview/#working-areas","text":"The table below explains the different working area sections of an application project. Working Area Access Description Project Area RW Contains user source code files managed by the user along with the project files (see next item). Project files RW Created by a user or an IDE to describe the application project. Component source code RO Content of software packs; the location is specified by the environment variable CMSIS_PACK_ROOT or the node pack: path in project files. Component Configuration\u200b RW User-editable config files of software components that are copied to the RTE directory. Generator artifacts\u200b RO (see note) Managed by domain-specific configuration tools such as STM32CubeMX or MCUXpresso. Build artifacts RW Created during the build process for example by a compiler. Note Some generators allow user modification of the generated files. For example, STM32CubeMX allows modification of source code between /* USER CODE BEGIN */ and /* USER CODE END */ and preserves this modification even when the STM32CubeMX regenerates the files.","title":"Working Areas"},{"location":"build-overview/#project-area","text":"There are no strict rules on how to organize the project area that stores the user source code. However, the following guidelines apply: Each solution should have a distinct base directory. This directory contains the file *.csolution.yml which refers to the independent projects defined with *.cproject.yml files. Each project should have a distinct base directory. This directory contains the file *.cproject.yml , which defines the project's content. The project's source code might be grouped in subdirectories that are typically stored in this base directory. The configuration files of the software components are typically stored in a subdirectory with the name ./RTE . A *.cproject.yml may refer to one or more software layers with *.clayer.yml files. Each software layer should have a distinct base directory with a similar structure as a project. This base directory contains the file *.clayer.yml that defines the content of the software layer. It also contains the user source code (optionally organized in sub-directories) and the configuration\u200b files of software components that belong to this layer, typically stored in a sub-directory with the name ./RTE .","title":"Project Area"},{"location":"build-overview/#rte-directory-structure","text":"The table below summarizes the overall directory structure and further details the ./RTE directory. The ./RTE directory contains the configuration information for software components and is managed by the csolution Project Manager . It contains: Configuration files of the software components. These files have attr=\"config\" in the PDSC-file of the software packs. Refer to PLM of Configuration Files for more information. The file RTE_components.h and pre-include files are generated based on the software packs' PDSC file information. Note The ./RTE directory structure is maintained by tools. You should not modify its structure. However, the complete directory should be committed to a repository of a version control system. Directory Structure Content <csolution> Base directory that contains one or more *.csolution.yml files. <project> Each project has its own directory; this base directory contains the *.cproject.yml file. <project>/RTE/<Cclass> Configurable files for each component Cclass have a common directory. <project>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory. <project>/RTE/<context-dir> Directory for RTE_components.h and pre-include files that are generated by the csolution Project Manager . <layer> Each layer has its own base directory; this directory contains the *.clayer.yml file. <layer>/RTE/<Cclass> Configurable files for each component Cclass have a common directory below the layer base directory. <layer>/RTE/<Cclass>/<device> Configurable files for components that have a condition to a device are in a separate directory below the layer base directory. The <context-dir> has the following format: _<build-type>_<target-type> . Note cbuild no longer generates the <context-dir> by default. It is, therefore, required to align the naming of <context-dir> with other tools (MDK, CMSIS-Pack-Eclipse, etc.) that support the CMSIS-Pack system.","title":"RTE Directory Structure"},{"location":"build-overview/#output-directory-structure","text":"By default, the following output directories are used. Use cbuild to generate the content of these output directories. Output Content ./out/<project>/<target>/<build> Contains the final binary and symbol files of a project context.","title":"Output Directory Structure"},{"location":"build-overview/#software-components","text":"Software components are re-usable library or source files that do not require modification in the user application. Optionally, configurable source and header files are provided to allow the setting of parameters for the software component. Configurable source and header files are copied to the project using the directory structure explained above. Libraries, source, and header files that are not configurable (and need no modification) are stored in the directory of the software component (typically part of CMSIS_Pack_ROOT) and get included directly from this location into the project. An include path to the header files of the software component is added to the C/C++ Compiler control string. Notes The csolution command convert provides the option --no-update-rte that disables the generation of files in the ./RTE directory and, therefore the management of configuration files and the RTE_Components.h file. The csolution command update-rte only updates the configuration files in the RTE directory. Using the option --verbose outputs additional version details.","title":"Software Components"},{"location":"build-overview/#plm-of-configuration-files","text":"Configurable source and header files have a piece of version information that is required during Project Lifetime Management (PLM) of a project. The version number is important when the underlying software pack changes and provides a newer configuration file version. Depending on the PLM status of the application, csolution performs the following operation for configuration files: Add a software component for the first time. Upgrade (or downgrade) a software component.","title":"PLM of Configuration Files"},{"location":"build-overview/#add","text":"When adding a software component for the first time, the related config file is copied twice into the related RTE project directory. The first copy can be modified by the user with the parameters for the user application. The second copy is an unmodified backup file with the format <configfile>.<ext>.base@version . Example: A configuration file ConfigFile.h at version 1.2.0 is copied: ./RTE/component_class/ConfigFile.h // user editable configuration file ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison csolution shows a user notification to indicate that files have been added: ./RTE/component_class/ConfigFile.h - info: component 'name' added configuration file version '1.2.0' Note The unmodified files with @version information should be committed to the repository of the version control system as these files are used to upgrade configuration information using merge utilities.","title":"Add"},{"location":"build-overview/#upgrade","text":"When upgrading (or downgrading) a software component, the version information of the configuration file is considered. If the version of the unmodified backup file is identical, no operation is performed. If the version differs, the new configuration file is copied with the format <configfile>.<ext>.update@version . Example: after updating the configuration file ConfigFile.h to version 1.3.0 , the directory contains these files: ./RTE/component_class/ConfigFile.h // user editable configuration file (based on the current version) ./RTE/component_class/ConfigFile.h.update@1.3.0 // new configuration file; used to start a 3-way merge ./RTE/component_class/ConfigFile.h.base@1.2.0 // current unmodified configuration file with version // information; used as a base for version comparison csolution displays a user notification to indicate that configuration files have changed: ./RTE/component_class/ConfigFile.h - warning: component 'name' upgrade for configuration file version '1.3.0' added, but file inactive User action to complete upgrade The user now has several options (outside of csolution ) to merge the configuration file information. A potential way could be to use a 3-way merge utility. After merging the configuration file, the original base@version file should be deleted, and the new unmodified version should become the new base@version . The previous configuration file may be stored as a backup, as shown below. ./RTE/component_class/ConfigFile.h // new configuration file with merge configuration ./RTE/component_class/ConfigFile.h.bak // previous configuration file stored as backup ./RTE/component_class/ConfigFile.h.base@1.3.0 // current unmodified configuration file with version // information; used as a base for version comparison","title":"Upgrade"},{"location":"build-overview/#multiple-instances-of-configuration-files","text":"The system is also capable of handling multiple instances of configuration files as explained in the CMSIS-Pack specification under Component Instances . In this case, the instance %placeholder% is expanded as shown below. ./RTE/component_class/ConfigFile_0.h ./RTE/component_class/ConfigFile_0.h.base@1.2.0 ./RTE/component_class/ConfigFile_1.h ./RTE/component_class/ConfigFile_1.h.base@1.2.0","title":"Multiple Instances of Configuration files"},{"location":"build-overview/#rte_componentsh","text":"The file ./RTE/RTE_Components.h is created by the CMSIS Project Manager when the option --update-rte is used. This option is the default for the csolution convert command. For each selected software component, it contains #define statements required by the component. These statements are defined in the *.PDSC file for that component. The following example shows a sample content of a RTE_Components.h file: /* Auto generated Run-Time-Environment Component Configuration File *** Do not modify ! *** */ #ifndef RTE_COMPONENTS_H #define RTE_COMPONENTS_H /* Define the Device Header File: */ #define CMSIS_device_header \"stm32f10x.h\" #define RTE_Network_Interface_ETH_0 /* Network Interface ETH 0 */ #define RTE_Network_Socket_BSD /* Network Socket BSD */ #define RTE_Network_Socket_TCP /* Network Socket TCP */ #define RTE_Network_Socket_UDP /* Network Socket UDP */ #endif /* RTE_COMPONENTS_H */ The RTE_Components.h file is typically used in other header files to control the inclusion of files related to other components of the same software pack. #include \"RTE_Components.h\" #include CMSIS_device_header #ifdef RTE_Network_Interface_ETH_0 // if component Network Interface ETH 0 is included #include \"Net_Config_ETH_0.h\" // add the related configuration file for this component #endif","title":"RTE_Components.h"},{"location":"build-overview/#cmsis_device_header","text":"The preprocessor symbol CMSIS_device_header represents the device header file provided by the CMSIS-Core. It defines the registers and interrupt mapping of the device that is used. Refer to Reference Applications > Header File Structure for more information.","title":"CMSIS_device_header"},{"location":"build-overview/#_rte_-preprocessor-symbol","text":"The preprocessor symbol _RTE_ is added to the compiler invocation when a CMSIS build system manages the file RTE_Components.h . This symbol can be used as follows: #ifdef _RTE_ // Is a CMSIS build system used? #include \"RTE_Components.h\" // Include Run-Time-Environment symbols #else // Otherwise, use different ways to supply required symbols #define CMSIS_device_header \"stm32f10x.h\" #endif","title":"_RTE_ Preprocessor Symbol"},{"location":"build-overview/#linker-script-management","text":"A Linker Script contains a series of Linker directives that specify the available memory and how it should be used in a project. The Linker directives reflect exactly the available memory resources and memory map for the project context. This section describes the Linker Script management of the csolution Project Manager : The linker: node specifies an explicit Linker Script and/or memory regions header file. This overrules Linker Scripts that are part of software components or specified using the file: notation. The linker: auto: enables the automatic Linker Script generation . If no linker: node is used, a Linker Script file can be provided as part of software components. The extensions .sct , .scf , .ld , and .icf are recognized as Linker Script files. If no Linker Script is found, the automatic Linker Script generation is used.","title":"Linker Script Management"},{"location":"build-overview/#linker-script-preprocessing","text":"A standard C preprocessor is used for the Linker Script file when: the linker script file extension is *.src . the linker: node contains a regions: header file or a define: . Otherwise, no preprocessor is used, and the Linker Script file is directly passed to the linker.","title":"Linker Script Preprocessing"},{"location":"build-overview/#automatic-linker-script-generation","text":"The automatic Linker Script generation uses a Linker Script template and generates a <regions>.h file based on information from the software packs using the: <device> - <memory> element in the DFP <board> - <memory> element in the BSP Both files, the Linker Script template and the <regions>.h are located in the RTE directory path \\RTE\\Device\\<device> . The <regions>.h file name is extended with: Bname when the project context uses a board: specification, i.e. regions_IMXRT1050-EVKB.h Dname when the project context only uses a device: specification, i.e. regions_stm32u585xx.h . Both files, the Linker Script template and the <regions>.h can be modified by the user as it might be required to adjust the memory regions or give additional attributes (such as noinit ). Note For more information, refer to Create Applications\u2014Configure Linker Scripts .","title":"Automatic Linker Script generation"},{"location":"build-overview/#linker-script-templates","text":"The following compiler-specific Linker Script template files are copied to the \\RTE\\Device\\<device> directory when no Linker Script exists. The files are located in the directory <cmsis-toolbox-installation-dir>/etc of the CMSIS-Toolbox. Linker Script Template Linker control file for ... ac6_linker_script.sct.src Arm Compiler gcc_linker_script.ld.src GCC Compiler iar_linker_script.icf.src IAR Compiler clang_linker_script.ld.src CLANG Compiler (LLVM)","title":"Linker Script Templates"},{"location":"build-overview/#generator-support","text":"Generators , such as STM32CubeMX or MCUXpresso Config Tools, simplify the configuration for devices and boards. The CMSIS-Toolbox implements a generic interface for generators . Generators may be used to: Configure device and/or board settings, such as clock configuration or pinout. Add and configure software drivers, for example, for UART, SPI, or I/O ports. Configure parameters of an algorithm, such as DSP filter design or motor control parameters. The steps for creating a *.csolution.yml application with a Generator are: Create the *.csolution.yml container that refers to the projects and selects device: or board: (by using target-types: ) Create *.cproject.yml files that are referred to by the *.csolution.yml container. Add components: to the *.cproject.yml file. For components that have a <generator-id> , run the related generator. The Generator can add files, components, and settings to a project using the Generator import file ( *.cgen.yml ) . The format of this file is similar to a software layer .","title":"Generator Support"},{"location":"build-overview/#use-a-generator","text":"An example that uses STM32CubeMX is provided in github.com/Open-CMSIS-Pack/csolution-examples . The ./CubeMX example is used below. To list the Generator configuration of a *.csolution.yml use: csolution CubeMX.csolution.yml list generators --verbose CubeMX (Global Registered Generator) # Name of the Generator base-dir: STM32CubeMX/MyBoard # Generator output directory for contexts listed below cgen-file: STM32CubeMX/MyBoard/CubeMX.cgen.yml # Generator import file for contexts listed below context: CubeMX.Debug+MyBoard context: CubeMX.Release+MyBoard To run the generator (in this case CubeMX) use: csolution CubeMX.csolution.yml run --generator CubeMX","title":"Use a Generator"},{"location":"build-overview/#configure-generator-output","text":"The Generator output directory and the name of the Generator import file ( *.cgen.yml ) can be configured using the node generators: as shown below. generators: options: - generator: CubeMX path: ../STM32CubeMX name: MyConfig A Generator output configuration is useful for: Using a board layer that is shareable across multiple projects. Using different configurations across a *.csolution.yml project.","title":"Configure Generator Output"},{"location":"build-overview/#detailed-usage-instructions","text":"These chapters explain how to manage device and board configuration in more detail: Configure STM32 Devices with CubeMX Configure NXP Devices with MCUXpresso Config Tools","title":"Detailed Usage Instructions"},{"location":"build-overview/#run-and-debug-configuration","text":"The CMSIS-Toolbox uses the information from the DFP and BSP to simplify the debugger configuration. It generates the file <solution-name>+<target-type>.cbuild-run.yml that contains for one target of a csolution project all information for run and debug. This file is used by pyOCD and the CMSIS Solution extension for VS Code to configure debug and programming features of the supported debug adapters . An application can be composed of various project contexts and additional images . In addition the debugger along with parameters are specified in the *.csolution.yml file using the target-set: node. Note Refer to Run and Debug Management for further details. Examples: The following example configures the ST-LINK debugger for the project MyProject with build-type Debug : target-types: - type: MyBoard board: B-U585I-IOT02A # Board name target-set: - set: debugger: name: ST-LINK images: - project-context: MyProject.Debug The following example uses a CMSIS-DAP debugger with JTAG protocol and configures a multi-core application with two projects. The project core0 uses the build-type Debug . The project core1 uses the build-type Release . target-types: - type: Alif_AppKitE7 board: Alif Semiconductor::AppKit-E7 target-set: - set: debugger: name: CMSIS-DAP protocol: jtag images: - project-context: core0.Debug - project-context: core1.Release","title":"Run and Debug Configuration"},{"location":"build-overview/#using-pyocd","text":"A csolution project that uses target-set: to configure the debugger should be build using the option --active to select the target-type. The cbuild command creates then a corresponding *.build-run.yml file that can be used with pyOCD version 0.37.0 or higher. This *.build-run.yml file contains all information to program and debug the application . Example: cbuild MyApplication.csolution.yml --active MyBoard # build application pyOCD load --cbuild-run MyApplication+MyBoard.cbuild-run.yml # download image to target pyOCD gdbserver --cbuild-run MyApplication+MyBoard.cbuild-run.yml # start GDB remote server","title":"Using pyOCD"},{"location":"build-overview/#using-vs-code","text":"With the VS Code extension CMSIS Solution version 1.54 or higher use the Manage Solution view to configure the debugger. You may then use the CMSIS Debugger extension for interactive debug or pyOCD in command line mode.","title":"Using VS Code"},{"location":"build-overview/#device-configuration","text":"Several DFP contain *.dbgconf files that configure device-specific debug and trace parameters. The CMSIS-Toolbox provides this configuration information in the *.build-run.yml file for debuggers with Debug Access Sequence support . The .cmsis directory in the csolution project directory contains for each target a default *.dbgconf configuration file. For example: .\\.cmsis\\MyApplication+MyBoard . This file can be configured to reflect user settings. An explict *.dbgconf configuration file can be specified using the debugger: node in the *.csolution.yml file.","title":"Device Configuration"},{"location":"build-overview/#west-build-system-integration","text":"The West build system is a project management system used primarily in the Zephyr ecosystem. The integration in the CMSIS-Toolbox acts as a \"build orchestration wrapper\" around CMake. The CMSIS-Toolbox connects the west build command with the information of the CMSIS-Pack system as shown in the diagram below. For the selected compiler the related environment variables for the west build system are set. When combined with the VS Code CMSIS Solution extension, features such as project outline in the CMSIS View or \"go-to-definition\" with clangd are available. West projects are specified using the west: node under projects: in the *.csolution.yml file and can be managed with the target-types and build-types of the csolution project . Note that the sysbuild feature of west is not supported as the CMSIS-Toolbox manages already related projects. Example: solution: compiler: AC6 packs: - pack: AlifSemiconductor::Ensemble@^2.0.0-0 - pack: ARM::CMSIS target-types: - type: DevKit-E7 board: Alif Semiconductor::DevKit-E7 device: Alif Semiconductor::AE722F80F55D5LS variables: # west board selection - west-board: alif_e7_dk_rtss target-set: - set: debugger: name: J-Link Server port: 3333 protocol: swd images: - project-context: rtss_he.Debug - project-context: rtss_hp.Release build-types: - type: Debug optimize: debug west-defs: # west defines - CONFIG_DEBUG: y - CONFIG_DEBUG_THREAD_INFO: y - SE_SERVICES: OFF - CMAKE_BUILD_TYPE: Debug - type: Release optimize: size west-defs: # west defines - SE_SERVICES: OFF - CMAKE_BUILD_TYPE: Release projects: - west: app-path: ./alif/samples/drivers/ipm/ipm_arm_mhuv2/rtss_he board: $west-board$_he device: :M55_HE - west: app-path: ./alif/samples/drivers/ipm/ipm_arm_mhuv2/rtss_hp board: $west-board$_hp device: :M55_HP","title":"West Build System Integration"},{"location":"build-tools/","text":"Build Tools This chapter describes the tools cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). It includes details on command line syntax and examples. Requirements Install the CMSIS-Toolbox as described in chapter Installation . The CMSIS-Pack repository must be present in the host development environment. There are several ways to configure the CMSIS-Pack repository: Use the cpackget Package Installer command init to initialize the CMSIS-Pack root directory , update the pack index file . Then add software packs . Share an existing CMSIS-Pack repository (i.e. from an IDE) via the environment variable CMSIS_PACK_ROOT . cbuild Invocation Orchestrate the overall build steps utilizing the various tools of the CMSIS-Toolbox and a CMake-based compilation process. cbuild: Build Invocation 2.12.0 (C) 2022-2025 Arm Ltd. and Contributors Usage: cbuild [command] <name>.csolution.yml [options] Commands: help Help about any command list List information about contexts, environment, target-sets and toolchains setup Generate project data for IDE environment Options: -a, --active arg Select active target-set: <target-type>[@<set>] --cbuildgen Generate legacy *.cprj files and use cbuildgen backend -C, --clean Remove intermediate and output directories -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -S, --context-set Select the context names from cbuild-set.yml for generating the target application -d, --debug Enable debug messages --frozen-packs Pack list and versions from cbuild-pack.yml are fixed and raises errors if it changes -g, --generator arg Select build system generator (default \"Ninja\") -h, --help Print usage -j, --jobs int Number of job slots for parallel execution (default 8) -l, --load arg Set policy for packs loading [latest | all | required] (default \"required\") --log arg Save output messages in a log file -n, --no-schema-check Skip schema check -O, --output arg Base folder for output files, 'outdir' and 'tmpdir' (default \"Same as '*.csolution.yml'\") -p, --packs Download missing software packs with cpackget -j, --jobs int Number of job slots for parallel execution (default 8) -l, --load arg Set policy for packs loading [latest | all | required] (default \"required\") --log arg Save output messages in a log file -n, --no-schema-check Skip schema check -O, --output arg Base folder for output files, 'outdir' and 'tmpdir' (default \"Same as '*.csolution.yml'\") -p, --packs Download missing software packs with cpackget -q, --quiet Suppress output messages except build invocations -r, --rebuild Remove intermediate and output directories and rebuild -s, --schema Validate project input file(s) against schema [deprecated] --skip-convert Skip csolution convert step -t, --target arg Optional CMake target name --toolchain arg Input toolchain to be used --update-rte Update the RTE directory and files -v, --verbose Enable verbose messages from toolchain builds -V, --version Print version Use \"cbuild [command] --help\" for more information about a command. Note By default, the cbuild invocation does not update the RTE Directory . If required, use the option --update-rte . csolution Invocation Create build information for embedded applications that consist of one or more related projects. csolution: Project Manager 2.9.0 (C) 2022-2025 Arm Ltd. and Contributors Usage: csolution <command> [<name>.csolution.yml] [options] Commands: convert Convert user input *.yml files to *.cprj files list boards Print list of available board names list configs Print list of configuration files list contexts Print list of contexts in a <name>.csolution.yml list components Print list of available components list debuggers Print list of debuggers from debug-adapters.yml list dependencies Print list of unresolved project dependencies list devices Print list of available device names list environment Print list of environment configurations list examples Print list of examples list templates Print list of templates list generators Print list of code generators of a given context list layers Print list of available, referenced and compatible layers list packs Print list of used packs from the pack repository list target-sets Print list of target-sets in a <name>.csolution.yml list toolchains Print list of supported toolchains run Run code generator rpc Run remote procedure call server update-rte Create/update configuration files and validate solution Options: -a, --active arg Select active target-set: <target-type>[@<set>] -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -d, --debug Enable debug messages -D, --dry-run Enable dry-run -e, --export arg Set suffix for exporting <context><suffix>.cprj retaining only specified versions -f, --filter arg Filter words -g, --generator arg Code generator identifier -l, --load arg Set policy for packs loading [latest | all | required] -L, --clayer-path arg Set search path for external clayers -m, --missing List only required packs that are missing in the pack repository -n, --no-check-schema Skip schema check -N, --no-update-rte Skip creation of RTE directory and files -o,-O --output arg Base folder for output files, 'outdir' and 'tmpdir' (default \"Same as '*.csolution.yml'\") -q, --quiet Run silently, printing only error messages -S, --context-set Select the context names from cbuild-set.yml for generating the target application -t, --toolchain arg Selection of the toolchain used in the project optionally with version -v, --verbose Enable verbose messages -V, --version Print version Use 'csolution <command> -h' for more information about a command. cpackget Invocation Manage the installation of software packs on the host computer. cpackget version 2.1.9 (C) 2021-2023 Linaro, 2024-2025 Arm Ltd. Usage: cpackget [command] [flags] Available Commands: add Add Open-CMSIS-Pack packages checksum-create Generates a .checksum file containing the digests of a pack checksum-verify Verifies the integrity of a pack using its .checksum file completion Generate the autocompletion script for the specified shell connection Check online connection to default or given URL help Help about any command init Initializes a pack root folder list List installed packs rm Remove Open-CMSIS-Pack packages signature-create Digitally signs a pack with a X.509 certificate or PGP key signature-verify Verifies a signed pack update Update Open-CMSIS-Pack packages to latest update-index Update the public index Flags: -C, --concurrent-downloads uint Number of concurrent batch downloads. Set to 0 to disable concurrency (default 20) -h, --help help for cpackget -R, --pack-root string Specifies pack root folder. Defaults to CMSIS_PACK_ROOT environment variable. -q, --quiet Run cpackget silently, printing only error messages -T, --timeout uint Set maximum duration (in seconds) of a download. Disabled by default -v, --verbose Sets verboseness level: None (Errors + Info + Warnings), -v (all + Debugging). Specify \"-q\" for no messages -V, --version Prints the version number of cpackget and exit Use \"cpackget [command] --help\" for more information about a command and command-specific flags. Command Examples List Environment Print the settings of the host development environment to verify the correctness of the tool installation. cbuild list environment List Available Toolchains Print the installed toolchains in the host development environment to identify the available compilers. The option --verbose provides additional path information. cbuild list toolchains -v Build a Project This command builds a project that is defined in the file example.csolution.yml : cbuild example.csolution.yml A csolution project that defines a debugger using target-set: should be build using the option --active that selects the target-type. cbuild example.csolution.yml --active MyBoard Options allow to rebuild and download missing software packs or to select specific context settings: cbuild example.csolution.yml --rebuild --packs --context .Release For reproducible builds in CI environments, fixed software pack versions are provided by the file *.cbuild-pack.yml . An error is reported if the file *.cbuild-pack.yml does not exist or packs are added/removed. Refer to reproducible builds for more information. cbuild example.csolution.yml --frozen-packs --packs --rebuild It is also possible to overwrite the toolchain selection and use a different toolchain for translation: cbuild example.csolution.yml --toolchain GCC The --toolchain option is useful for: Test a new compiler or a different compiler version for the overall project. For unit test applications to allow the usage of different compilers. In DevOps systems that run CI test with a matrix build, it is sometimes required to separate the output of various builds. The option --output adds a prefix to the output directory for outdir: , tmpdir: and build information files. The following commands build the project with the AC6 and GCC compiler and separate the directories for output and temporary files. cbuild example.csolution.yml --toolchain AC6 --output outAC6 cbuild example.csolution.yml --toolchain GCC --output outGCC Note The --output option may be used by an IDE environment to location build information files outside of the user space. Update RTE Configuration Files The Component Configuration\u200b is stored in the RTE directory . When files are missing or new software pack versions are installed, it might be required to update the RTE configuration files: csolution update-rte example.csolution.yml Add Software Packs To install software packs from a public web service, run: cpackget add Arm::CMSIS cpackget add Arm::CMSIS@6.1.0 # optional with version specification List Installed Packs Print a list of installed packs. The list can be filtered by words provided with the option --filter : csolution list packs [-f \"<filter words>\"] Print a list of packs that are required by the example.csolution.yml . csolution list packs example.csolution.yml Install Missing Packs Print a list of missing packs required by the example.csolution.yml but not available in the pack repository to the file packs.txt . These missing packs can then be installed using the cpackget tool. csolution list packs example.csolution.yml -m >packs.txt cpackget update-index # optional to ensure that pack index is up-to-date cpackget add -f packs.txt List Devices or Boards Print a list of available device or board names. The list can be filtered by words provided with the option --filter : csolution list devices csolution list boards --filter NXP List Unresolved Dependencies Device, board, and software components are specified as part of the *.csolution.yml and *.cproject.yml files. Print a list of unresolved project dependencies. The list may be filtered by words provided with the option --filter : csolution list dependencies mysolution.csolution.yml [-f \"<filter words>\"] Create Build Information Convert example.csolution.yml into build information files. csolution convert example.csolution.yml Convert specific contexts of a *.csolution.yml file into build information files. csolution convert SimpleTZ.csolution.yml -c CM33_s.Debug -c CM33_ns.Release+AVH List Compatible Layers List compatible layers for ./fxls8962_normal_spi.csolution.yml and the context *+frdmk22f_agmp03 . This contains also setup information. csolution list layers ./fxls8962_normal_spi.csolution.yml -c *+frdmk22f_agmp03 Refer to Software Layers for more information. Use Generators List external code generators that are used to create software components. It outputs the generator ID that is required for the run command. When using the option --verbose , the generator out directory is listed. csolution list generators mysolution.csolution.yml -v Run a generator (in this case, STM32CubeMX) for a specific project context. Note that the context can be omitted when the same generator output directory is used. csolution run -g CubeMX mysolution.csolution.yml -c Blinky.Debug+STM32L4 Use context set When working with multiple related projects , it might be necessary to combine different build types for debugging and downloading in the target hardware. The option --context-set allows you to save and reuse the selected --context options. Write the selected --context options to the file SimpleTZ.cbuild-set.yml . Refer to file structure of *.cbuild-set.yml for details. cbuild SimpleTZ.csolution.yml -S -c CM33_s.Release -c CM33_ns.Debug Read the previously stored --context setup from the file SimpleTZ.cbuild-set.yml . cbuild SimpleTZ.csolution.yml -S List configuration files List all configuration files that belong to software components and are stored in the RTE directory . When updating software packs , it also shows the update status of each file. csolution list configs SimpleTZ.csolution.yml -S Setup Project (for IDE) In an IDE environment, this command downloads missing packs creates build information files , and generates the file compile_commands.json for IntelliSense. Refer to cbuild setup command for more information. cbuild setup example.csolution.yml --context-set --packs Specify CMSIS-Pack root directory cpackget is compatible with other CMSIS-Pack management tools, such as the Pack Installer, available in MDK or Eclipse variants. There are two ways to specify the CMSIS-PACK root directory: With the CMSIS_PACK_ROOT environment variable. Refer to Installation - Environment Variables . With the option --pack-root <path> , for example: cpackget add Vendor.PackName --pack-root ./MyLocal/Packs Note As the various tools of the CMSIS-Toolbox all rely on the CMSIS-Pack root directory, it is recommended to use the CMSIS_PACK_ROOT environment variable. Initialize CMSIS-Pack root directory CMSIS-Packs are typically distributed via a public web service that offers a Pack Index File of available software packs. To initialize the CMSIS-Pack root directory, run the command: cpackget init https://www.keil.com/pack/index.pidx This command creates in the CMSIS-PACK root directory the following sub-directories. Sub-Directory Content .Web Pack Index File of a public web service and *.PDSC files. .Download Packs that are installed from a web service. Stores *.PDSC pack description file, *.pack content file, and related license information. .Local Index file local_repository.pidx that points to local installations for the development of a software pack. Contains also the *.PDSC files from private software packs. The cpackget init command initializes the CMSIS-Pack root directory but does not download PDSC files. Combined with the option --all-pdsc-files it also downloads all PDSC files that are available in the public index. cpackget init https://www.keil.com/pack/indexpidx --all-pdsc-files Update Pack Index When new software packs are available on a public web service, the local copy of the Pack Index File requires an update. To update the Pack Index File , run: cpackget update-index The option --sparse avoids updating the PDSC files and improves, therefore, the speed. cpackget update-index --sparse Use the option --all-pdsc-files to download all PDSC files available in the public index. cpackget update-index --all-pdsc-files Add packs There are different ways to install software packs. Install public packs The commands below install software packs from a public web service. The available packs along with download URL and version information are listed in the Pack Index File . Check if a pack is installed. If not, install the latest version of a public software pack: cpackget add Vendor.PackName # or cpackget add Vendor::PackName Update an installed pack to the latest version of a public software pack: cpackget add Vendor.PackName@latest # or cpackget add Vendor::PackName@latest Install a specific version of a public software pack: cpackget add Vendor.PackName.x.y.z # or cpackget add Vendor::PackName@x.y.z cpackget add Vendor::PackName@>=x.y.z # check if there is any version greater or equal to x.y.z, install latest Install latest version of a public software pack with the same major version or same major/minor version. Within the rules of semantic versioning only compatible packs are used. cpackget add Vendor::PackName@^x.y.z # check if there is any version greater or equal to x.y.z, but with same major version x cpackget add Vendor::PackName@~x.y.z # check if there is any version greater or equal to x.y.z, but with same major/minor version x.y Install a list of software packs Frequently, a list of software packs should be installed that are used by a project. A text file can specify a list of packs, whereby each line specifies a single pack, optionally with version information as shown above: cpackget add -f list-of-packs.txt Content of list-of-packs.txt : ARM::CMSIS ARM::CMSIS-Driver ARM::CMSIS-FreeRTOS@10.4.6 ARM::mbedTLS@1.7.0 AWS::backoffAlgorithm@1.0.0-Beta : Accept End User License Agreement (EULA) from the command line Some packs come with licenses. By default, cpackget will prompt the user's acceptance of this license agreement. For automated installation of software packs, this user prompting can be suppressed with the command line flag --agree-embedded-license : cpackget add -f list-of-packs.txt --agree-embedded-license In some cases, the user might want to only extract the license agreement of the software pack. This is supported by the command line flag --extract-embedded-license : cpackget add --extract-embedded-license Vendor.PackName The extracted license file will be placed next to the pack. For example, if Vendor.PackName.x.y.z had a license file named LICENSE.txt , cpackget would extract it to .Download/Vendor.PackName.x.y.z.LICENSE.txt . Work behind a proxy Sometimes, cpackget seems to be unable to download software packs, for example, when used behind a corporate firewall. Typically this is indicated by error messages such as: E: Get \"<url>/<pack-name>.pack\": dial tcp <ip-address>: connectex: No connection could be made because the target machine actively refused it. E: failed to download the file In such cases, accessing the Internet via a proxy might be required. This can be done via environment variables that are used by cpackget : # Windows set HTTP_PROXY=http://my-proxy # proxy used for HTTP requests set HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests # Unix export HTTP_PROXY=http://my-proxy # proxy used for HTTP requests export HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests Then all HTTP/HTTPS requests will be going through the specified proxy. Install a private software pack A software pack can be distributed via different methods, such as file exchange systems. Once the software pack is available on the local computer, it can be installed by referring to the *.pack file itself: cpackget add <path>/Vendor.PackName.x.y.z.pack A software pack that is available for download via a URL can be downloaded and installed with: cpackget add https://vendor.com/example/Vendor.PackName.x.y.z.pack Install a repository During the development of a software pack, it is possible to mark the content of a local directory (that typically reflects the repository of the software pack) as a software pack. In this case, the *.pdsc file is specified as shown below: cpackget add <local_path>/Vendor.PackName.pdsc Example: cpackget add /work/IoT_Socket/MDK-Packs.IoT_Socket.pdsc List all software packs List of all installed packs that are available in the CMSIS-Pack root directory. cpackget list This will include all packs that are installed via cpackget add command, regardless of the source of the software pack. There are also a couple of flags that allow listing extra information. List all cached packs that are present in the .Download/ folder: cpackget list --cached List all packs present in the local copy of the Pack Index File ( index.pidx ): cpackget list --public Note Update Pack Index File before using the list command to list all public software packs. Remove packs The commands below demonstrate how to remove packs. This is independent of how the software pack was added. Remove a software pack with a specific version: cpackget rm Vendor.PackName.x.y.z # or cpackget rm Vendor::PackName@x.y.z Remove all versions of a software pack: cpackget rm Vendor.PackName # or cpackget rm Vendor::PackName The procedure is the same as above, but you should also remove the cached files related to this pack from the .Download/ directory. cpackget rm --purge Vendor.PackName` Remove a pack that was installed via a repository . cpackget rm Vendor.PackName.pdsc DevOps Usage The CMSIS-Toolbox supports Continuous Integration (CI) tests in DevOps systems. The ./out directory contains all build artifacts of an application for execution on physical hardware or simulation models. Arm Virtual Hardware - Fixed Virtual Platforms (AVH FVP) enables unit tests and integration tests with simulation models and various virtual interfaces. Using software layers allows, for example, to test on physical hardware or AVH-FVP simulation models. The following commands show typical usage of the CMSIS-Toolbox build system in CI environments. The commands below show typical builds in a CI system. Using --packs installs all public packs with implicit acceptance of licenses. This command builds all projects, target-types, and build-types. Using --context reduces the scope of the build. Using --frozen-packs uses exactly the packs that are specified in the file *.cbuild-pack.yml . cbuild Hello.csolution.yml --packs # install packs and build all cbuild Hello.csolution.yml --packs --context +AVH-SSE-300 # only build target +AVH-SSE-300 cbuild Hello.csolution.yml --packs --frozen-packs # use exact pack versions Packs that are not public are installed using cpackget . The following commands use the MDK-Middleware development repository to install a pre-release pack in a GitHub Actions CI workflow. - name: Checkout MDK-Middleware uses: actions/checkout@v4 with: repository: ARM-software/MDK-Middleware path: ./MDK-Middleware - name: Initialize CMSIS pack system and use MDK-Middleware pack from development repo run: | cpackget init https://www.keil.com/pack/index.pidx cpackget update-index cpackget add ./MDK-Middleware/Keil.MDK-Middleware.pdsc Examples Several examples show CI workflows using the CMSIS-Toolbox. Example Description csolution-examples Four different examples that execute CI tests showing various concepts, including matrix tests and AVH FVP simulation. AVH-Hello Build and execution test for \"Hello World\" example using a GitHub Action matrix to target all Cortex-M processors, Arm Compiler or GCC, and AVH simulation. AVH_CI_Template CI Template for unit test automation that uses GitHub Actions. CMSIS Version 6 Runs a CMSIS-Core validation test across the supported processors using multiple compilers. RTOS2 Validation Runs the CMSIS-RTOS2 validation across Keil RTX using source and library variants. STM32H743I-EVAL_BSP Build test of a Board Support Pack (BSP) with MDK-Middleware Reference Applications using Arm Compiler or GCC. The artifacts store the various example projects for testing on the hardware board. TFL Micro Speech This example project shows the Virtual Streaming Interface with Audio input and uses software layers for retargeting. IDE Usage An IDE may use the following cbuild setup command to set up the project outline view and get information about components and software layers. cbuild setup example.csolution.yml --context-set [--packs] [--update-rte] The command above is used when the IDE starts: The option --context-set uses one target-type and optionally multiple related projects that are selected by a user in the file *.cbuild-set.yml . If this file is missing, it is created with the first target-type and the first build-type which are defined in the *.csolution.yml file. The option --packs can enable the download of missing software packs that are public. The option --update-rte is used when the IDE changes device: , board: or component: settings. The cbuild setup command creates build information files and generates the file compile_commands.json for IntelliSense in an VS Code IDE environment. Refer to cbuild setup command for more information. Project Outline View The project outline view in an IDE may utilize the project files as described below: The file *.csolution.yml contains the overall structure of projects, build-types , and target-types . The file *cbuild-set.yml specifies the selected contexts; if it does not exist, the IDE may select the first project, first build-type , and first target-type from the file *.csolution.yml . The file *.cproject.yml provides the source groups, source files, and the list of components (but without source files). The files *.clayer.yml or *.cgen.yml contain software layers with additional source groups, source files, and components. The *.cbuild.<context>.yml files provide the exact location of these files, for example, when variables are used. Using the above information, it is possible to create an outline view, but without the file list for components. For software layers, the content may require the *.cbuild.<context>.yml files that are generated with the cbuild setup command. The cbuild-idx.yml file provides the exact location of all *.cbuild.<context>.yml files that are used in this context-set. The *.cbuild.<context>.yml files contain for the components source files, configuration file information, API header files, user code templates, generator information, and links to documentation. The project outline view may provide access to this information. Build Process An IDE may use the following cbuild command to build the overall application. cbuild example.csolution.yml --context-set [--packs] [--quite] [--rebuild] The option --context-set selects the projects along with target-type and build-type for the application. The option --packs can be enable the download missing software packs that are public. The option --quite suppresses details about the build process. The option --rebuild may be used to force a complete rebuild of the output files.","title":"Build Tools"},{"location":"build-tools/#build-tools","text":"This chapter describes the tools cbuild (build projects), csolution (transform csolution project files ), and cpackget (manage software packs). It includes details on command line syntax and examples.","title":"Build Tools"},{"location":"build-tools/#requirements","text":"Install the CMSIS-Toolbox as described in chapter Installation . The CMSIS-Pack repository must be present in the host development environment. There are several ways to configure the CMSIS-Pack repository: Use the cpackget Package Installer command init to initialize the CMSIS-Pack root directory , update the pack index file . Then add software packs . Share an existing CMSIS-Pack repository (i.e. from an IDE) via the environment variable CMSIS_PACK_ROOT .","title":"Requirements"},{"location":"build-tools/#cbuild-invocation","text":"Orchestrate the overall build steps utilizing the various tools of the CMSIS-Toolbox and a CMake-based compilation process. cbuild: Build Invocation 2.12.0 (C) 2022-2025 Arm Ltd. and Contributors Usage: cbuild [command] <name>.csolution.yml [options] Commands: help Help about any command list List information about contexts, environment, target-sets and toolchains setup Generate project data for IDE environment Options: -a, --active arg Select active target-set: <target-type>[@<set>] --cbuildgen Generate legacy *.cprj files and use cbuildgen backend -C, --clean Remove intermediate and output directories -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -S, --context-set Select the context names from cbuild-set.yml for generating the target application -d, --debug Enable debug messages --frozen-packs Pack list and versions from cbuild-pack.yml are fixed and raises errors if it changes -g, --generator arg Select build system generator (default \"Ninja\") -h, --help Print usage -j, --jobs int Number of job slots for parallel execution (default 8) -l, --load arg Set policy for packs loading [latest | all | required] (default \"required\") --log arg Save output messages in a log file -n, --no-schema-check Skip schema check -O, --output arg Base folder for output files, 'outdir' and 'tmpdir' (default \"Same as '*.csolution.yml'\") -p, --packs Download missing software packs with cpackget -j, --jobs int Number of job slots for parallel execution (default 8) -l, --load arg Set policy for packs loading [latest | all | required] (default \"required\") --log arg Save output messages in a log file -n, --no-schema-check Skip schema check -O, --output arg Base folder for output files, 'outdir' and 'tmpdir' (default \"Same as '*.csolution.yml'\") -p, --packs Download missing software packs with cpackget -q, --quiet Suppress output messages except build invocations -r, --rebuild Remove intermediate and output directories and rebuild -s, --schema Validate project input file(s) against schema [deprecated] --skip-convert Skip csolution convert step -t, --target arg Optional CMake target name --toolchain arg Input toolchain to be used --update-rte Update the RTE directory and files -v, --verbose Enable verbose messages from toolchain builds -V, --version Print version Use \"cbuild [command] --help\" for more information about a command. Note By default, the cbuild invocation does not update the RTE Directory . If required, use the option --update-rte .","title":"cbuild Invocation"},{"location":"build-tools/#csolution-invocation","text":"Create build information for embedded applications that consist of one or more related projects. csolution: Project Manager 2.9.0 (C) 2022-2025 Arm Ltd. and Contributors Usage: csolution <command> [<name>.csolution.yml] [options] Commands: convert Convert user input *.yml files to *.cprj files list boards Print list of available board names list configs Print list of configuration files list contexts Print list of contexts in a <name>.csolution.yml list components Print list of available components list debuggers Print list of debuggers from debug-adapters.yml list dependencies Print list of unresolved project dependencies list devices Print list of available device names list environment Print list of environment configurations list examples Print list of examples list templates Print list of templates list generators Print list of code generators of a given context list layers Print list of available, referenced and compatible layers list packs Print list of used packs from the pack repository list target-sets Print list of target-sets in a <name>.csolution.yml list toolchains Print list of supported toolchains run Run code generator rpc Run remote procedure call server update-rte Create/update configuration files and validate solution Options: -a, --active arg Select active target-set: <target-type>[@<set>] -c, --context arg [...] Input context names [<project-name>][.<build-type>][+<target-type>] -d, --debug Enable debug messages -D, --dry-run Enable dry-run -e, --export arg Set suffix for exporting <context><suffix>.cprj retaining only specified versions -f, --filter arg Filter words -g, --generator arg Code generator identifier -l, --load arg Set policy for packs loading [latest | all | required] -L, --clayer-path arg Set search path for external clayers -m, --missing List only required packs that are missing in the pack repository -n, --no-check-schema Skip schema check -N, --no-update-rte Skip creation of RTE directory and files -o,-O --output arg Base folder for output files, 'outdir' and 'tmpdir' (default \"Same as '*.csolution.yml'\") -q, --quiet Run silently, printing only error messages -S, --context-set Select the context names from cbuild-set.yml for generating the target application -t, --toolchain arg Selection of the toolchain used in the project optionally with version -v, --verbose Enable verbose messages -V, --version Print version Use 'csolution <command> -h' for more information about a command.","title":"csolution Invocation"},{"location":"build-tools/#cpackget-invocation","text":"Manage the installation of software packs on the host computer. cpackget version 2.1.9 (C) 2021-2023 Linaro, 2024-2025 Arm Ltd. Usage: cpackget [command] [flags] Available Commands: add Add Open-CMSIS-Pack packages checksum-create Generates a .checksum file containing the digests of a pack checksum-verify Verifies the integrity of a pack using its .checksum file completion Generate the autocompletion script for the specified shell connection Check online connection to default or given URL help Help about any command init Initializes a pack root folder list List installed packs rm Remove Open-CMSIS-Pack packages signature-create Digitally signs a pack with a X.509 certificate or PGP key signature-verify Verifies a signed pack update Update Open-CMSIS-Pack packages to latest update-index Update the public index Flags: -C, --concurrent-downloads uint Number of concurrent batch downloads. Set to 0 to disable concurrency (default 20) -h, --help help for cpackget -R, --pack-root string Specifies pack root folder. Defaults to CMSIS_PACK_ROOT environment variable. -q, --quiet Run cpackget silently, printing only error messages -T, --timeout uint Set maximum duration (in seconds) of a download. Disabled by default -v, --verbose Sets verboseness level: None (Errors + Info + Warnings), -v (all + Debugging). Specify \"-q\" for no messages -V, --version Prints the version number of cpackget and exit Use \"cpackget [command] --help\" for more information about a command and command-specific flags.","title":"cpackget Invocation"},{"location":"build-tools/#command-examples","text":"","title":"Command Examples"},{"location":"build-tools/#list-environment","text":"Print the settings of the host development environment to verify the correctness of the tool installation. cbuild list environment","title":"List Environment"},{"location":"build-tools/#list-available-toolchains","text":"Print the installed toolchains in the host development environment to identify the available compilers. The option --verbose provides additional path information. cbuild list toolchains -v","title":"List Available Toolchains"},{"location":"build-tools/#build-a-project","text":"This command builds a project that is defined in the file example.csolution.yml : cbuild example.csolution.yml A csolution project that defines a debugger using target-set: should be build using the option --active that selects the target-type. cbuild example.csolution.yml --active MyBoard Options allow to rebuild and download missing software packs or to select specific context settings: cbuild example.csolution.yml --rebuild --packs --context .Release For reproducible builds in CI environments, fixed software pack versions are provided by the file *.cbuild-pack.yml . An error is reported if the file *.cbuild-pack.yml does not exist or packs are added/removed. Refer to reproducible builds for more information. cbuild example.csolution.yml --frozen-packs --packs --rebuild It is also possible to overwrite the toolchain selection and use a different toolchain for translation: cbuild example.csolution.yml --toolchain GCC The --toolchain option is useful for: Test a new compiler or a different compiler version for the overall project. For unit test applications to allow the usage of different compilers. In DevOps systems that run CI test with a matrix build, it is sometimes required to separate the output of various builds. The option --output adds a prefix to the output directory for outdir: , tmpdir: and build information files. The following commands build the project with the AC6 and GCC compiler and separate the directories for output and temporary files. cbuild example.csolution.yml --toolchain AC6 --output outAC6 cbuild example.csolution.yml --toolchain GCC --output outGCC Note The --output option may be used by an IDE environment to location build information files outside of the user space.","title":"Build a Project"},{"location":"build-tools/#update-rte-configuration-files","text":"The Component Configuration\u200b is stored in the RTE directory . When files are missing or new software pack versions are installed, it might be required to update the RTE configuration files: csolution update-rte example.csolution.yml","title":"Update RTE Configuration Files"},{"location":"build-tools/#add-software-packs","text":"To install software packs from a public web service, run: cpackget add Arm::CMSIS cpackget add Arm::CMSIS@6.1.0 # optional with version specification","title":"Add Software Packs"},{"location":"build-tools/#list-installed-packs","text":"Print a list of installed packs. The list can be filtered by words provided with the option --filter : csolution list packs [-f \"<filter words>\"] Print a list of packs that are required by the example.csolution.yml . csolution list packs example.csolution.yml","title":"List Installed Packs"},{"location":"build-tools/#install-missing-packs","text":"Print a list of missing packs required by the example.csolution.yml but not available in the pack repository to the file packs.txt . These missing packs can then be installed using the cpackget tool. csolution list packs example.csolution.yml -m >packs.txt cpackget update-index # optional to ensure that pack index is up-to-date cpackget add -f packs.txt","title":"Install Missing Packs"},{"location":"build-tools/#list-devices-or-boards","text":"Print a list of available device or board names. The list can be filtered by words provided with the option --filter : csolution list devices csolution list boards --filter NXP","title":"List Devices or Boards"},{"location":"build-tools/#list-unresolved-dependencies","text":"Device, board, and software components are specified as part of the *.csolution.yml and *.cproject.yml files. Print a list of unresolved project dependencies. The list may be filtered by words provided with the option --filter : csolution list dependencies mysolution.csolution.yml [-f \"<filter words>\"]","title":"List Unresolved Dependencies"},{"location":"build-tools/#create-build-information","text":"Convert example.csolution.yml into build information files. csolution convert example.csolution.yml Convert specific contexts of a *.csolution.yml file into build information files. csolution convert SimpleTZ.csolution.yml -c CM33_s.Debug -c CM33_ns.Release+AVH","title":"Create Build Information"},{"location":"build-tools/#list-compatible-layers","text":"List compatible layers for ./fxls8962_normal_spi.csolution.yml and the context *+frdmk22f_agmp03 . This contains also setup information. csolution list layers ./fxls8962_normal_spi.csolution.yml -c *+frdmk22f_agmp03 Refer to Software Layers for more information.","title":"List Compatible Layers"},{"location":"build-tools/#use-generators","text":"List external code generators that are used to create software components. It outputs the generator ID that is required for the run command. When using the option --verbose , the generator out directory is listed. csolution list generators mysolution.csolution.yml -v Run a generator (in this case, STM32CubeMX) for a specific project context. Note that the context can be omitted when the same generator output directory is used. csolution run -g CubeMX mysolution.csolution.yml -c Blinky.Debug+STM32L4","title":"Use Generators"},{"location":"build-tools/#use-context-set","text":"When working with multiple related projects , it might be necessary to combine different build types for debugging and downloading in the target hardware. The option --context-set allows you to save and reuse the selected --context options. Write the selected --context options to the file SimpleTZ.cbuild-set.yml . Refer to file structure of *.cbuild-set.yml for details. cbuild SimpleTZ.csolution.yml -S -c CM33_s.Release -c CM33_ns.Debug Read the previously stored --context setup from the file SimpleTZ.cbuild-set.yml . cbuild SimpleTZ.csolution.yml -S","title":"Use context set"},{"location":"build-tools/#list-configuration-files","text":"List all configuration files that belong to software components and are stored in the RTE directory . When updating software packs , it also shows the update status of each file. csolution list configs SimpleTZ.csolution.yml -S","title":"List configuration files"},{"location":"build-tools/#setup-project-for-ide","text":"In an IDE environment, this command downloads missing packs creates build information files , and generates the file compile_commands.json for IntelliSense. Refer to cbuild setup command for more information. cbuild setup example.csolution.yml --context-set --packs","title":"Setup Project (for IDE)"},{"location":"build-tools/#specify-cmsis-pack-root-directory","text":"cpackget is compatible with other CMSIS-Pack management tools, such as the Pack Installer, available in MDK or Eclipse variants. There are two ways to specify the CMSIS-PACK root directory: With the CMSIS_PACK_ROOT environment variable. Refer to Installation - Environment Variables . With the option --pack-root <path> , for example: cpackget add Vendor.PackName --pack-root ./MyLocal/Packs Note As the various tools of the CMSIS-Toolbox all rely on the CMSIS-Pack root directory, it is recommended to use the CMSIS_PACK_ROOT environment variable.","title":"Specify CMSIS-Pack root directory"},{"location":"build-tools/#initialize-cmsis-pack-root-directory","text":"CMSIS-Packs are typically distributed via a public web service that offers a Pack Index File of available software packs. To initialize the CMSIS-Pack root directory, run the command: cpackget init https://www.keil.com/pack/index.pidx This command creates in the CMSIS-PACK root directory the following sub-directories. Sub-Directory Content .Web Pack Index File of a public web service and *.PDSC files. .Download Packs that are installed from a web service. Stores *.PDSC pack description file, *.pack content file, and related license information. .Local Index file local_repository.pidx that points to local installations for the development of a software pack. Contains also the *.PDSC files from private software packs. The cpackget init command initializes the CMSIS-Pack root directory but does not download PDSC files. Combined with the option --all-pdsc-files it also downloads all PDSC files that are available in the public index. cpackget init https://www.keil.com/pack/indexpidx --all-pdsc-files","title":"Initialize CMSIS-Pack root directory"},{"location":"build-tools/#update-pack-index","text":"When new software packs are available on a public web service, the local copy of the Pack Index File requires an update. To update the Pack Index File , run: cpackget update-index The option --sparse avoids updating the PDSC files and improves, therefore, the speed. cpackget update-index --sparse Use the option --all-pdsc-files to download all PDSC files available in the public index. cpackget update-index --all-pdsc-files","title":"Update Pack Index"},{"location":"build-tools/#add-packs","text":"There are different ways to install software packs.","title":"Add packs"},{"location":"build-tools/#install-public-packs","text":"The commands below install software packs from a public web service. The available packs along with download URL and version information are listed in the Pack Index File . Check if a pack is installed. If not, install the latest version of a public software pack: cpackget add Vendor.PackName # or cpackget add Vendor::PackName Update an installed pack to the latest version of a public software pack: cpackget add Vendor.PackName@latest # or cpackget add Vendor::PackName@latest Install a specific version of a public software pack: cpackget add Vendor.PackName.x.y.z # or cpackget add Vendor::PackName@x.y.z cpackget add Vendor::PackName@>=x.y.z # check if there is any version greater or equal to x.y.z, install latest Install latest version of a public software pack with the same major version or same major/minor version. Within the rules of semantic versioning only compatible packs are used. cpackget add Vendor::PackName@^x.y.z # check if there is any version greater or equal to x.y.z, but with same major version x cpackget add Vendor::PackName@~x.y.z # check if there is any version greater or equal to x.y.z, but with same major/minor version x.y","title":"Install public packs"},{"location":"build-tools/#install-a-list-of-software-packs","text":"Frequently, a list of software packs should be installed that are used by a project. A text file can specify a list of packs, whereby each line specifies a single pack, optionally with version information as shown above: cpackget add -f list-of-packs.txt Content of list-of-packs.txt : ARM::CMSIS ARM::CMSIS-Driver ARM::CMSIS-FreeRTOS@10.4.6 ARM::mbedTLS@1.7.0 AWS::backoffAlgorithm@1.0.0-Beta :","title":"Install a list of software packs"},{"location":"build-tools/#accept-end-user-license-agreement-eula-from-the-command-line","text":"Some packs come with licenses. By default, cpackget will prompt the user's acceptance of this license agreement. For automated installation of software packs, this user prompting can be suppressed with the command line flag --agree-embedded-license : cpackget add -f list-of-packs.txt --agree-embedded-license In some cases, the user might want to only extract the license agreement of the software pack. This is supported by the command line flag --extract-embedded-license : cpackget add --extract-embedded-license Vendor.PackName The extracted license file will be placed next to the pack. For example, if Vendor.PackName.x.y.z had a license file named LICENSE.txt , cpackget would extract it to .Download/Vendor.PackName.x.y.z.LICENSE.txt .","title":"Accept End User License Agreement (EULA) from the command line"},{"location":"build-tools/#work-behind-a-proxy","text":"Sometimes, cpackget seems to be unable to download software packs, for example, when used behind a corporate firewall. Typically this is indicated by error messages such as: E: Get \"<url>/<pack-name>.pack\": dial tcp <ip-address>: connectex: No connection could be made because the target machine actively refused it. E: failed to download the file In such cases, accessing the Internet via a proxy might be required. This can be done via environment variables that are used by cpackget : # Windows set HTTP_PROXY=http://my-proxy # proxy used for HTTP requests set HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests # Unix export HTTP_PROXY=http://my-proxy # proxy used for HTTP requests export HTTPS_PROXY=https://my-https-proxy # proxy used for HTTPS requests Then all HTTP/HTTPS requests will be going through the specified proxy.","title":"Work behind a proxy"},{"location":"build-tools/#install-a-private-software-pack","text":"A software pack can be distributed via different methods, such as file exchange systems. Once the software pack is available on the local computer, it can be installed by referring to the *.pack file itself: cpackget add <path>/Vendor.PackName.x.y.z.pack A software pack that is available for download via a URL can be downloaded and installed with: cpackget add https://vendor.com/example/Vendor.PackName.x.y.z.pack","title":"Install a private software pack"},{"location":"build-tools/#install-a-repository","text":"During the development of a software pack, it is possible to mark the content of a local directory (that typically reflects the repository of the software pack) as a software pack. In this case, the *.pdsc file is specified as shown below: cpackget add <local_path>/Vendor.PackName.pdsc Example: cpackget add /work/IoT_Socket/MDK-Packs.IoT_Socket.pdsc","title":"Install a repository"},{"location":"build-tools/#list-all-software-packs","text":"List of all installed packs that are available in the CMSIS-Pack root directory. cpackget list This will include all packs that are installed via cpackget add command, regardless of the source of the software pack. There are also a couple of flags that allow listing extra information. List all cached packs that are present in the .Download/ folder: cpackget list --cached List all packs present in the local copy of the Pack Index File ( index.pidx ): cpackget list --public Note Update Pack Index File before using the list command to list all public software packs.","title":"List all software packs"},{"location":"build-tools/#remove-packs","text":"The commands below demonstrate how to remove packs. This is independent of how the software pack was added. Remove a software pack with a specific version: cpackget rm Vendor.PackName.x.y.z # or cpackget rm Vendor::PackName@x.y.z Remove all versions of a software pack: cpackget rm Vendor.PackName # or cpackget rm Vendor::PackName The procedure is the same as above, but you should also remove the cached files related to this pack from the .Download/ directory. cpackget rm --purge Vendor.PackName` Remove a pack that was installed via a repository . cpackget rm Vendor.PackName.pdsc","title":"Remove packs"},{"location":"build-tools/#devops-usage","text":"The CMSIS-Toolbox supports Continuous Integration (CI) tests in DevOps systems. The ./out directory contains all build artifacts of an application for execution on physical hardware or simulation models. Arm Virtual Hardware - Fixed Virtual Platforms (AVH FVP) enables unit tests and integration tests with simulation models and various virtual interfaces. Using software layers allows, for example, to test on physical hardware or AVH-FVP simulation models. The following commands show typical usage of the CMSIS-Toolbox build system in CI environments. The commands below show typical builds in a CI system. Using --packs installs all public packs with implicit acceptance of licenses. This command builds all projects, target-types, and build-types. Using --context reduces the scope of the build. Using --frozen-packs uses exactly the packs that are specified in the file *.cbuild-pack.yml . cbuild Hello.csolution.yml --packs # install packs and build all cbuild Hello.csolution.yml --packs --context +AVH-SSE-300 # only build target +AVH-SSE-300 cbuild Hello.csolution.yml --packs --frozen-packs # use exact pack versions Packs that are not public are installed using cpackget . The following commands use the MDK-Middleware development repository to install a pre-release pack in a GitHub Actions CI workflow. - name: Checkout MDK-Middleware uses: actions/checkout@v4 with: repository: ARM-software/MDK-Middleware path: ./MDK-Middleware - name: Initialize CMSIS pack system and use MDK-Middleware pack from development repo run: | cpackget init https://www.keil.com/pack/index.pidx cpackget update-index cpackget add ./MDK-Middleware/Keil.MDK-Middleware.pdsc","title":"DevOps Usage"},{"location":"build-tools/#examples","text":"Several examples show CI workflows using the CMSIS-Toolbox. Example Description csolution-examples Four different examples that execute CI tests showing various concepts, including matrix tests and AVH FVP simulation. AVH-Hello Build and execution test for \"Hello World\" example using a GitHub Action matrix to target all Cortex-M processors, Arm Compiler or GCC, and AVH simulation. AVH_CI_Template CI Template for unit test automation that uses GitHub Actions. CMSIS Version 6 Runs a CMSIS-Core validation test across the supported processors using multiple compilers. RTOS2 Validation Runs the CMSIS-RTOS2 validation across Keil RTX using source and library variants. STM32H743I-EVAL_BSP Build test of a Board Support Pack (BSP) with MDK-Middleware Reference Applications using Arm Compiler or GCC. The artifacts store the various example projects for testing on the hardware board. TFL Micro Speech This example project shows the Virtual Streaming Interface with Audio input and uses software layers for retargeting.","title":"Examples"},{"location":"build-tools/#ide-usage","text":"An IDE may use the following cbuild setup command to set up the project outline view and get information about components and software layers. cbuild setup example.csolution.yml --context-set [--packs] [--update-rte] The command above is used when the IDE starts: The option --context-set uses one target-type and optionally multiple related projects that are selected by a user in the file *.cbuild-set.yml . If this file is missing, it is created with the first target-type and the first build-type which are defined in the *.csolution.yml file. The option --packs can enable the download of missing software packs that are public. The option --update-rte is used when the IDE changes device: , board: or component: settings. The cbuild setup command creates build information files and generates the file compile_commands.json for IntelliSense in an VS Code IDE environment. Refer to cbuild setup command for more information.","title":"IDE Usage"},{"location":"build-tools/#project-outline-view","text":"The project outline view in an IDE may utilize the project files as described below: The file *.csolution.yml contains the overall structure of projects, build-types , and target-types . The file *cbuild-set.yml specifies the selected contexts; if it does not exist, the IDE may select the first project, first build-type , and first target-type from the file *.csolution.yml . The file *.cproject.yml provides the source groups, source files, and the list of components (but without source files). The files *.clayer.yml or *.cgen.yml contain software layers with additional source groups, source files, and components. The *.cbuild.<context>.yml files provide the exact location of these files, for example, when variables are used. Using the above information, it is possible to create an outline view, but without the file list for components. For software layers, the content may require the *.cbuild.<context>.yml files that are generated with the cbuild setup command. The cbuild-idx.yml file provides the exact location of all *.cbuild.<context>.yml files that are used in this context-set. The *.cbuild.<context>.yml files contain for the components source files, configuration file information, API header files, user code templates, generator information, and links to documentation. The project outline view may provide access to this information.","title":"Project Outline View"},{"location":"build-tools/#build-process","text":"An IDE may use the following cbuild command to build the overall application. cbuild example.csolution.yml --context-set [--packs] [--quite] [--rebuild] The option --context-set selects the projects along with target-type and build-type for the application. The option --packs can be enable the download missing software packs that are public. The option --quite suppresses details about the build process. The option --rebuild may be used to force a complete rebuild of the output files.","title":"Build Process"},{"location":"installation/","text":"Installation This chapter explains the setup of the CMSIS-Toolbox along with a build environment. There are three different ways to set up the CMSIS-Toolbox: Manual setup with operating system commands and environment variables. vcpkg in CLI using the vcpkg tool in command-line mode vcpkg in VS Code using the vcpkg tool with VS Code integration Manual Setup Download the CMSIS-Toolbox from the Arm Tools Artifactory . An archive file provides signed binaries for Windows (amd64), Linux (amd64, arm64), and MacOS/Darwin (amd64, arm64). To set up the CMSIS-Toolbox on a local computer, copy the content of the archive file to an <cmsis-toolbox-installation-dir> , for example, to ~/cmsis-toolbox . Requirements The CMSIS-Toolbox uses the CMake build system with a Ninja generator. The installation of these tools is required. CMake version 3.31.5 or higher. Note For Win64, enable the install option Add CMake to the system PATH . Ninja version 1.12.0 or higher. Note Ninja may be copied to the <cmsis-toolbox-installation-dir>/bin directory. Compiler Toolchains The CMSIS-Toolbox works with the following compiler toolchains. Install one or more compilers, depending on your requirements. GNU Arm Embedded Compiler version 10.3.1 or higher. Keil MDK version 5.36 or higher. Arm Compiler for Embedded version 6.18.0 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported IAR EW-Arm version 9.32.1 or higher. CLANG Embedded Compiler version 17.0.1 or higher. Environment Variables It maybe required to customize the installation for the actual setup of your development environment as described in the following. The various tools use the following environment variables. Environment Variable Description <name> _TOOLCHAIN_ <major> _ <minor> _ <patch> Required Path to the compiler binaries where <name> is one of AC6, GCC, IAR, CLANG. CMSIS_PACK_ROOT Optional Path to the CMSIS-Pack Root directory that stores software packs . CMSIS_COMPILER_ROOT Optional Path to the CMSIS-Toolbox etc directory (i.e. /c/cmsis-toolbox/etc ). Path Required Add to the system path the CMSIS-Toolbox bin directory (i.e. /c/cmsis-toolbox/bin ) as well as CMake and Ninja. Default Values The environment variables CMSIS_PACK_ROOT and CMSIS_COMPILER_ROOT are optional. If missing, default settings are used. CMSIS_PACK_ROOT default values: Platform Default path Linux ${HOME}/.cache/arm/packs Windows %LOCALAPPDATA%\\Arm\\Packs MacOS ${HOME}/.cache/arm/packs WSL_Windows ${LOCALAPPDATA}/Arm/Packs CMSIS_COMPILER_ROOT default is <toolbox>/bin/../etc , i.e., etc folder relative to the toolbox executables. It is used to locate: Toolchain cmake files <compiler-name>.<major>.<minor>.<patch>.cmake for the selected compiler . Default linker script files (to be preprocessed): <compiler-name>_linker_script.<ext>.src The cdefault.yml that is used when no cdefault.yml file is found in the same directory as the <solution-name>.csolution.yml file. Compiler Registration The compiler toolchain is registered with an environment variable that includes compiler name (AC6, GCC, IAR, LLVM) and version number (major, minor and patch). This information is used by the compiler: node or the --toolchain option to choose the compiler. Format: <name>_TOOLCHAIN_<major>_<minor>_<patch>=<path/to/toolchain/binaries> Example for Windows: set AC6_TOOLCHAIN_6_19_0=C:\\Keil_v5\\ARM\\ARMCLANG\\bin For Windows, use the dialog System Properties - Advanced and add the Environment Variables listed above. Example for Unix: export GCC_TOOLCHAIN_10_3_1=/opt/gcc-arm-none-eabi-10.3-2021.10/bin Keil MDK version 5 When using Keil MDK version 5, the CMSIS-Toolbox is shipped as part of the installer. The tools are located in the directory .\\ARM\\cmsis-toolbox of the MDK installation. Adding the binary directory of the cmsis-toolbox directory to your PATH environment variable allows you to invoke the tools at the command line without the need to specify the full path (default: C:\\Keil_v5\\ARM\\cmsis-toolbox\\bin ) For sharing the pack directory between MDK and the CMSIS-Toolbox, it is required that both CMSIS_PACK_ROOT environment variable and the RTEPATH setting in the MDK's TOOLS.INI (default: C:\\Keil_v5\\TOOLS.INI) point to the same directory. Note that in case the default location %LOCALAPPDATA%\\Arm\\Packs was selected during installation, the setting of CMSIS_PACK_ROOT environment variable is not required. The CMSIS_COMPILER_ROOT environment variable is not required if the compiler configuration files provided in cmsis-toolbox/etc are used. Note At the Windows command prompt, use set to list all environment variables. Keil \u00b5Vision may be used to: open projects in *.csolution.yml format (since v5.40). export project files in *.csolution.yml format. import project files in *.CPRJ format. Setup Linux or Bash In Linux, there are multiple ways to configure the Environment Variables . In a Bash environment, add the following content to the file .bashrc for example: Example: export CMSIS_PACK_ROOT=/home/ubuntu/packs export CMSIS_COMPILER_ROOT=/opt/cmsis-toolbox/etc export PATH=/opt/cmsis-toolbox/bin:$PATH Note The command printenv should list these environment variables. Setup macOS Add execution permissions for all executables in ./bin chmod +x <cmsis-toolbox-installation-dir>/bin/cbridge chmod +x <cmsis-toolbox-installation-dir>/bin/cbuild ... Registering CMSIS_PACK_ROOT with cpackget Once you are done with setting up the environment variables, run the following on the command line: cpackget init https://www.keil.com/pack/index.pidx Note Arm is running a public indexing server at the URL provided. You can specify any indexing server URL if you do not wish to use this service. vcpkg Setup using CLI The vcpkg is a package management tool that includes features to manage tool artifacts. Arm provides an artifactory system for tools. For more information, refer to Arm Tools Available in vcpkg . Note Microsoft changed the name of the shell version from vcpkg to vcpkg-shell . Depending on the version that you are using, you may need to call vcpkg-shell from the command line instead of vcpkg . The following describes how to set up the CMSIS-Toolbox with vcpkg in a command-line (CLI) environment. In many examples, the file vcpkg-configuration.json already exists, which describes the tool environment required for the example. Refer to the last step to create a new vcpkg-configuration.json file. Install and enable vcpkg The command to install and enable vcpkg depends on the shell. Windows Command Prompt (cmd): curl -LO https://aka.ms/vcpkg-init.cmd && .\\vcpkg-init.cmd %USERPROFILE%\\.vcpkg\\vcpkg-init.cmd Windows PowerShell: iex (iwr -useb https://aka.ms/vcpkg-init.ps1) . ~/.vcpkg/vcpkg-init.ps1 Linux (x64)/macOS: . <(curl https://aka.ms/vcpkg-init.sh -L) . ~/.vcpkg/vcpkg-init Note vcpkg is currently not working on - MSYS Bash (such as Git Bash) on Windows. - Linux (aarch64) Activate tools The required tools are specified in the vcpkg-configuration.json file, which can be found in the current or any parent directory. vcpkg-shell activate Note In case that activate fails, update registries to access the latest versions of the tools artifacts: vcpkg-shell x-update-registry --all Deactivate tools The configuration is deactivated with: vcpkg-shell deactivate Create vcpkg-configuration.json To create a new vcpkg-configuration.json file including the artifacts cmsis-toolbox, cmake, ninja, and arm-none-eabi-gcc use this sequence of commands: vcpkg-shell new --application vcpkg-shell add artifact arm:cmsis-toolbox [--version major.minor.patch] vcpkg-shell add artifact arm:cmake vcpkg-shell add artifact arm:ninja vcpkg-shell add artifact arm:arm-none-eabi-gcc vcpkg-shell activate Alternatively, you may use an existing repository, for example github.com/Open-CMSIS-Pack/vscode-get-started with a vcpkg-configuration.json file. vcpkg Command Line Mode Using vcpkg in Continuous Integration (CI) environments is basically like using it in a CLI environment . The way how vcpkg artifacts updates the current shell environment needs to be taken into account when creating CI pipelines. The command vcpkg-shell activate updates the current environment variables by extending PATH and adding additional variables required by installed artifacts. These modifications are only visible in the currently running shell and spawned subprocesses. This also enables manual usage on a local prompt, given a typical user runs subsequent commands from the same parent shell process. In contrast, typical CI systems such as GitHub Actions or Jenkins spawn a new sub-shell for each step of a pipeline. Hence, modifications made to the environment in one sub-shell by running the vcpkg-shell activate command, does not persist in the subsequent steps. Another aspect to consider is about handling the local vcpkg cache (e.g., ~/.vcpkg ). Common practice on CI systems is to recreate a clean environment for each run. Hence, vcpkg and all required artifacts are re-downloaded on every run. This may cause massive bandwidth requirements for downloading the same (huge) archives all the time. Instead, consider preserving the local vcpkg cache between runs. GitHub Actions GitHub Actions allow you to preserve environment settings via the files exposed in $GITHUB_PATH and $GITHUB_ENV . Refer to the custom action provided in github.com/ARM-software/cmsis-actions - Action: vcpkg for more information. Preserving the runners between runs vcpkg cache is achieved with an actions/cache step preceding the first vcpkg-shell activate command. The above custom action uses this actions/cache step. Other CI Systems In CI Systems without a vcpkg integration: Keep all tool installations depending on an activated environment within the same shell block, or Repeat activation for each new shell block before running any dependent command. . ~/.vcpkg/vcpkg-init vcpkg-shell activate vcpkg Setup in VS Code Download and install Microsoft Visual Studio Code for your operating system. Launch Visual Studio Code. Use the menu View and open Extensions and install the Keil Studio Pack extensions. Use the menu View and open Source Control . Select 'Clone Repository' and enter as url https://github.com/Open-CMSIS-Pack/vscode-get-started . Specify the destination folder to clone to and select 'Open' when asked 'Would you like to open the cloned directory?' Use the View menu 'Explorer' and select the file vcpkg-configuration.json . This file instructs Microsoft vcpkg to install the prerequisite artifacts required for building the solution and installs therefore: CMSIS-Toolbox 2.6.1 cmake 3.28.4 ninja 1.12.0 arm-none-eabi-gcc 13.3.1-mpacbti (GNU Arm Embedded Toolchain 13.3.1) Note If vcpkg shows an error in the VSCode status bar, the vcpkg output provides further information. Once the tools are installed, you may use the CMSIS-Toolbox commands in a Terminal window of VS Code. If the terminal icon shows a yellow triangle with an exclamation mark, you have to start a new terminal. This ensures that the environment settings updates triggered by the vcpkg activation are reflected in the terminal. Alternatively, use View and open the CMSIS Extension. Then use the Build buttons to translate the project, flash your connected board and/or launch a debug connection. CMSIS_PACK_ROOT The environment variable CMSIS_PACK_ROOT defines the location of the directory that stores the software packs. This directory has the following structure. Content of CMSIS_PACK_ROOT Description pack.idx Empty file that is touched (timestamp is updated) when packs are added or removed. /.Web Contains *.pdsc files available on public web pages. /.Web/index.pidx An index file that lists publicly available software packs. /.Download A local cache of packs that are downloaded. /.Local Stores the file local_repository.pidx that refers local *.pdsc files during pack development. Refer to install a repository for more information. /<vendor>/<name>/<version> Extracted software packs that are available for development using the CMSIS-Toolbox. Note For more details, refer to the CMSIS_PACK_ROOT Directory Wiki page .","title":"Installation"},{"location":"installation/#installation","text":"This chapter explains the setup of the CMSIS-Toolbox along with a build environment. There are three different ways to set up the CMSIS-Toolbox: Manual setup with operating system commands and environment variables. vcpkg in CLI using the vcpkg tool in command-line mode vcpkg in VS Code using the vcpkg tool with VS Code integration","title":"Installation"},{"location":"installation/#manual-setup","text":"Download the CMSIS-Toolbox from the Arm Tools Artifactory . An archive file provides signed binaries for Windows (amd64), Linux (amd64, arm64), and MacOS/Darwin (amd64, arm64). To set up the CMSIS-Toolbox on a local computer, copy the content of the archive file to an <cmsis-toolbox-installation-dir> , for example, to ~/cmsis-toolbox .","title":"Manual Setup"},{"location":"installation/#requirements","text":"The CMSIS-Toolbox uses the CMake build system with a Ninja generator. The installation of these tools is required. CMake version 3.31.5 or higher. Note For Win64, enable the install option Add CMake to the system PATH . Ninja version 1.12.0 or higher. Note Ninja may be copied to the <cmsis-toolbox-installation-dir>/bin directory.","title":"Requirements"},{"location":"installation/#compiler-toolchains","text":"The CMSIS-Toolbox works with the following compiler toolchains. Install one or more compilers, depending on your requirements. GNU Arm Embedded Compiler version 10.3.1 or higher. Keil MDK version 5.36 or higher. Arm Compiler for Embedded version 6.18.0 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported IAR EW-Arm version 9.32.1 or higher. CLANG Embedded Compiler version 17.0.1 or higher.","title":"Compiler Toolchains"},{"location":"installation/#environment-variables","text":"It maybe required to customize the installation for the actual setup of your development environment as described in the following. The various tools use the following environment variables. Environment Variable Description <name> _TOOLCHAIN_ <major> _ <minor> _ <patch> Required Path to the compiler binaries where <name> is one of AC6, GCC, IAR, CLANG. CMSIS_PACK_ROOT Optional Path to the CMSIS-Pack Root directory that stores software packs . CMSIS_COMPILER_ROOT Optional Path to the CMSIS-Toolbox etc directory (i.e. /c/cmsis-toolbox/etc ). Path Required Add to the system path the CMSIS-Toolbox bin directory (i.e. /c/cmsis-toolbox/bin ) as well as CMake and Ninja.","title":"Environment Variables"},{"location":"installation/#default-values","text":"The environment variables CMSIS_PACK_ROOT and CMSIS_COMPILER_ROOT are optional. If missing, default settings are used. CMSIS_PACK_ROOT default values: Platform Default path Linux ${HOME}/.cache/arm/packs Windows %LOCALAPPDATA%\\Arm\\Packs MacOS ${HOME}/.cache/arm/packs WSL_Windows ${LOCALAPPDATA}/Arm/Packs CMSIS_COMPILER_ROOT default is <toolbox>/bin/../etc , i.e., etc folder relative to the toolbox executables. It is used to locate: Toolchain cmake files <compiler-name>.<major>.<minor>.<patch>.cmake for the selected compiler . Default linker script files (to be preprocessed): <compiler-name>_linker_script.<ext>.src The cdefault.yml that is used when no cdefault.yml file is found in the same directory as the <solution-name>.csolution.yml file.","title":"Default Values"},{"location":"installation/#compiler-registration","text":"The compiler toolchain is registered with an environment variable that includes compiler name (AC6, GCC, IAR, LLVM) and version number (major, minor and patch). This information is used by the compiler: node or the --toolchain option to choose the compiler. Format: <name>_TOOLCHAIN_<major>_<minor>_<patch>=<path/to/toolchain/binaries> Example for Windows: set AC6_TOOLCHAIN_6_19_0=C:\\Keil_v5\\ARM\\ARMCLANG\\bin For Windows, use the dialog System Properties - Advanced and add the Environment Variables listed above. Example for Unix: export GCC_TOOLCHAIN_10_3_1=/opt/gcc-arm-none-eabi-10.3-2021.10/bin Keil MDK version 5 When using Keil MDK version 5, the CMSIS-Toolbox is shipped as part of the installer. The tools are located in the directory .\\ARM\\cmsis-toolbox of the MDK installation. Adding the binary directory of the cmsis-toolbox directory to your PATH environment variable allows you to invoke the tools at the command line without the need to specify the full path (default: C:\\Keil_v5\\ARM\\cmsis-toolbox\\bin ) For sharing the pack directory between MDK and the CMSIS-Toolbox, it is required that both CMSIS_PACK_ROOT environment variable and the RTEPATH setting in the MDK's TOOLS.INI (default: C:\\Keil_v5\\TOOLS.INI) point to the same directory. Note that in case the default location %LOCALAPPDATA%\\Arm\\Packs was selected during installation, the setting of CMSIS_PACK_ROOT environment variable is not required. The CMSIS_COMPILER_ROOT environment variable is not required if the compiler configuration files provided in cmsis-toolbox/etc are used. Note At the Windows command prompt, use set to list all environment variables. Keil \u00b5Vision may be used to: open projects in *.csolution.yml format (since v5.40). export project files in *.csolution.yml format. import project files in *.CPRJ format.","title":"Compiler Registration"},{"location":"installation/#setup-linux-or-bash","text":"In Linux, there are multiple ways to configure the Environment Variables . In a Bash environment, add the following content to the file .bashrc for example: Example: export CMSIS_PACK_ROOT=/home/ubuntu/packs export CMSIS_COMPILER_ROOT=/opt/cmsis-toolbox/etc export PATH=/opt/cmsis-toolbox/bin:$PATH Note The command printenv should list these environment variables.","title":"Setup Linux or Bash"},{"location":"installation/#setup-macos","text":"Add execution permissions for all executables in ./bin chmod +x <cmsis-toolbox-installation-dir>/bin/cbridge chmod +x <cmsis-toolbox-installation-dir>/bin/cbuild ...","title":"Setup macOS"},{"location":"installation/#registering-cmsis_pack_root-with-cpackget","text":"Once you are done with setting up the environment variables, run the following on the command line: cpackget init https://www.keil.com/pack/index.pidx Note Arm is running a public indexing server at the URL provided. You can specify any indexing server URL if you do not wish to use this service.","title":"Registering CMSIS_PACK_ROOT with cpackget"},{"location":"installation/#vcpkg-setup-using-cli","text":"The vcpkg is a package management tool that includes features to manage tool artifacts. Arm provides an artifactory system for tools. For more information, refer to Arm Tools Available in vcpkg . Note Microsoft changed the name of the shell version from vcpkg to vcpkg-shell . Depending on the version that you are using, you may need to call vcpkg-shell from the command line instead of vcpkg . The following describes how to set up the CMSIS-Toolbox with vcpkg in a command-line (CLI) environment. In many examples, the file vcpkg-configuration.json already exists, which describes the tool environment required for the example. Refer to the last step to create a new vcpkg-configuration.json file.","title":"vcpkg Setup using CLI"},{"location":"installation/#install-and-enable-vcpkg","text":"The command to install and enable vcpkg depends on the shell. Windows Command Prompt (cmd): curl -LO https://aka.ms/vcpkg-init.cmd && .\\vcpkg-init.cmd %USERPROFILE%\\.vcpkg\\vcpkg-init.cmd Windows PowerShell: iex (iwr -useb https://aka.ms/vcpkg-init.ps1) . ~/.vcpkg/vcpkg-init.ps1 Linux (x64)/macOS: . <(curl https://aka.ms/vcpkg-init.sh -L) . ~/.vcpkg/vcpkg-init Note vcpkg is currently not working on - MSYS Bash (such as Git Bash) on Windows. - Linux (aarch64)","title":"Install and enable vcpkg"},{"location":"installation/#activate-tools","text":"The required tools are specified in the vcpkg-configuration.json file, which can be found in the current or any parent directory. vcpkg-shell activate Note In case that activate fails, update registries to access the latest versions of the tools artifacts: vcpkg-shell x-update-registry --all","title":"Activate tools"},{"location":"installation/#deactivate-tools","text":"The configuration is deactivated with: vcpkg-shell deactivate","title":"Deactivate tools"},{"location":"installation/#create-vcpkg-configurationjson","text":"To create a new vcpkg-configuration.json file including the artifacts cmsis-toolbox, cmake, ninja, and arm-none-eabi-gcc use this sequence of commands: vcpkg-shell new --application vcpkg-shell add artifact arm:cmsis-toolbox [--version major.minor.patch] vcpkg-shell add artifact arm:cmake vcpkg-shell add artifact arm:ninja vcpkg-shell add artifact arm:arm-none-eabi-gcc vcpkg-shell activate Alternatively, you may use an existing repository, for example github.com/Open-CMSIS-Pack/vscode-get-started with a vcpkg-configuration.json file.","title":"Create vcpkg-configuration.json"},{"location":"installation/#vcpkg-command-line-mode","text":"Using vcpkg in Continuous Integration (CI) environments is basically like using it in a CLI environment . The way how vcpkg artifacts updates the current shell environment needs to be taken into account when creating CI pipelines. The command vcpkg-shell activate updates the current environment variables by extending PATH and adding additional variables required by installed artifacts. These modifications are only visible in the currently running shell and spawned subprocesses. This also enables manual usage on a local prompt, given a typical user runs subsequent commands from the same parent shell process. In contrast, typical CI systems such as GitHub Actions or Jenkins spawn a new sub-shell for each step of a pipeline. Hence, modifications made to the environment in one sub-shell by running the vcpkg-shell activate command, does not persist in the subsequent steps. Another aspect to consider is about handling the local vcpkg cache (e.g., ~/.vcpkg ). Common practice on CI systems is to recreate a clean environment for each run. Hence, vcpkg and all required artifacts are re-downloaded on every run. This may cause massive bandwidth requirements for downloading the same (huge) archives all the time. Instead, consider preserving the local vcpkg cache between runs.","title":"vcpkg Command Line Mode"},{"location":"installation/#github-actions","text":"GitHub Actions allow you to preserve environment settings via the files exposed in $GITHUB_PATH and $GITHUB_ENV . Refer to the custom action provided in github.com/ARM-software/cmsis-actions - Action: vcpkg for more information. Preserving the runners between runs vcpkg cache is achieved with an actions/cache step preceding the first vcpkg-shell activate command. The above custom action uses this actions/cache step.","title":"GitHub Actions"},{"location":"installation/#other-ci-systems","text":"In CI Systems without a vcpkg integration: Keep all tool installations depending on an activated environment within the same shell block, or Repeat activation for each new shell block before running any dependent command. . ~/.vcpkg/vcpkg-init vcpkg-shell activate","title":"Other CI Systems"},{"location":"installation/#vcpkg-setup-in-vs-code","text":"Download and install Microsoft Visual Studio Code for your operating system. Launch Visual Studio Code. Use the menu View and open Extensions and install the Keil Studio Pack extensions. Use the menu View and open Source Control . Select 'Clone Repository' and enter as url https://github.com/Open-CMSIS-Pack/vscode-get-started . Specify the destination folder to clone to and select 'Open' when asked 'Would you like to open the cloned directory?' Use the View menu 'Explorer' and select the file vcpkg-configuration.json . This file instructs Microsoft vcpkg to install the prerequisite artifacts required for building the solution and installs therefore: CMSIS-Toolbox 2.6.1 cmake 3.28.4 ninja 1.12.0 arm-none-eabi-gcc 13.3.1-mpacbti (GNU Arm Embedded Toolchain 13.3.1) Note If vcpkg shows an error in the VSCode status bar, the vcpkg output provides further information. Once the tools are installed, you may use the CMSIS-Toolbox commands in a Terminal window of VS Code. If the terminal icon shows a yellow triangle with an exclamation mark, you have to start a new terminal. This ensures that the environment settings updates triggered by the vcpkg activation are reflected in the terminal. Alternatively, use View and open the CMSIS Extension. Then use the Build buttons to translate the project, flash your connected board and/or launch a debug connection.","title":"vcpkg Setup in VS Code"},{"location":"installation/#cmsis_pack_root","text":"The environment variable CMSIS_PACK_ROOT defines the location of the directory that stores the software packs. This directory has the following structure. Content of CMSIS_PACK_ROOT Description pack.idx Empty file that is touched (timestamp is updated) when packs are added or removed. /.Web Contains *.pdsc files available on public web pages. /.Web/index.pidx An index file that lists publicly available software packs. /.Download A local cache of packs that are downloaded. /.Local Stores the file local_repository.pidx that refers local *.pdsc files during pack development. Refer to install a repository for more information. /<vendor>/<name>/<version> Extracted software packs that are available for development using the CMSIS-Toolbox. Note For more details, refer to the CMSIS_PACK_ROOT Directory Wiki page .","title":"CMSIS_PACK_ROOT"},{"location":"overview/","text":"Overview Target Audience This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs. The CMSIS-Toolbox contains stand-alone tools for all host platforms (Windows, Mac, Linux) that support: Arm Compiler for Embedded version 6.18 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported Arm GNU Toolchain (GCC) version 10.3.1 or higher IAR Compiler version 9.32.1 or higher CLANG Compiler version 17.0.1 or higher based on LLVM technology Notes This documentation uses the filename extension *.yml , but the extension *.yaml is also supported. The term CMSIS solution refers to an application project that is specified with csolution project files ( *.csolution.yml , *cproject.yml , and *.clayer.yml ). Software packs describe software components in Open-CMSIS-Pack format that can contain middleware, drivers, board support, or device support. Software packs also provide documentation, examples, and reusable software layers. Overall Workflow The CMSIS-Toolbox includes the following tools for the creation of embedded applications: Tool Description cpackget Pack Manager: install and manage software packs in the host development environment. cbuild Build Invocation: orchestrate the build steps utilizing CMSIS tools and a CMake compilation process. csolution Project Manager: create build information for embedded applications that consist of one or more related projects. These tools use software packs for device/board support and access to reusable software components. The operation is controlled via csolution project files in YAML format . The overall application is defined in the *.csolution.yml file and contains one or more projects that can utilize pre-configured software layers. The build engine CMake/Ninja calls the C/C++ compiler toolchain that generates the Build Output. The cbuild command orchestrates the overall build steps. This command calls individual tools to generate the application as outlined in the following diagram. The build steps are: cpackget downloads Software Packs that are required for *.csolution.yml when using the option --pack . csolution processes the csolution project and the Software Packs to generate the overall Build Information . Refer to CSolution Project Structure for details. cbuild2cmake converts this Build Information into CMake format. CMake/Ninja call the C/C++ compiler toolchain to translate the source files into the application image. Note The CMSIS-Toolbox build system does not use the CMake compiler and linker flags specified by environment variables CFLAGS, LDFLAGS . Refer to the chapter Build Operation for further details of the build process. Command Line and IDE Usage The CMSIS-Toolbox is a set of command line tools that are designed for stand-alone usage and integration into IDEs or DevOps systems for Continuous Integration (CI) workflows. Tip The VS Code extension Arm CMSIS Solution is a graphical user interface for csolution projects . The AVH-FVP examples and many projects on github.com/Open-CMSIS-Pack exemplify CI workflows. Benefits The overall benefits of the CMSIS-Toolbox are: Software packs simplify tool setup with device: or board: selection and provide access to reusable software components. Organize solutions with independent projects to support a wide range of use cases, including multi-processor applications or unit testing. Integrates with domain-specific generators (e.g., CubeMX or MCUXpresso Config Tools) for configuring devices/boards and complex software stacks such as motor control. Target types allow application deployment to different hardware (test board, production hardware, virtual simulation models, etc.). Build types support software testing and verification (debug build, test build, release build, ect.). Software layers enable code reuse across similar applications with a pre-configured set of source files and software components. Linker Script Management utilizes device and board information of software packs to define available memory and allows flexible control of linker operation. The Run and Debug Configuration collects all information to program and debug an application in a target system. Product lifecycle management (PLM) with versioned software packs that ease update and management for configuration files. Provides a list of software licenses used by the various software packs and software components.","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#target-audience","text":"This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs. The CMSIS-Toolbox contains stand-alone tools for all host platforms (Windows, Mac, Linux) that support: Arm Compiler for Embedded version 6.18 or higher Arm FuSa Compiler for Embedded version 6.16.2 or higher is also supported Arm GNU Toolchain (GCC) version 10.3.1 or higher IAR Compiler version 9.32.1 or higher CLANG Compiler version 17.0.1 or higher based on LLVM technology Notes This documentation uses the filename extension *.yml , but the extension *.yaml is also supported. The term CMSIS solution refers to an application project that is specified with csolution project files ( *.csolution.yml , *cproject.yml , and *.clayer.yml ). Software packs describe software components in Open-CMSIS-Pack format that can contain middleware, drivers, board support, or device support. Software packs also provide documentation, examples, and reusable software layers.","title":"Target Audience"},{"location":"overview/#overall-workflow","text":"The CMSIS-Toolbox includes the following tools for the creation of embedded applications: Tool Description cpackget Pack Manager: install and manage software packs in the host development environment. cbuild Build Invocation: orchestrate the build steps utilizing CMSIS tools and a CMake compilation process. csolution Project Manager: create build information for embedded applications that consist of one or more related projects. These tools use software packs for device/board support and access to reusable software components. The operation is controlled via csolution project files in YAML format . The overall application is defined in the *.csolution.yml file and contains one or more projects that can utilize pre-configured software layers. The build engine CMake/Ninja calls the C/C++ compiler toolchain that generates the Build Output. The cbuild command orchestrates the overall build steps. This command calls individual tools to generate the application as outlined in the following diagram. The build steps are: cpackget downloads Software Packs that are required for *.csolution.yml when using the option --pack . csolution processes the csolution project and the Software Packs to generate the overall Build Information . Refer to CSolution Project Structure for details. cbuild2cmake converts this Build Information into CMake format. CMake/Ninja call the C/C++ compiler toolchain to translate the source files into the application image. Note The CMSIS-Toolbox build system does not use the CMake compiler and linker flags specified by environment variables CFLAGS, LDFLAGS . Refer to the chapter Build Operation for further details of the build process.","title":"Overall Workflow"},{"location":"overview/#command-line-and-ide-usage","text":"The CMSIS-Toolbox is a set of command line tools that are designed for stand-alone usage and integration into IDEs or DevOps systems for Continuous Integration (CI) workflows. Tip The VS Code extension Arm CMSIS Solution is a graphical user interface for csolution projects . The AVH-FVP examples and many projects on github.com/Open-CMSIS-Pack exemplify CI workflows.","title":"Command Line and IDE Usage"},{"location":"overview/#benefits","text":"The overall benefits of the CMSIS-Toolbox are: Software packs simplify tool setup with device: or board: selection and provide access to reusable software components. Organize solutions with independent projects to support a wide range of use cases, including multi-processor applications or unit testing. Integrates with domain-specific generators (e.g., CubeMX or MCUXpresso Config Tools) for configuring devices/boards and complex software stacks such as motor control. Target types allow application deployment to different hardware (test board, production hardware, virtual simulation models, etc.). Build types support software testing and verification (debug build, test build, release build, ect.). Software layers enable code reuse across similar applications with a pre-configured set of source files and software components. Linker Script Management utilizes device and board information of software packs to define available memory and allows flexible control of linker operation. The Run and Debug Configuration collects all information to program and debug an application in a target system. Product lifecycle management (PLM) with versioned software packs that ease update and management for configuration files. Provides a list of software licenses used by the various software packs and software components.","title":"Benefits"},{"location":"pack-tools/","text":"Pack Creation This chapter describes how to create software packs and explains the tools packchk (software pack verification) and svdconv (SVD file converter). A pack provides a Pack Description file in XML format (*.pdsc) and collects information that is required by software developers and tools to work effectively with devices, boards, and middleware. Introduction The picture below shows the structure of the different packs and how boards, devices, and examples are exposed to an user in the Arm CMSIS Solution extension for VS Code. Packs are stacked: The Device Family Pack (DFP) is the foundation. The Board Support Pack (BSP) is based on DFP and are an extension. The Generic Software Packs (GSP) should use boards defined in a BSP to publish examples or Reference Applications that run on several boards. Tip A Blinky example in the BSP simplifies the bring up of an development environment in multiple ways. The VS Code extension CMSIS Solution gets examples via a web service. All required packs are automatically installed. It verifies compile, download, and hardware setup. The LED blinks with 1Hz which validates clock settings. Device Family Pack (DFP) Content The DFP provides foundation support for a device or device family and is used by: Compiler (Arm Compiler, GCC, IAR, and LLVM): startup code, project templates for bare-metal development, and memory information for linker scripts. Debuggers: SVD description files for peripheral awareness and debug description for configuration options. Programmers: download algorithms and debug description for download options. IDE and web portals: parameter information and links to documentation, repository, and support. Other technologies such as RUST or Zephyr as the DFP content can be exported. HAL drivers and CMSIS-Drivers that offer interfaces to device peripherals. Therefore, a DFP collects the following information: Must have Strongly recommended Optional Device description Overview.md file Project templates SVD description files Links to documentation Debug description Device Header file Device features HAL drivers Startup files (see note) Pack Requirements CMSIS-Drivers Download algorithms Note Startup files are not required if templates for a configuration generator (such as CubeMX) exports the startup code. Hands-on Tutorial: DFP-Pack-HandsOn explains the structure and creation of a Device Family Pack (DFP). Pack Example: STM32L4xx_DFP available on keil.arm.com/packs/stm32l4xx_dfp-keil . Board Support Pack (BSP) Content A BSP extends the DFP with information that relates to boards: The Blinky example verifies hardware and tool setup and provides the bootstrap for IDE workflows. With CMSIS-Driver VIO, simple I/Os such as LEDs and push buttons are controlled, and test automation is supported. Project templates configured for board peripherals. A layer can provide a pre-configured driver set for reference applications that interface to middleware. Board memory with download algorithms extend the information for programmers and linker scripts. Tip The Blinky example of the BSP-Pack-HandsOn is generic. All it requires to adapt the ./Driver/vio*.c to the actual hardware of the board. Must have Strongly recommended Optional Board description Overview.md file Additional examples Blinky example Layers for Reference Applications CMSIS-Driver VIO for LED and button HAL drivers for board peripherals Board features Project templates (board specific) Download algorithms for on-board memory Pack Requirements Note The content of a DFP and BSP may be provided in a single pack. Hands-on Tutorial: BSP-Pack-HandsOn explains the structure and creation of a Board Support Pack (BSP). Pack Example: NUCLEO-F746ZG_BSP available on keil.arm.com/packs/nucleo-f746zg_bsp-keil . Generic Software Pack (GSP) Content A GSP may provide additional middleware software such as RTOS, communication stacks, or crypto libraries. Hands-on Tutorial: GSP-Pack-HandsOn explains the steps to create a software pack. Pack Example: MDK-Middleware available on www.keil.arm.com/packs/mdk-middleware-keil . Hints for Pack Creation Several tools and scripts help to automate the pack creation and are used in these hands-on tutorials. Use C startup files that allows the use of a DFP with any toolchain. For elements, use a brief description text of less than 128 characters to explain the purpose. When possible, link to documentation with detailed information. Example: A component Device:HAL:ENET should not have description ENET HAL Driver , use Ethernet HAL driver instead. Consider adding project templates to help get started with more complex projects. This is useful when devices are configured using generators or provide multiple linker scripts (e.g., RAM/ROM execution). To distribute toolchain agnostic examples as part of packs: Consider to use select-compiler to make projects toolchain independent. To avoid that examples need updates with every pack release, specify the minimum pack version required . Use CI workflows to validate that projects compile correctly. Add an overview.md file that describes the software pack's overall usage. These files are displayed on www.keil.arm.com/packs and indexed by Web search engines. Pack Creation Tools The following tools are part of the CMSIS-Toolbox. These tools can be used to develop packs on a local computer and to automate the creation of packs. Tool Description packchk Pack Validation: installs and manages software packs in the local development environment. svdconv SVD Check / Convert: validate and/or convert System View Description (SVD) files. vidx2pidx Package Index Generator: check Package index file (PIDX) for indexing in public pack services. Usage The following section is based on the repositories DFP-Pack-HandsOn and BSP-Pack-HandsOn . Checkout these packs for local development of pack content. Tip Install the VS Code extension CMSIS Solution and related tools. The Keil Studio Pack is a collection of such related extensions. Step 1: Create an empty workspace and ensure that development tools are available. When using the Arm Tools Environment Manager this can be configured using the following vand related tools are installed. { \"registries\": [ { \"name\": \"arm\", \"kind\": \"artifact\", \"location\": \"https://artifacts.tools.arm.com/vcpkg-registry\" } ], \"requires\": { \"arm:compilers/arm/armclang\": \"6.23.0\", \"arm:compilers/arm/arm-none-eabi-gcc\": \"14.2.1\", \"arm:compilers/arm/llvm-embedded\": \"19.1.5\", \"arm:tools/kitware/cmake\": \"3.31.5\", \"arm:tools/ninja-build/ninja\": \"1.12.0\", \"arm:tools/open-cmsis-pack/cmsis-toolbox\": \"2.7.0\" } } Tip Verify the setup with the commands cbuild list environment and cbuild list toolchains . Step 2: Register packs for development using these commands: cpackget add <workdir>/DFP-Pack-Handson/ACME.ACMECM4_DFP.pdsc cpackget add <workdir>/BSP-Pack-Handson/ACME.ACME_BSP.pdsc Tip The CMSIS-Toolbox now uses this local repositories. Verify the installation with with the commands cpackget list , csolution list devices , and csolution list boards . Note CMSIS-Toolbox 2.7.0 adds an empty <timestamp></timestamp> line to the file $CMSIS_PACK_ROOT/local/local_repository.pidx which prevents the VS Code extension from using the local pack content. As workaround remove this line. Content of $CMSIS_PACK_ROOT/local/local_repository.pidx : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <index schemaVersion=\"1.1.0\"> <vendor>local repository</vendor> <url>file://localhost/C:/Users/reikei01/AppData/Local/Arm/Packs</url> <pindex> <pdsc vendor=\"ACME\" url=\"file://localhost/c:/w/DFP-Pack-Handson/\" name=\"ACMECM4_DFP\" version=\"1.1.1\"></pdsc> <pdsc vendor=\"ACME\" url=\"file://localhost/C:/w/BSP-Pack-HandsOn/\" name=\"ACME_BSP\" version=\"1.0.0\"></pdsc> </pindex> </index> Step 3: The various tools have now access to the local packs and you may change the PDSC files. Rename the packs to reflect your products and develop the content starting with the MUST HAVE items listed above. Tip Use the VS Code extension Red Hat XML for syntax help on the XML format. Step 4: Verify the packs using the following commands: packchk <workdir>/DFP-Pack-Handson/ACME.ACMECM4_DFP.pdsc -i $CMSIS_PACK_ROOT/ARM/CMSIS/6.1.0/ARM.CMSIS.pdsc packchk <workdir>/BSP-Pack-Handson/ACME.ACME_BSP.pdsc -i <workdir>/DFP-Pack-Handson/ACME.ACMECM4_DFP -i $CMSIS_PACK_ROOT/ARM/CMSIS/6.1.0/ARM.CMSIS.pdsc Step 5: Verify the Blinky example with a build test in an IDE and execution test on the board. Step 6: Commit the packs to the repository, verify the GitHub action workflows, download the artifacts. Make an end-to-end test of the packs on a different computer. Step 7: Publish the packs . Pack Generation Packs may be generated using scripts. Several scripts are available on github.com/open-cmsis-pack : gen-pack is a library for scripts creating software packs. gen-pack-action is a GitHub workflow action generating documentation and software packs. Tip Arm uses GitHub actions to create packs. Review this process under the workflow directory on the projects available on github.com/arm-software or github.com/open-cmsis-pack . A good simple pack project is the CMSIS-Driver pack . Once this pack is published it is available for software developers using pack managers or web portals . Versioning The CMSIS-Pack system uses version numbers to track and differentiate various releases of packs, components, and configuration files. It supports these versioning schemas: Semantic Versioning ( SemVer ) is the recommended format with MAJOR.MINOR.PATCH . for example: 1.4.2 . SemVer MAJOR indicates big updates that break backward compatibility. MINOR indicates new features, but still backward-compatible. PATCH indicates bug fixes or minor tweaks. Calendar Versioning ( CalVer ) is accepted when higher values indicated newer releases. The format should be therefore YY.MM.DD , or YY.MM.PATCH . For example: 22.04.1 indicates April 2022 release, patch version 1. 25.02.07 indicates release date 7. Feb. 2025. Both versioning schemas support -pre-release labels that may be used during development and testing. For example: 1.0.0-alpha for early testing. 22.04.0-rc.1 for a release candidate that is close to final. Product Lifecycle Management (PLM) and versioning are closely connected. Versioning ensures that each stage of PLM is properly controlled and documented. The CMSIS-Toolbox accepts therefore version numbers and ranges for packs and components and outputs version details in build information files . Semantic Versioning ( SemVer ) is recommended as it supports the PLM features of the CMSIS-Toolbox. It enables PLM of configuration files and simplifies the software pack updates. For example: - pack: ARM::CMSIS@^6.1.0 accepts any release version equal or higher but with the same MAJOR version. To accept also pre-release versions, use - pack: ARM::CMSIS@^6.1.0-0 . Note During the development of a pack +build information may be used. This +build information is ignored by the CMSIS-Toolbox and should be not part of a public released pack. Project Examples Project examples help to get started with new devices, boards, and middleware software components. The CMSIS-Pack format supports, therefore, different types of project examples: Template Projects are stub projects that help to get started. Some software packs may contain device-specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications are hardware-agnostic project examples that required layers to add the hardware abstraction of a target (typically a board). In addition, packs may contain: Layers are pre-configured software components or source code that can be shared across multiple projects. Code Templates are stub source files for middleware components that can be incorporated into user code. The following section explains how the different types of project examples are structured and registered within a CMSIS-Pack. Support Multiple Compilers To make project examples independent of a specific compiler toolchain, the *.csolution.yml file should include the select-compiler: node with a list of tested compilers. When a user or IDE starts such an example, the compiler: node that selects the compiler gets added. Example: solution: description: <brief description of the project example> created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG : Related Examples The *.csolution.yml file may contain several related projects that share the same target-types: and build-types: . Example: solution: : projects: - project: BSD_Server/BSD_Server.cproject.yml - project: FTP_Server/FTP_Server.cproject.yml - project: HTTP_Server/HTTP_Server.cproject.yml Template Projects The VSCode extension CMSIS Solution supports template projects that are part of a DFP or BSP. It is a starting point for a user application and can be directly compiled, but the functionality is mostly empty. Template projects may provide: Setup for single-core, TrustZone, or multi-core projects, optional with execution from ROM or RAM. Can be device and board specific, optional Configuration Generator. May contain other projects that are ready to use (Bootloader, Trusted Firmware). A template project may omit device: , board: , and pack: specification in the *.csolution.yml file. When a IDE starts a template this information is added depending on user selection. Note Templates should compile when the IDE adds above information to the *.csolution.yml file. The exception is when templates require parts of the code provided by a generator. Simple Template: A simple template only defines one project. # A solution is a collection of related projects that share same base configuration. solution: created-for: CMSIS-Toolbox@2.6.0 cdefault: # List of tested compilers that can be selected select-compiler: - compiler: AC6 - compiler: GCC - compiler: IAR target-types: # empty, filled in by IDE # List of different build configurations. build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced # List related projects. projects: - project: Simple.cproject.yml Multi-Target Template: A multi-target template may contain different configurations for the same target, such as one that executes from ROM and another that executes from RAM. The example below shows how this could be achieved using variables: . solution: : target-types: - type: ${Name}_ROM variables: - RegionsHeader: <path>/memory_flash.h - type: ${Name}_RAM variables: - RegionsHeader: <path>/memory_ram.h : In the example above, projects can use the linker: node in the *.cproject.yml file to reference the regions header file of the selected target. project: linker: - regions: $RegionsHeader$ Board-specific Template: Board specific template projects provide a meaningful configuration for peripherals on a board. As it is fixed to a board, it may define the target-type along with that packs required. solution: : packs: - pack: NXP::FRDM-MCXN947_BSP # do not use pack version as it is part of a BSP - pack: NXP::MCXN947_DFP - pack: ARM::CMSIS target-types: - type: MCXN947 device: NXP::MCXN947VDF board: NXP::FRDM-MCXN947 Register Template in PDSC File: Templates are published using the <csolution> element in the PDSC file. Device-specific Templates should be part of the DFP. Board-specific templates should be part of the BSP. <csolution> <template name=\"Simple Device project\" path=\"/device/Simple\" file=\"Simple.csolution.yml\" condition=\"Device_Spec\"> <description>Single-core project with empty main function configured for device</description> </template> <template name=\"Simple Board project\" path=\"/board/Simple\" file=\"Simple.csolution.yml\" condition=\"Board_Spec\"> <description>Single-core project with empty main function configured for board</description> </template> </csolution> Examples Examples are complete projects that typically run on a board. They should, therefore, specify a target-type with board: and list the packs: that are used, specifically the DFP and BSP. To minimize maintenance of Examples that are part of a pack, consider these rules: IMPORTANT: Store all files that are part of the ./RTE directory . These files store configuration and are important for PLM . Use select-compiler: when the Example works with several toolchains. Do not specify compiler: . Specify minimum pack version . Do not store *.cbuild-pack.yml . The tool selects first target-type and first build-type when cbuild-set.yml is missing. For simple projects, do not store *.cbuild-set.yml . For simple projects, rely on the cdefault.yml file that is provided with CMSIS-Toolbox. Examples that work with several compiler toolchains should use select-compiler: and not define compiler: explicitly. The available toolchain's compiler: node is added when the Example is loaded into the IDE. When minimum pack versions are specified, the semantic versioning of packs should ensure that newer pack versions work also. As the *.cbuild-pack.yml file fixes pack versions, this file should not be stored in the pack. Examples may contain multiple related projects in the *.csolution.yml file that, for example, cover different aspects of peripheral or middleware. For such Examples , it is not required to store the *.cbuild-set.yml file as the tools select the first target-type and build-type of the *.csolution.yml file. Examples that do not require special compiler controls may rely on the cdefault.yml file that is provided with CMSIS-Toolbox as this file contains reasonable default settings. For more complex Examples , provide a local copy of the cdefault.yml file in the same directory as the *.csolution.yml file. Refer to Toolchain Agnostic Project for further information. csolution.yml file of an Example : solution: # Optional: Add a brief description line (recommendation less than 128 characters) description: Example that shows the usage of Fault component on a Cortex-M33 with TrustZone created-for: CMSIS-Toolbox@2.6.0 # minimum CMSIS-Toolbox version, newer versions will work also cdefault: select-compiler: - compiler: GCC # GCC is supported - compiler: AC6 # AC6 is supported - compiler: IAR # IAR is supported packs: - pack: Keil::STM32U5xx_DFP@^2.1.0 # minimum compatible pack version - pack: Keil::B-U585I-IOT02A_BSP@^1.0.0 target-types: - type: B-U585I-IOT02A board: STMicroelectronics::B-U585I-IOT02A device: STMicroelectronics::STM32U585AIIx build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Secure/Fault_S.cproject.yml - project: ./NonSecure/Fault_NS.cproject.yml Register Examples in PDSC File: Examples can be part of any pack and are published using the <examples> element in the PDSC file. Note that it is possible to register multiple project formats to support different tool environments. <examples> <example name=\"Fault example\" folder=\"Examples/Fault/B-U585I-IOT02A\" doc=\"README.md\"> <description>Example that shows the usage of Fault component on a Cortex-M33 with TrustZone</description> <board name=\"B-U585I-IOT02A\" vendor=\"STMicroelectronics\"/> <project> <environment name=\"csolution\" load=\"Fault.csolution.yml\"/> <environment name=\"uv\" load=\"Fault.uvmpw\"/> </project> </example> </examples> Reference Applications Reference applications can run on many different target hardware boards. Similar to template projects , the device: and board: along with the required DFP and BSP pack: is not specified in the *.csolution.yml file. solution: description: IPv4/IPv6 Network examples created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG target-types: - type: Name # board: # added during creation of solution # variables: # - Board-Layer: <board_layer>.clayer.yml Note The MDK-Middleware contains several reference applications that exemplify the overall structure. Register Reference Applications in PDSC File: Reference Applications are typically part of a middleware software pack and publish using the <examples> element in the PDSC file. The difference to examples is that no <board> element is used as the reference application is hardware agnostic. <examples> </example> <example name=\"Network\" doc=\"README.md\" folder=\"Examples/Network\"> <description>MDK-Middleware: IPv4/IPv6 Client and Server applications via Ethernet</description> <project> <environment name=\"csolution\" load=\"Network.csolution.yml\"/> </project> </example> Layers Layers with connections are used to by Reference Applications to target hardware. These layers are added when a reference application is configured for a board: , typically in the IDE. Register Layers in PDSC File: Layers are part of a BSP and published using the <csolution> element in the PDSC file. <csolution> <clayer type=\"Board\" path=\"Layers/Default\" file=\"Board.clayer.yml\" copy-to=\"Board/MyBoard\" condition=\"Board-Spec\"/> </csolution> Note Several STM32 Board Support Packs (BSP) contain layers that are pre-configured for certain applications. For example, the layer in the ST_NUCLEO-F756ZG_BSP supports applications that require Ethernet, USB Device, UART, or I2C interfaces. Code Templates Code templates are part of the components files in the PDSC file and can be manually added by the user to a software project. Code templates show how a software component is used, and the source code can be directly adapted to the requirements of the application program. Register Code Templates in PDSC File: Code Templates are part of a software component and published using the <components> element using attr=\"template\" in the PDSC file. <component Cgroup=\"Socket\" Csub=\"UDP\" condition=\"Network Interface\"> : <files> <file category=\"doc\" name=\"Documentation/html/Network/group__netUDP__Func.html\"/> <file category=\"header\" name=\"Components/Network/Config/Net_Config_UDP.h\" attr=\"config\" version=\"5.1.1\"/> <file category=\"source\" name=\"Components/Network/Template/UDP_Socket.c\" attr=\"template\" select=\"UDP Socket\"/> <!-- Library source files --> <file category=\"source\" name=\"Components/Network/Source/net_udp.c\"/> </files> Note The CMSIS-RTX and MDK-Middleware packs contain several code templates that exemplify the overall structure. Pack Examples Several pack examples available on github.com/Open-CMSIS-Pack exemplify how to create software packs. Other packs that are a good reference are the various Arm CMSIS packs or the MDK Middleware pack . The source of these packs is available on Github/Arm-software .","title":"Pack Creation"},{"location":"pack-tools/#pack-creation","text":"This chapter describes how to create software packs and explains the tools packchk (software pack verification) and svdconv (SVD file converter). A pack provides a Pack Description file in XML format (*.pdsc) and collects information that is required by software developers and tools to work effectively with devices, boards, and middleware.","title":"Pack Creation"},{"location":"pack-tools/#introduction","text":"The picture below shows the structure of the different packs and how boards, devices, and examples are exposed to an user in the Arm CMSIS Solution extension for VS Code. Packs are stacked: The Device Family Pack (DFP) is the foundation. The Board Support Pack (BSP) is based on DFP and are an extension. The Generic Software Packs (GSP) should use boards defined in a BSP to publish examples or Reference Applications that run on several boards. Tip A Blinky example in the BSP simplifies the bring up of an development environment in multiple ways. The VS Code extension CMSIS Solution gets examples via a web service. All required packs are automatically installed. It verifies compile, download, and hardware setup. The LED blinks with 1Hz which validates clock settings.","title":"Introduction"},{"location":"pack-tools/#device-family-pack-dfp-content","text":"The DFP provides foundation support for a device or device family and is used by: Compiler (Arm Compiler, GCC, IAR, and LLVM): startup code, project templates for bare-metal development, and memory information for linker scripts. Debuggers: SVD description files for peripheral awareness and debug description for configuration options. Programmers: download algorithms and debug description for download options. IDE and web portals: parameter information and links to documentation, repository, and support. Other technologies such as RUST or Zephyr as the DFP content can be exported. HAL drivers and CMSIS-Drivers that offer interfaces to device peripherals. Therefore, a DFP collects the following information: Must have Strongly recommended Optional Device description Overview.md file Project templates SVD description files Links to documentation Debug description Device Header file Device features HAL drivers Startup files (see note) Pack Requirements CMSIS-Drivers Download algorithms Note Startup files are not required if templates for a configuration generator (such as CubeMX) exports the startup code. Hands-on Tutorial: DFP-Pack-HandsOn explains the structure and creation of a Device Family Pack (DFP). Pack Example: STM32L4xx_DFP available on keil.arm.com/packs/stm32l4xx_dfp-keil .","title":"Device Family Pack (DFP) Content"},{"location":"pack-tools/#board-support-pack-bsp-content","text":"A BSP extends the DFP with information that relates to boards: The Blinky example verifies hardware and tool setup and provides the bootstrap for IDE workflows. With CMSIS-Driver VIO, simple I/Os such as LEDs and push buttons are controlled, and test automation is supported. Project templates configured for board peripherals. A layer can provide a pre-configured driver set for reference applications that interface to middleware. Board memory with download algorithms extend the information for programmers and linker scripts. Tip The Blinky example of the BSP-Pack-HandsOn is generic. All it requires to adapt the ./Driver/vio*.c to the actual hardware of the board. Must have Strongly recommended Optional Board description Overview.md file Additional examples Blinky example Layers for Reference Applications CMSIS-Driver VIO for LED and button HAL drivers for board peripherals Board features Project templates (board specific) Download algorithms for on-board memory Pack Requirements Note The content of a DFP and BSP may be provided in a single pack. Hands-on Tutorial: BSP-Pack-HandsOn explains the structure and creation of a Board Support Pack (BSP). Pack Example: NUCLEO-F746ZG_BSP available on keil.arm.com/packs/nucleo-f746zg_bsp-keil .","title":"Board Support Pack (BSP) Content"},{"location":"pack-tools/#generic-software-pack-gsp-content","text":"A GSP may provide additional middleware software such as RTOS, communication stacks, or crypto libraries. Hands-on Tutorial: GSP-Pack-HandsOn explains the steps to create a software pack. Pack Example: MDK-Middleware available on www.keil.arm.com/packs/mdk-middleware-keil .","title":"Generic Software Pack (GSP) Content"},{"location":"pack-tools/#hints-for-pack-creation","text":"Several tools and scripts help to automate the pack creation and are used in these hands-on tutorials. Use C startup files that allows the use of a DFP with any toolchain. For elements, use a brief description text of less than 128 characters to explain the purpose. When possible, link to documentation with detailed information. Example: A component Device:HAL:ENET should not have description ENET HAL Driver , use Ethernet HAL driver instead. Consider adding project templates to help get started with more complex projects. This is useful when devices are configured using generators or provide multiple linker scripts (e.g., RAM/ROM execution). To distribute toolchain agnostic examples as part of packs: Consider to use select-compiler to make projects toolchain independent. To avoid that examples need updates with every pack release, specify the minimum pack version required . Use CI workflows to validate that projects compile correctly. Add an overview.md file that describes the software pack's overall usage. These files are displayed on www.keil.arm.com/packs and indexed by Web search engines.","title":"Hints for Pack Creation"},{"location":"pack-tools/#pack-creation-tools","text":"The following tools are part of the CMSIS-Toolbox. These tools can be used to develop packs on a local computer and to automate the creation of packs. Tool Description packchk Pack Validation: installs and manages software packs in the local development environment. svdconv SVD Check / Convert: validate and/or convert System View Description (SVD) files. vidx2pidx Package Index Generator: check Package index file (PIDX) for indexing in public pack services.","title":"Pack Creation Tools"},{"location":"pack-tools/#usage","text":"The following section is based on the repositories DFP-Pack-HandsOn and BSP-Pack-HandsOn . Checkout these packs for local development of pack content. Tip Install the VS Code extension CMSIS Solution and related tools. The Keil Studio Pack is a collection of such related extensions. Step 1: Create an empty workspace and ensure that development tools are available. When using the Arm Tools Environment Manager this can be configured using the following vand related tools are installed. { \"registries\": [ { \"name\": \"arm\", \"kind\": \"artifact\", \"location\": \"https://artifacts.tools.arm.com/vcpkg-registry\" } ], \"requires\": { \"arm:compilers/arm/armclang\": \"6.23.0\", \"arm:compilers/arm/arm-none-eabi-gcc\": \"14.2.1\", \"arm:compilers/arm/llvm-embedded\": \"19.1.5\", \"arm:tools/kitware/cmake\": \"3.31.5\", \"arm:tools/ninja-build/ninja\": \"1.12.0\", \"arm:tools/open-cmsis-pack/cmsis-toolbox\": \"2.7.0\" } } Tip Verify the setup with the commands cbuild list environment and cbuild list toolchains . Step 2: Register packs for development using these commands: cpackget add <workdir>/DFP-Pack-Handson/ACME.ACMECM4_DFP.pdsc cpackget add <workdir>/BSP-Pack-Handson/ACME.ACME_BSP.pdsc Tip The CMSIS-Toolbox now uses this local repositories. Verify the installation with with the commands cpackget list , csolution list devices , and csolution list boards . Note CMSIS-Toolbox 2.7.0 adds an empty <timestamp></timestamp> line to the file $CMSIS_PACK_ROOT/local/local_repository.pidx which prevents the VS Code extension from using the local pack content. As workaround remove this line. Content of $CMSIS_PACK_ROOT/local/local_repository.pidx : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <index schemaVersion=\"1.1.0\"> <vendor>local repository</vendor> <url>file://localhost/C:/Users/reikei01/AppData/Local/Arm/Packs</url> <pindex> <pdsc vendor=\"ACME\" url=\"file://localhost/c:/w/DFP-Pack-Handson/\" name=\"ACMECM4_DFP\" version=\"1.1.1\"></pdsc> <pdsc vendor=\"ACME\" url=\"file://localhost/C:/w/BSP-Pack-HandsOn/\" name=\"ACME_BSP\" version=\"1.0.0\"></pdsc> </pindex> </index> Step 3: The various tools have now access to the local packs and you may change the PDSC files. Rename the packs to reflect your products and develop the content starting with the MUST HAVE items listed above. Tip Use the VS Code extension Red Hat XML for syntax help on the XML format. Step 4: Verify the packs using the following commands: packchk <workdir>/DFP-Pack-Handson/ACME.ACMECM4_DFP.pdsc -i $CMSIS_PACK_ROOT/ARM/CMSIS/6.1.0/ARM.CMSIS.pdsc packchk <workdir>/BSP-Pack-Handson/ACME.ACME_BSP.pdsc -i <workdir>/DFP-Pack-Handson/ACME.ACMECM4_DFP -i $CMSIS_PACK_ROOT/ARM/CMSIS/6.1.0/ARM.CMSIS.pdsc Step 5: Verify the Blinky example with a build test in an IDE and execution test on the board. Step 6: Commit the packs to the repository, verify the GitHub action workflows, download the artifacts. Make an end-to-end test of the packs on a different computer. Step 7: Publish the packs .","title":"Usage"},{"location":"pack-tools/#pack-generation","text":"Packs may be generated using scripts. Several scripts are available on github.com/open-cmsis-pack : gen-pack is a library for scripts creating software packs. gen-pack-action is a GitHub workflow action generating documentation and software packs. Tip Arm uses GitHub actions to create packs. Review this process under the workflow directory on the projects available on github.com/arm-software or github.com/open-cmsis-pack . A good simple pack project is the CMSIS-Driver pack . Once this pack is published it is available for software developers using pack managers or web portals .","title":"Pack Generation"},{"location":"pack-tools/#versioning","text":"The CMSIS-Pack system uses version numbers to track and differentiate various releases of packs, components, and configuration files. It supports these versioning schemas: Semantic Versioning ( SemVer ) is the recommended format with MAJOR.MINOR.PATCH . for example: 1.4.2 . SemVer MAJOR indicates big updates that break backward compatibility. MINOR indicates new features, but still backward-compatible. PATCH indicates bug fixes or minor tweaks. Calendar Versioning ( CalVer ) is accepted when higher values indicated newer releases. The format should be therefore YY.MM.DD , or YY.MM.PATCH . For example: 22.04.1 indicates April 2022 release, patch version 1. 25.02.07 indicates release date 7. Feb. 2025. Both versioning schemas support -pre-release labels that may be used during development and testing. For example: 1.0.0-alpha for early testing. 22.04.0-rc.1 for a release candidate that is close to final. Product Lifecycle Management (PLM) and versioning are closely connected. Versioning ensures that each stage of PLM is properly controlled and documented. The CMSIS-Toolbox accepts therefore version numbers and ranges for packs and components and outputs version details in build information files . Semantic Versioning ( SemVer ) is recommended as it supports the PLM features of the CMSIS-Toolbox. It enables PLM of configuration files and simplifies the software pack updates. For example: - pack: ARM::CMSIS@^6.1.0 accepts any release version equal or higher but with the same MAJOR version. To accept also pre-release versions, use - pack: ARM::CMSIS@^6.1.0-0 . Note During the development of a pack +build information may be used. This +build information is ignored by the CMSIS-Toolbox and should be not part of a public released pack.","title":"Versioning"},{"location":"pack-tools/#project-examples","text":"Project examples help to get started with new devices, boards, and middleware software components. The CMSIS-Pack format supports, therefore, different types of project examples: Template Projects are stub projects that help to get started. Some software packs may contain device-specific templates. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications are hardware-agnostic project examples that required layers to add the hardware abstraction of a target (typically a board). In addition, packs may contain: Layers are pre-configured software components or source code that can be shared across multiple projects. Code Templates are stub source files for middleware components that can be incorporated into user code. The following section explains how the different types of project examples are structured and registered within a CMSIS-Pack.","title":"Project Examples"},{"location":"pack-tools/#support-multiple-compilers","text":"To make project examples independent of a specific compiler toolchain, the *.csolution.yml file should include the select-compiler: node with a list of tested compilers. When a user or IDE starts such an example, the compiler: node that selects the compiler gets added. Example: solution: description: <brief description of the project example> created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG :","title":"Support Multiple Compilers"},{"location":"pack-tools/#related-examples","text":"The *.csolution.yml file may contain several related projects that share the same target-types: and build-types: . Example: solution: : projects: - project: BSD_Server/BSD_Server.cproject.yml - project: FTP_Server/FTP_Server.cproject.yml - project: HTTP_Server/HTTP_Server.cproject.yml","title":"Related Examples"},{"location":"pack-tools/#template-projects","text":"The VSCode extension CMSIS Solution supports template projects that are part of a DFP or BSP. It is a starting point for a user application and can be directly compiled, but the functionality is mostly empty. Template projects may provide: Setup for single-core, TrustZone, or multi-core projects, optional with execution from ROM or RAM. Can be device and board specific, optional Configuration Generator. May contain other projects that are ready to use (Bootloader, Trusted Firmware). A template project may omit device: , board: , and pack: specification in the *.csolution.yml file. When a IDE starts a template this information is added depending on user selection. Note Templates should compile when the IDE adds above information to the *.csolution.yml file. The exception is when templates require parts of the code provided by a generator. Simple Template: A simple template only defines one project. # A solution is a collection of related projects that share same base configuration. solution: created-for: CMSIS-Toolbox@2.6.0 cdefault: # List of tested compilers that can be selected select-compiler: - compiler: AC6 - compiler: GCC - compiler: IAR target-types: # empty, filled in by IDE # List of different build configurations. build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced # List related projects. projects: - project: Simple.cproject.yml Multi-Target Template: A multi-target template may contain different configurations for the same target, such as one that executes from ROM and another that executes from RAM. The example below shows how this could be achieved using variables: . solution: : target-types: - type: ${Name}_ROM variables: - RegionsHeader: <path>/memory_flash.h - type: ${Name}_RAM variables: - RegionsHeader: <path>/memory_ram.h : In the example above, projects can use the linker: node in the *.cproject.yml file to reference the regions header file of the selected target. project: linker: - regions: $RegionsHeader$ Board-specific Template: Board specific template projects provide a meaningful configuration for peripherals on a board. As it is fixed to a board, it may define the target-type along with that packs required. solution: : packs: - pack: NXP::FRDM-MCXN947_BSP # do not use pack version as it is part of a BSP - pack: NXP::MCXN947_DFP - pack: ARM::CMSIS target-types: - type: MCXN947 device: NXP::MCXN947VDF board: NXP::FRDM-MCXN947 Register Template in PDSC File: Templates are published using the <csolution> element in the PDSC file. Device-specific Templates should be part of the DFP. Board-specific templates should be part of the BSP. <csolution> <template name=\"Simple Device project\" path=\"/device/Simple\" file=\"Simple.csolution.yml\" condition=\"Device_Spec\"> <description>Single-core project with empty main function configured for device</description> </template> <template name=\"Simple Board project\" path=\"/board/Simple\" file=\"Simple.csolution.yml\" condition=\"Board_Spec\"> <description>Single-core project with empty main function configured for board</description> </template> </csolution>","title":"Template Projects"},{"location":"pack-tools/#examples","text":"Examples are complete projects that typically run on a board. They should, therefore, specify a target-type with board: and list the packs: that are used, specifically the DFP and BSP. To minimize maintenance of Examples that are part of a pack, consider these rules: IMPORTANT: Store all files that are part of the ./RTE directory . These files store configuration and are important for PLM . Use select-compiler: when the Example works with several toolchains. Do not specify compiler: . Specify minimum pack version . Do not store *.cbuild-pack.yml . The tool selects first target-type and first build-type when cbuild-set.yml is missing. For simple projects, do not store *.cbuild-set.yml . For simple projects, rely on the cdefault.yml file that is provided with CMSIS-Toolbox. Examples that work with several compiler toolchains should use select-compiler: and not define compiler: explicitly. The available toolchain's compiler: node is added when the Example is loaded into the IDE. When minimum pack versions are specified, the semantic versioning of packs should ensure that newer pack versions work also. As the *.cbuild-pack.yml file fixes pack versions, this file should not be stored in the pack. Examples may contain multiple related projects in the *.csolution.yml file that, for example, cover different aspects of peripheral or middleware. For such Examples , it is not required to store the *.cbuild-set.yml file as the tools select the first target-type and build-type of the *.csolution.yml file. Examples that do not require special compiler controls may rely on the cdefault.yml file that is provided with CMSIS-Toolbox as this file contains reasonable default settings. For more complex Examples , provide a local copy of the cdefault.yml file in the same directory as the *.csolution.yml file. Refer to Toolchain Agnostic Project for further information. csolution.yml file of an Example : solution: # Optional: Add a brief description line (recommendation less than 128 characters) description: Example that shows the usage of Fault component on a Cortex-M33 with TrustZone created-for: CMSIS-Toolbox@2.6.0 # minimum CMSIS-Toolbox version, newer versions will work also cdefault: select-compiler: - compiler: GCC # GCC is supported - compiler: AC6 # AC6 is supported - compiler: IAR # IAR is supported packs: - pack: Keil::STM32U5xx_DFP@^2.1.0 # minimum compatible pack version - pack: Keil::B-U585I-IOT02A_BSP@^1.0.0 target-types: - type: B-U585I-IOT02A board: STMicroelectronics::B-U585I-IOT02A device: STMicroelectronics::STM32U585AIIx build-types: - type: Debug debug: on optimize: debug - type: Release debug: off optimize: balanced projects: - project: ./Secure/Fault_S.cproject.yml - project: ./NonSecure/Fault_NS.cproject.yml Register Examples in PDSC File: Examples can be part of any pack and are published using the <examples> element in the PDSC file. Note that it is possible to register multiple project formats to support different tool environments. <examples> <example name=\"Fault example\" folder=\"Examples/Fault/B-U585I-IOT02A\" doc=\"README.md\"> <description>Example that shows the usage of Fault component on a Cortex-M33 with TrustZone</description> <board name=\"B-U585I-IOT02A\" vendor=\"STMicroelectronics\"/> <project> <environment name=\"csolution\" load=\"Fault.csolution.yml\"/> <environment name=\"uv\" load=\"Fault.uvmpw\"/> </project> </example> </examples>","title":"Examples"},{"location":"pack-tools/#reference-applications","text":"Reference applications can run on many different target hardware boards. Similar to template projects , the device: and board: along with the required DFP and BSP pack: is not specified in the *.csolution.yml file. solution: description: IPv4/IPv6 Network examples created-for: CMSIS-Toolbox@2.6.0 cdefault: select-compiler: # list of tested compilers that can be selected - compiler: AC6 - compiler: GCC - compiler: IAR - compiler: CLANG target-types: - type: Name # board: # added during creation of solution # variables: # - Board-Layer: <board_layer>.clayer.yml Note The MDK-Middleware contains several reference applications that exemplify the overall structure. Register Reference Applications in PDSC File: Reference Applications are typically part of a middleware software pack and publish using the <examples> element in the PDSC file. The difference to examples is that no <board> element is used as the reference application is hardware agnostic. <examples> </example> <example name=\"Network\" doc=\"README.md\" folder=\"Examples/Network\"> <description>MDK-Middleware: IPv4/IPv6 Client and Server applications via Ethernet</description> <project> <environment name=\"csolution\" load=\"Network.csolution.yml\"/> </project> </example>","title":"Reference Applications"},{"location":"pack-tools/#layers","text":"Layers with connections are used to by Reference Applications to target hardware. These layers are added when a reference application is configured for a board: , typically in the IDE. Register Layers in PDSC File: Layers are part of a BSP and published using the <csolution> element in the PDSC file. <csolution> <clayer type=\"Board\" path=\"Layers/Default\" file=\"Board.clayer.yml\" copy-to=\"Board/MyBoard\" condition=\"Board-Spec\"/> </csolution> Note Several STM32 Board Support Packs (BSP) contain layers that are pre-configured for certain applications. For example, the layer in the ST_NUCLEO-F756ZG_BSP supports applications that require Ethernet, USB Device, UART, or I2C interfaces.","title":"Layers"},{"location":"pack-tools/#code-templates","text":"Code templates are part of the components files in the PDSC file and can be manually added by the user to a software project. Code templates show how a software component is used, and the source code can be directly adapted to the requirements of the application program. Register Code Templates in PDSC File: Code Templates are part of a software component and published using the <components> element using attr=\"template\" in the PDSC file. <component Cgroup=\"Socket\" Csub=\"UDP\" condition=\"Network Interface\"> : <files> <file category=\"doc\" name=\"Documentation/html/Network/group__netUDP__Func.html\"/> <file category=\"header\" name=\"Components/Network/Config/Net_Config_UDP.h\" attr=\"config\" version=\"5.1.1\"/> <file category=\"source\" name=\"Components/Network/Template/UDP_Socket.c\" attr=\"template\" select=\"UDP Socket\"/> <!-- Library source files --> <file category=\"source\" name=\"Components/Network/Source/net_udp.c\"/> </files> Note The CMSIS-RTX and MDK-Middleware packs contain several code templates that exemplify the overall structure.","title":"Code Templates"},{"location":"pack-tools/#pack-examples","text":"Several pack examples available on github.com/Open-CMSIS-Pack exemplify how to create software packs. Other packs that are a good reference are the various Arm CMSIS packs or the MDK Middleware pack . The source of these packs is available on Github/Arm-software .","title":"Pack Examples"},{"location":"pyOCD-Debugger/","text":"pyOCD Debugger Note This section contains preliminary information and is work-in-progress. The CMSIS-Toolbox organizes for debuggers projects and configuration options. This chapter explains the usage of the pyOCD Debugger in combination with the CMSIS-Toolbox. Extended Options explains additional configuration features that are required in specific use-cases. Command Line Invocation describes how to call pyOCD directly from the command-line. cbuild-run: explains the configuration file that describes the overall pyOCD system setup. Other manual sections describe how to configure debuggers: Run and Debug Configuration explains overall structure and how projects and images are configured. Debugger Configuration - pyOCD contains details about the options that are specific to pyOCD. Extended Options The section CSolution Project Format - pyOCD contains the pyOCD configuration for typical systems. Extended YML options are required to configure specific use-cases or overwrite information that is typically provided in the DFP . CMSIS-DAP based Debug Adapters implement debug access sequences that are configured in the DFP for a device . connect: Configures the behavior for connecting pyOCD to the hardware target. connect: Description mode: Required Selects the connect mode: pre-reset , under-reset , attach , halt . Connect Mode Description pre-reset Apply a hardware reset before connect. Sequence: ResetHardware . under-reset Asserts a hardware reset using during connect and de-asserts after core(s) are halted. Sequence: ResetHardwareAssert , ResetHardwareDeassert . attach Do not change status of the core(s). No sequence is executed. ToDo: review StopProcessor as there is no squence. halt Halt core(s) after connect. Sequence: ResetCatchSet , ResetCatchClear . reset: Configures the reset behavior for each core when a reset is requested. reset: Description - pname: Optional Identifies the processor (not requried for single core system). type: Required Selects the reset type: hardware , system , core . Default: specified in DFP by todo. Reset Types Description hardware Use the Reset pin of the debug adapter. Sequence: ResetHardware . system Use a system-wide reset via software mechanism. Sequence: ResetSystem . core Use a processor reset via software mechanism. Sequence: ResetProcessor Note The defaultResetSequence in DFP element /package/devices/family/.../debug can define a different default reset type. If no defaultResetSequence the default reset type is system . load-setup: Configures the debug sequences executed during the load command of pyOCD. ToDo: missing is a overall flow chart of load and run sequences. When is connect executed, etc. Does pyOCD use Verify? This info may go into pyOCD-Debugger.md. load-cmd: Description halt: Optional Halt core(s) before load: on (default), off . Sequence: ResetCatchSet , ResetCatchClear . pre-reset: Optional Reset type before loading: off , hardware , system , core . Default: specified in DFP (ToDo how???]. post-reset: Optional Reset type after loading: off , hardware (default), system , core . Examples: debugger: name: CMSIS-DAP@pyOCD # default connect, halt and reset behavior debugger: name: CMSIS-DAP@pyOCD connect: under-reset # connect under hardware reset reset: - type: system # use system reset load-setup: halt: on # halt core after load post-reset: hardware # use hardware reset after load debugger: name: CMSIS-DAP@pyOCD connect: pre-reset # apply hardware reset before connect reset: - pname: Core0 # for Core0 type: hardware # use hardware reset - pname: Core1 # for Core1 type: system # use system reset load-stop: post-reset: off # no reset after load trace: Note The trace: feature will be implemented until Dec 2025. This section is only a preview. CMSIS-DAP supports the SWO trace output of Cortex-M devices. The device-specific trace features are configured using the *.dbgconf file. The default trace output file and location is derived from the cbuild-run.yml file and uses the extension <pname>.txt , format: <solution-name>+<target-type>.trace trace: Description mode: Required Trace: off (default), server , file . clock: Required Trace clock frequency in Hz. port-type: Optional Set Trace Port transport mode. Currently only SWO-UART is accepted. baudrate: Optional Maxium baudrate for SWO-UART mode. port: Optional Set TCP/IP port number of Trace Server (default: 5555). file: Optional Explicit path and name of the trace output file. Default: <solution-name>+<target-type>.trace . Command Line Invocation The CMSIS-Toolbox debugger configuration is provided in the file *.cbuild-run.yml . Use the following command line syntax to leverage this information: >pyOCD <command> --cbuild-run <cbuild-run.yml file> [options] <command> Description run Execute application. erase Erase device load Load image to device. <options> Description --timelimit sec Terminate pyOCD when the timelimit is reached. Applies to run command only. --eot Terminate when EOT character ( 0x04 ) is printed via a telnet channel. Applies to run command only. --load Erase device and flash program the images specified in cbuild-run.yml. Applies to run command only. --udi <id> Specify an id of a debug probe Examples: ToDo: command line examples Content of cbuild-run.yml This section details the content of cbuild-run.yml file and how it is used to configure pyOCD. The cbuild-run.yml file is generated by the CMSIS-Toolbox from the information provided in the csolution project . However, it is possible to create a *.cbuild-run.yml file manually and the following section explains the file structure. Configuration File Example: todo cbuild-run: The cbuild-run: node is the start of a *.cbuild-run.yml file. cbuild-run: Content device: Optional Identifies the device. device-pack: Optional Identifies the device pack used. output: Optional Lists the possible compiler selection that this project is tested with. system-resources: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. output: output: Content device: Optional Identifies the device. device-pack: Optional Identifies the device pack used. output: Optional Lists the possible compiler selection that this project is tested with. system-resources: Optional When specified, the cdefault.yml file is used to setup compiler specific controls. system-resources: cbuild-run: device: device-pack: ? is the board-pack: not used? output: - file: info: type: load-offset: load: pname: system-resources: memory: - name: access: start: size: pname: alias: from-pack: system-descriptions: - file: type: pname: debugger: name: clock: dbgconf: start-pname: gdbserver: - port: pname: - port: pname: debug-vars: vars: debug-sequences: - name: info: pname: blocks: - info: if: while: execute: timeout: atomic: blocks: programming: - algorithm: ram-start: size: ram-start: ram-size: pname: debug-topology: debugports: - dpid: accessports: - apid: address: index: processors: - pname: apid: swj: dormant:","title":"pyOCD Debugger"},{"location":"pyOCD-Debugger/#pyocd-debugger","text":"Note This section contains preliminary information and is work-in-progress. The CMSIS-Toolbox organizes for debuggers projects and configuration options. This chapter explains the usage of the pyOCD Debugger in combination with the CMSIS-Toolbox. Extended Options explains additional configuration features that are required in specific use-cases. Command Line Invocation describes how to call pyOCD directly from the command-line. cbuild-run: explains the configuration file that describes the overall pyOCD system setup. Other manual sections describe how to configure debuggers: Run and Debug Configuration explains overall structure and how projects and images are configured. Debugger Configuration - pyOCD contains details about the options that are specific to pyOCD.","title":"pyOCD Debugger"},{"location":"pyOCD-Debugger/#extended-options","text":"The section CSolution Project Format - pyOCD contains the pyOCD configuration for typical systems. Extended YML options are required to configure specific use-cases or overwrite information that is typically provided in the DFP . CMSIS-DAP based Debug Adapters implement debug access sequences that are configured in the DFP for a device .","title":"Extended Options"},{"location":"pyOCD-Debugger/#connect","text":"Configures the behavior for connecting pyOCD to the hardware target. connect: Description mode: Required Selects the connect mode: pre-reset , under-reset , attach , halt . Connect Mode Description pre-reset Apply a hardware reset before connect. Sequence: ResetHardware . under-reset Asserts a hardware reset using during connect and de-asserts after core(s) are halted. Sequence: ResetHardwareAssert , ResetHardwareDeassert . attach Do not change status of the core(s). No sequence is executed. ToDo: review StopProcessor as there is no squence. halt Halt core(s) after connect. Sequence: ResetCatchSet , ResetCatchClear .","title":"connect:"},{"location":"pyOCD-Debugger/#reset","text":"Configures the reset behavior for each core when a reset is requested. reset: Description - pname: Optional Identifies the processor (not requried for single core system). type: Required Selects the reset type: hardware , system , core . Default: specified in DFP by todo. Reset Types Description hardware Use the Reset pin of the debug adapter. Sequence: ResetHardware . system Use a system-wide reset via software mechanism. Sequence: ResetSystem . core Use a processor reset via software mechanism. Sequence: ResetProcessor Note The defaultResetSequence in DFP element /package/devices/family/.../debug can define a different default reset type. If no defaultResetSequence the default reset type is system .","title":"reset:"},{"location":"pyOCD-Debugger/#load-setup","text":"Configures the debug sequences executed during the load command of pyOCD. ToDo: missing is a overall flow chart of load and run sequences. When is connect executed, etc. Does pyOCD use Verify? This info may go into pyOCD-Debugger.md. load-cmd: Description halt: Optional Halt core(s) before load: on (default), off . Sequence: ResetCatchSet , ResetCatchClear . pre-reset: Optional Reset type before loading: off , hardware , system , core . Default: specified in DFP (ToDo how???]. post-reset: Optional Reset type after loading: off , hardware (default), system , core . Examples: debugger: name: CMSIS-DAP@pyOCD # default connect, halt and reset behavior debugger: name: CMSIS-DAP@pyOCD connect: under-reset # connect under hardware reset reset: - type: system # use system reset load-setup: halt: on # halt core after load post-reset: hardware # use hardware reset after load debugger: name: CMSIS-DAP@pyOCD connect: pre-reset # apply hardware reset before connect reset: - pname: Core0 # for Core0 type: hardware # use hardware reset - pname: Core1 # for Core1 type: system # use system reset load-stop: post-reset: off # no reset after load","title":"load-setup:"},{"location":"pyOCD-Debugger/#trace","text":"Note The trace: feature will be implemented until Dec 2025. This section is only a preview. CMSIS-DAP supports the SWO trace output of Cortex-M devices. The device-specific trace features are configured using the *.dbgconf file. The default trace output file and location is derived from the cbuild-run.yml file and uses the extension <pname>.txt , format: <solution-name>+<target-type>.trace trace: Description mode: Required Trace: off (default), server , file . clock: Required Trace clock frequency in Hz. port-type: Optional Set Trace Port transport mode. Currently only SWO-UART is accepted. baudrate: Optional Maxium baudrate for SWO-UART mode. port: Optional Set TCP/IP port number of Trace Server (default: 5555). file: Optional Explicit path and name of the trace output file. Default: <solution-name>+<target-type>.trace .","title":"trace:"},{"location":"pyOCD-Debugger/#command-line-invocation","text":"The CMSIS-Toolbox debugger configuration is provided in the file *.cbuild-run.yml . Use the following command line syntax to leverage this information: >pyOCD <command> --cbuild-run <cbuild-run.yml file> [options] <command> Description run Execute application. erase Erase device load Load image to device. <options> Description --timelimit sec Terminate pyOCD when the timelimit is reached. Applies to run command only. --eot Terminate when EOT character ( 0x04 ) is printed via a telnet channel. Applies to run command only. --load Erase device and flash program the images specified in cbuild-run.yml. Applies to run command only. --udi <id> Specify an id of a debug probe Examples: ToDo: command line examples","title":"Command Line Invocation"},{"location":"pyOCD-Debugger/#content-of-cbuild-runyml","text":"This section details the content of cbuild-run.yml file and how it is used to configure pyOCD. The cbuild-run.yml file is generated by the CMSIS-Toolbox from the information provided in the csolution project . However, it is possible to create a *.cbuild-run.yml file manually and the following section explains the file structure. Configuration File Example: todo","title":"Content of cbuild-run.yml"},{"location":"pyOCD-Debugger/#cbuild-run","text":"The cbuild-run: node is the start of a *.cbuild-run.yml file. cbuild-run: Content device: Optional Identifies the device. device-pack: Optional Identifies the device pack used. output: Optional Lists the possible compiler selection that this project is tested with. system-resources: Optional When specified, the cdefault.yml file is used to setup compiler specific controls.","title":"cbuild-run:"},{"location":"pyOCD-Debugger/#output","text":"output: Content device: Optional Identifies the device. device-pack: Optional Identifies the device pack used. output: Optional Lists the possible compiler selection that this project is tested with. system-resources: Optional When specified, the cdefault.yml file is used to setup compiler specific controls.","title":"output:"},{"location":"pyOCD-Debugger/#system-resources","text":"cbuild-run: device: device-pack: ? is the board-pack: not used? output: - file: info: type: load-offset: load: pname: system-resources: memory: - name: access: start: size: pname: alias: from-pack: system-descriptions: - file: type: pname: debugger: name: clock: dbgconf: start-pname: gdbserver: - port: pname: - port: pname: debug-vars: vars: debug-sequences: - name: info: pname: blocks: - info: if: while: execute: timeout: atomic: blocks: programming: - algorithm: ram-start: size: ram-start: ram-size: pname: debug-topology: debugports: - dpid: accessports: - apid: address: index: processors: - pname: apid: swj: dormant:","title":"system-resources:"}]}